<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Vicky's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://vickyqi.com/"/>
  <updated>2015-12-01T04:47:52.000Z</updated>
  <id>http://vickyqi.com/</id>
  
  <author>
    <name><![CDATA[Vicky]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[JDK并发工具类源码学习系列——SynchronousQueue]]></title>
    <link href="http://vickyqi.com/2015/11/30/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94SynchronousQueue/"/>
    <id>http://vickyqi.com/2015/11/30/JDK并发工具类源码学习系列——SynchronousQueue/</id>
    <published>2015-11-30T11:18:11.000Z</published>
    <updated>2015-12-01T04:47:52.000Z</updated>
    <content type="html"><![CDATA[<p>SynchronousQueue是一种特殊的阻塞队列，不同于<a href="http://vickyqi.com/2015/11/23/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94LinkedBlockingQueue/">LinkedBlockingQueue</a>、ArrayBlockingQueue和<a href="http://vickyqi.com/2015/11/20/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94PriorityBlockingQueue/">PriorityBlockingQueue</a>，其内部没有任何容量，任何的入队操作都需要等待其他线程的出队操作，反之亦然。如果将SynchronousQueue用于生产者/消费者模式，那么相当于生产者和消费者手递手交易，即生产者生产出一个货物，则必须等到消费者过来取货，方可完成交易。<br>SynchronousQueue有一个fair选项，如果fair为true，称为fair模式，否则就是unfair模式。fair模式使用一个先进先出的队列保存生产者或者消费者线程，unfair模式则使用一个后进先出的栈保存。</p>
<h3 id="基本原理"><strong>基本原理</strong></h3><p>SynchronousQueue通过将入队出队的线程绑定到队列的节点上，并借助LockSupport的park()和unpark()实现等待，先到达的线程A需调用LockSupport的park()方法将当前线程进入阻塞状态，知道另一个与之匹配的线程B调用LockSupport.unpark(Thread)来唤醒在该节点上等待的线程A。<br>基本逻辑：</p>
<ol>
<li>初始状态队列为null</li>
<li>当一个线程到达，如果队列为null，无与之匹配的线程，则进入队列等待；队列不为null，参考3</li>
<li>当另一个线程到达，如果队列不为null，则判断队列中的第一个元素（针对fair和unfair不同）是否与其匹配，如果匹配则完成交易，不匹配则也入队；队列为null，参考2</li>
</ol>
<h3 id="常用方法解析"><strong>常用方法解析</strong></h3><p>在深入分析其实现机制之前，我们先了解对于SynchronousQueue可执行哪些操作，由于SynchronousQueue的容量为0，所以一些针对集合的操作，如：isEmpty()/size()/clear()/remove(Object)/contains(Object)等操作都是无意义的，同样peek()也总是返回null。所以针对SynchronousQueue只有两类操作：</p>
<ul>
<li>入队（put(E)/offer(E, long, TimeUnit)/offer(E)）</li>
<li>出队（take()/poll(long, TimeUnit)/poll()）</li>
</ul>
<p>这两类操作内部都是调用Transferer的transfer(Object, boolean, long)方法，通过第一个参数是否为null，来区分是生产者还是消费者（生产者不为null）。<br>针对以上情况，我们将着重分析Transferer的transfer(Object, boolean, long)方法，这里由于两种不同的公平模式，会存在两个Transferer的派生类：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    transferer = (fair)? <span class="keyword">new</span> TransferQueue() : <span class="keyword">new</span> TransferStack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见fair模式使用TransferQueue，unfair模式使用TransferStack，下面我们将分别对这两种模式进行着重分析。</p>
<h3 id="fair模式"><strong>fair模式</strong></h3><p>fair模式使用一个FIFO的队列保存线程，TransferQueue的结构如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Dual Queue */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> TransferQueue <span class="keyword">extends</span> Transferer &#123;</span><br><span class="line">	<span class="comment">/** Node class for TransferQueue. */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> QNode &#123;</span><br><span class="line">		<span class="keyword">volatile</span> QNode <span class="keyword">next</span>;          <span class="comment">// next node in queue</span></span><br><span class="line">		<span class="keyword">volatile</span> Object item;         <span class="comment">// CAS'ed to or from null</span></span><br><span class="line">		<span class="keyword">volatile</span> Thread waiter;       <span class="comment">// to control park/unpark</span></span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">boolean</span> isData;</span><br><span class="line"></span><br><span class="line">		QNode(Object item, <span class="keyword">boolean</span> isData) &#123;</span><br><span class="line">			<span class="keyword">this</span>.item = item;</span><br><span class="line">			<span class="keyword">this</span>.isData = isData;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Head of queue */</span></span><br><span class="line">	<span class="keyword">transient</span> <span class="keyword">volatile</span> QNode head;</span><br><span class="line">	<span class="comment">/** Tail of queue */</span></span><br><span class="line">	<span class="keyword">transient</span> <span class="keyword">volatile</span> QNode tail;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * Reference to a cancelled node that might not yet have been</span><br><span class="line">	 * unlinked from queue because it was the last inserted node</span><br><span class="line">	 * when it cancelled.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">transient</span> <span class="keyword">volatile</span> QNode cleanMe;</span><br><span class="line"></span><br><span class="line">	TransferQueue() &#123;</span><br><span class="line">		QNode h = <span class="keyword">new</span> QNode(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// initialize to dummy node.</span></span><br><span class="line">		head = h;</span><br><span class="line">		tail = h;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上是TransferQueue的大致结构，可以看到TransferQueue同一个普通的队列，同时存在一个指向队列头部的指针——head，和一个指向队列尾部的指针——tail；cleanMe的存在主要是解决不可清楚队列的尾节点的问题，后面会介绍到；队列的节点通过内部类QNode封装，QNode包含四个变量：</p>
<ul>
<li>next：指向队列中的下一个节点</li>
<li>item：节点包含的数据</li>
<li>waiter：等待在该节点上的线程</li>
<li>isData：表示该节点由生产者创建还是由消费者创建，由于生产者是放入数据，所以isData==true，而消费者==false</li>
</ul>
<p>其他的内容就是一些CAS变量以及操作，下面主要分析TransferQueue的三个重要方法：transfer(Object, boolean, long)、awaitFulfill(QNode, Object, boolean, long)、clean(QNode, QNode)。这三个方法是TransferQueue的核心，入口是transfer()，下面具体看代码。</p>
<h4 id="transfer"><strong>transfer</strong></h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @By Vicky:交换数据，生产者和消费者通过e==null来区分</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">Object</span> transfer(<span class="keyword">Object</span> e, <span class="built_in">boolean</span> timed, <span class="keyword">long</span> nanos) &#123;</span><br><span class="line">	QNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">	<span class="built_in">boolean</span> isData = (e != <span class="keyword">null</span>);<span class="comment">// e==null，则isData==false,else idData==true</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;<span class="comment">// 循环</span></span><br><span class="line">		QNode t = tail;</span><br><span class="line">		QNode h = head;</span><br><span class="line">		<span class="keyword">if</span> (t == <span class="keyword">null</span> || h == <span class="keyword">null</span>)         <span class="comment">// 无视即可，具体信息在方法开始的注释中有提到</span></span><br><span class="line">			<span class="keyword">continue</span>;                       <span class="comment">// spin</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// h==t队列为null,tail的isData==isData表示该队列中的等待的线程与当前线程是相同模式</span></span><br><span class="line">		<span class="comment">//（同为生产者，或者同为消费者）（队列中只存在一种模式的线程）</span></span><br><span class="line">		<span class="comment">// 此时需要将该线程插入到队列中进行等待</span></span><br><span class="line">		<span class="keyword">if</span> (h == t || t.isData == isData) &#123; </span><br><span class="line">			QNode tn = t.next;</span><br><span class="line">			<span class="keyword">if</span> (t != tail)                  <span class="comment">// inconsistent read</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 这里的目的是为了帮助其他线程完成入队操作</span></span><br><span class="line">			<span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;               <span class="comment">// lagging tail</span></span><br><span class="line">				<span class="comment">// 原子性将tail从t更新为tn，即将tail往后移动，直到队列的最后一个元素</span></span><br><span class="line">				advanceTail(t, tn);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果nanos&lt;=0则说明不等待，那么到这里已经说到队列没有可匹配的线程，所以直接返回null即可</span></span><br><span class="line">			<span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)        <span class="comment">// can't wait</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			<span class="comment">// 仅初始化一次s，节点s会保存isData信息作为生产者和消费者的区分</span></span><br><span class="line">			<span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">				s = <span class="keyword">new</span> QNode(e, isData);</span><br><span class="line">			<span class="comment">// 原子性的更新t的next指针指向s，上面将tail从t更新为tn就是为了处理此处剩下的操作</span></span><br><span class="line">			<span class="comment">// 由于此处插入一个节点分成了两个步骤，所以过程中会插入其他线程，导致看到不一致状态</span></span><br><span class="line">			<span class="comment">// 所以其他线程会执行剩下的步骤帮助其完成入队操作</span></span><br><span class="line">			<span class="keyword">if</span> (!t.casNext(<span class="keyword">null</span>, s))        <span class="comment">// failed to link in</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果自己执行失败没有关系，会有其他线程帮忙执行完成的，所以才无需锁，类似ConcurrentLinkedQueue</span></span><br><span class="line">			advanceTail(t, s);              <span class="comment">// swing tail and wait</span></span><br><span class="line">			<span class="comment">// 等待匹配</span></span><br><span class="line">			<span class="keyword">Object</span> x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line">			<span class="comment">// 这里有两种情况：</span></span><br><span class="line">			<span class="comment">//	A:匹配完成，返回数据</span></span><br><span class="line">			<span class="comment">//	B:等待超时/取消，返回原节点s</span></span><br><span class="line">			<span class="keyword">if</span> (x == s) &#123;                   <span class="comment">// wait was cancelled</span></span><br><span class="line">				<span class="comment">// 情况B则需要清除掉节点s</span></span><br><span class="line">				clean(t, s);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 情况A，则匹配成功了，但是还需要将该节点从队列中移除</span></span><br><span class="line">			<span class="comment">//  由于FIFO原则，所以匹配上的元素必然是队列的第一个元素，所以只需要移动head即可</span></span><br><span class="line">			<span class="keyword">if</span> (!s.isOffList()) &#123;           <span class="comment">// not already unlinked</span></span><br><span class="line">				<span class="comment">// 移动head指向s，则下次匹配从s.next开始</span></span><br><span class="line">				advanceHead(t, s);          <span class="comment">// unlink if head</span></span><br><span class="line">				<span class="comment">// 清除对节点中保存的数据的引用，GC友好</span></span><br><span class="line">				<span class="keyword">if</span> (x != <span class="keyword">null</span>)              <span class="comment">// and forget fields</span></span><br><span class="line">					s.item = s;</span><br><span class="line">				s.waiter = <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> (x != <span class="keyword">null</span>)? x : e;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;                            <span class="comment">// complementary-mode</span></span><br><span class="line">			<span class="comment">// 进行匹配，从队列的头部开始，即head.next，非head</span></span><br><span class="line">			QNode m = h.next;               <span class="comment">// node to fulfill</span></span><br><span class="line">			<span class="keyword">if</span> (t != tail || m == <span class="keyword">null</span> || h != head)</span><br><span class="line">				<span class="keyword">continue</span>;                   <span class="comment">// inconsistent read</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 判断该节点的isData是否与当前线程的isData匹配</span></span><br><span class="line">			<span class="comment">// 相等则说明m已经匹配过了，因为正常情况是不相等才对</span></span><br><span class="line">			<span class="comment">// x==m说明m被取消了，见QNode的tryCancel()方法</span></span><br><span class="line">			<span class="comment">// CAS设置m.item为e，这里的e，如果是生产者则是数据，消费者则是null，</span></span><br><span class="line">			<span class="comment">// 所以m如果是生产者，则item变为null，消费者则变为生产者的数据</span></span><br><span class="line">			<span class="comment">// CAS操作失败，则直接将m出队，CAS失败说明m已经被其他线程匹配了，所以将其出队，然后retry</span></span><br><span class="line">			<span class="keyword">Object</span> x = m.item;</span><br><span class="line">			<span class="keyword">if</span> (isData == (x != <span class="keyword">null</span>) ||    <span class="comment">// m already fulfilled</span></span><br><span class="line">				x == m ||                   <span class="comment">// m cancelled</span></span><br><span class="line">				!m.casItem(x, e)) &#123;         <span class="comment">// lost CAS</span></span><br><span class="line">				advanceHead(h, m);          <span class="comment">// dequeue and retry</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 与m匹配成功，将m出队，并唤醒等待在m上的线程m.waiter</span></span><br><span class="line">			advanceHead(h, m);              <span class="comment">// successfully fulfilled</span></span><br><span class="line">			LockSupport.unpark(m.waiter);</span><br><span class="line">			<span class="keyword">return</span> (x != <span class="keyword">null</span>)? x : e;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出TransferQueue.transfer()的整体流程：</p>
<ol>
<li>判断当前队列是否为null或者队尾线程是否与当前线程匹配，为null或者不匹配都将进行入队操作</li>
<li>入队主要很简单，分成两步：修改tail的next为新的节点，修改tail为新的节点，这两步操作有可能分在两个不同的线程执行，不过不影响执行结果</li>
<li>入队之后需要将当前线程阻塞，调用LockSupport.park()方法，直到打断/超时/被匹配的线程唤醒</li>
<li>如果被取消，则需要调用clean()方法进行清除</li>
<li>由于FIFO，所以匹配总是发生在队列的头部，匹配将修改等待节点的item属性传递数据，同时唤醒等待在节点上的线程</li>
</ol>
<h4 id="awaitFulfill"><strong>awaitFulfill</strong></h4><p>下面看看具体如何让一个线程进入阻塞。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *@ By Vicky:等待匹配，该方法会进入阻塞，直到三种情况下才返回：</span><br><span class="line"> *	a.等待被取消了，返回值为s</span><br><span class="line"> *	b.匹配上了，返回另一个线程传过来的值</span><br><span class="line"> *	c.线程被打断，会取消，返回值为s</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">Object <span class="title">awaitFulfill</span><span class="params">(QNode s, Object e, boolean timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// timed==false，则不等待，lastTime==0即可</span></span><br><span class="line">	<span class="keyword">long</span> lastTime = (timed)? System.nanoTime() : <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 当前线程</span></span><br><span class="line">	Thread w = Thread.currentThread();</span><br><span class="line">	<span class="comment">// 循环次数，原理同自旋锁，如果不是队列的第一个元素则不自旋，因为压根轮不上他，自旋只是浪费CPU</span></span><br><span class="line">	<span class="comment">// 如果等待的话则自旋的次数少些，不等待就多些</span></span><br><span class="line">	<span class="keyword">int</span> spins = ((head.next == s) ?</span><br><span class="line">				 (timed? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (w.isInterrupted())<span class="comment">// 支持打断</span></span><br><span class="line">			s.tryCancel(e);</span><br><span class="line">		<span class="comment">// 如果s的item不等于e，有三种情况：</span></span><br><span class="line">		<span class="comment">// a.等待被取消了，此时x==s</span></span><br><span class="line">		<span class="comment">// b.匹配上了，此时x==另一个线程传过来的值</span></span><br><span class="line">		<span class="comment">// c.线程被打断，会取消，此时x==s</span></span><br><span class="line">		<span class="comment">// 不管是哪种情况都不要再等待了，返回即可</span></span><br><span class="line">		Object x = s.item;</span><br><span class="line">		<span class="keyword">if</span> (x != e)</span><br><span class="line">			<span class="keyword">return</span> x;</span><br><span class="line">		<span class="comment">// 等到，直接超时取消</span></span><br><span class="line">		<span class="keyword">if</span> (timed) &#123;</span><br><span class="line">			<span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">			nanos -= now - lastTime;</span><br><span class="line">			lastTime = now;</span><br><span class="line">			<span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				s.tryCancel(e);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 自旋，直到spins==0，进入等待</span></span><br><span class="line">		<span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">			--spins;</span><br><span class="line">		<span class="comment">// 设置等待线程</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == null)</span><br><span class="line">			s.waiter = w;</span><br><span class="line">		<span class="comment">// 调用LockSupport.park进入等待</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">			LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">			LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>awaitFulfill()主要涉及自旋以及LockSupport.park()两个关键点，自旋可去了解自旋锁的原理。</p>
<blockquote>
<p>自旋锁原理：通过空循环则霸占着CPU，避免当前线程进入睡眠，因为睡眠/唤醒是需要进行线程上下文切换的，所以如果线程睡眠的时间很段，那么使用空循环能够避免线程进入睡眠的耗时，从而快速响应。但是由于空循环会浪费CPU，所以也不能一直循环。自旋锁一般适合同步快很小，竞争不是很激烈的场景。</p>
</blockquote>
<p>LockSupport.park()可到API文档进行了解。</p>
<h4 id="clean"><strong>clean</strong></h4><p>下面再看看如何清除被取消的节点。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *@By Vicky:清除节点被取消的节点 </span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">void</span> clean(QNode pred, QNode s) &#123;</span><br><span class="line">	s.waiter = <span class="keyword">null</span>; <span class="comment">// forget thread</span></span><br><span class="line">	<span class="comment">// 如果pred.next!=s则说明s已经出队了</span></span><br><span class="line">	<span class="keyword">while</span> (pred.<span class="keyword">next</span> == s) &#123; <span class="comment">// Return early if already unlinked</span></span><br><span class="line">		QNode h = head;</span><br><span class="line">		QNode hn = h.<span class="keyword">next</span>;   <span class="comment">// Absorb cancelled first node as head</span></span><br><span class="line">		<span class="comment">// 从队列头部开始遍历，遇到被取消的节点则将其出队 </span></span><br><span class="line">		<span class="keyword">if</span> (hn != <span class="keyword">null</span> &amp;&amp; hn.isCancelled()) &#123;</span><br><span class="line">			advanceHead(h, hn);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		QNode t = tail;      <span class="comment">// Ensure consistent read for tail</span></span><br><span class="line">		<span class="comment">// t==h则队列为null</span></span><br><span class="line">		<span class="keyword">if</span> (t == h)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		QNode tn = t.<span class="keyword">next</span>;</span><br><span class="line">		<span class="keyword">if</span> (t != tail)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// 帮助其他线程入队</span></span><br><span class="line">		<span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;</span><br><span class="line">			advanceTail(t, tn);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 只能出队非尾节点</span></span><br><span class="line">		<span class="keyword">if</span> (s != t) &#123;        <span class="comment">// If not tail, try to unsplice</span></span><br><span class="line">			<span class="comment">// 出队方式很简单，将pred.next指向s.next即可</span></span><br><span class="line">			QNode sn = s.<span class="keyword">next</span>;</span><br><span class="line">			<span class="keyword">if</span> (sn == s || pred.casNext(s, sn))</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果s是队尾元素，那么就需要cleanMe出场了，如果cleanMe==null，则只需将pred赋值给cleanMe即可，</span></span><br><span class="line">		<span class="comment">// 赋值cleanMe的意思是等到s不是队尾时再进行清除，毕竟队尾只有一个</span></span><br><span class="line">		<span class="comment">// 同时将上次的cleanMe清除掉，正常情况下此时的cleanMe已经不是队尾了，因为当前需要清除的节点是队尾</span></span><br><span class="line">		<span class="comment">// (上面说的cleanMe其实是需要清除的节点的前继节点)</span></span><br><span class="line">		QNode dp = cleanMe;</span><br><span class="line">		<span class="keyword">if</span> (dp != <span class="keyword">null</span>) &#123;    <span class="comment">// Try unlinking previous cancelled node</span></span><br><span class="line">			QNode d = dp.<span class="keyword">next</span>;</span><br><span class="line">			QNode dn;</span><br><span class="line">			<span class="comment">// d==null说明需要清除的节点已经没了</span></span><br><span class="line">			<span class="comment">// d==dp说明dp已经被清除了，那么dp.next也一并被清除了</span></span><br><span class="line">			<span class="comment">// 如果d未被取消，说明哪里出错了，将cleanMe清除，不清除这个节点了</span></span><br><span class="line">			<span class="comment">// 后面括号将清除cleanMe的next出局，前提是cleanMe.next没有已经被出局</span></span><br><span class="line">			<span class="keyword">if</span> (d == <span class="keyword">null</span> ||               <span class="comment">// d is gone or</span></span><br><span class="line">				d == dp ||                 <span class="comment">// d is off list or</span></span><br><span class="line">				!d.isCancelled() ||        <span class="comment">// d not cancelled or</span></span><br><span class="line">				(d != t &amp;&amp;                 <span class="comment">// d not tail and</span></span><br><span class="line">				 (dn = d.<span class="keyword">next</span>) != <span class="keyword">null</span> &amp;&amp;  <span class="comment">//   has successor</span></span><br><span class="line">				 dn != d &amp;&amp;                <span class="comment">//   that is on list</span></span><br><span class="line">				 dp.casNext(d, dn)))       <span class="comment">// d unspliced</span></span><br><span class="line">				casCleanMe(dp, <span class="keyword">null</span>);</span><br><span class="line">			<span class="comment">// dp==pred说明cleanMe.next已经其他线程被更新了</span></span><br><span class="line">			<span class="keyword">if</span> (dp == pred)</span><br><span class="line">				<span class="keyword">return</span>;      <span class="comment">// s is already saved node</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (casCleanMe(<span class="keyword">null</span>, pred))</span><br><span class="line">			<span class="keyword">return</span>;          <span class="comment">// Postpone cleaning s</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>清除节点时有个原则：不能清除队尾节点。所以如果对尾节点需要被清除，则将其保存到cleanMe变量，等待下次进行清除。在清除cleanMe时可能说的有点模糊，因为涉及到太多的并发会出现很多情况，所以if条件太多，导致难以分析全部情况。</p>
<p>以上就是TransferQueue的操作逻辑，下面看看后进先出的TransferStack。</p>
<h3 id="unfair模式"><strong>unfair模式</strong></h3><p>unfair模式使用一个LIFO的队列保存线程，TransferStack的结构如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="emphasis">** Dual stack *</span>/</span></span></span><br><span class="line"><span class="literal">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferStack</span> <span class="keyword">extends</span> <span class="title">Transferer</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* Modes for SNodes, ORed together in node fields */</span></span><br><span class="line">	<span class="comment"><span class="markdown">/** Node represents </span>an<span class="markdown"> unfulfilled consumer */</span></span></span><br><span class="line">	<span class="literal">static</span> <span class="keyword">final</span> <span class="built_in">int</span> REQUEST    = <span class="number">0</span>;<span class="comment">// 消费者请求数据</span></span><br><span class="line">	<span class="comment"><span class="markdown">/** Node represents </span>an<span class="markdown"> unfulfilled producer */</span></span></span><br><span class="line">	<span class="literal">static</span> <span class="keyword">final</span> <span class="built_in">int</span> DATA       = <span class="number">1</span>;<span class="comment">// 生产者生产数据</span></span><br><span class="line">	<span class="comment"><span class="markdown">/<span class="emphasis">** Node is fulfilling another unfulfilled DATA or REQUEST *</span>/</span></span></span><br><span class="line">	<span class="literal">static</span> <span class="keyword">final</span> <span class="built_in">int</span> FULFILLING = <span class="number">2</span>;<span class="comment">// 正在匹配中...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"><span class="markdown">/<span class="emphasis">** 只需要判断mode的第二位是否==1即可，==1则正在匹配中...*</span>/</span></span></span><br><span class="line">	<span class="literal">static</span> boolean isFulfilling(<span class="built_in">int</span> m) &#123; <span class="keyword">return</span> (m &amp; FULFILLING) != <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment"><span class="markdown">/<span class="emphasis">** Node class for TransferStacks. *</span>/</span></span></span><br><span class="line">	<span class="literal">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SNode</span> </span>&#123;</span><br><span class="line">		volatile SNode next;        <span class="comment">// next node in stack</span></span><br><span class="line">		volatile SNode match;       <span class="comment">// the node matched to this</span></span><br><span class="line">		volatile Thread waiter;     <span class="comment">// to control park/unpark</span></span><br><span class="line">		<span class="built_in">Object</span> item;                <span class="comment">// data; or null for REQUESTs</span></span><br><span class="line">		<span class="built_in">int</span> mode;</span><br><span class="line">		<span class="comment">// <span class="doctag">Note:</span> item and mode fields don't need to be volatile</span></span><br><span class="line">		<span class="comment">// since they are always written before, and read after,</span></span><br><span class="line">		<span class="comment">// other volatile/atomic operations.</span></span><br><span class="line"></span><br><span class="line">		SNode(<span class="built_in">Object</span> item) &#123;</span><br><span class="line">			<span class="keyword">this</span>.item = item;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment"><span class="markdown">/** The head (top) of </span>the<span class="markdown"> stack */</span></span></span><br><span class="line">	volatile SNode head;</span><br><span class="line"></span><br><span class="line">	<span class="literal">static</span> SNode snode(SNode s, <span class="built_in">Object</span> e, SNode next, <span class="built_in">int</span> mode) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="keyword">null</span>) s = <span class="keyword">new</span> SNode(e);</span><br><span class="line">		s.mode = mode;</span><br><span class="line">		s.next = next;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TransferStacks比TransferQueue的结构复杂些。使用一个head指向栈顶元素，使用内部类SNode封装栈中的节点信息，SNode包含5个变量：</p>
<ul>
<li>next：指向栈中下一个节点</li>
<li>match：与之匹配的节点</li>
<li>waiter：等待的线程</li>
<li>item：数据</li>
<li>mode：模式，对应REQUEST/DATA/FULFILLING（第三个并不是FULFILLING，而是FULFILLING | REQUEST或者FULFILLING | DATA）</li>
</ul>
<p>SNode的5个变量，三个是volatile的，另外两个item和mode没有volatile修饰，代码注释给出的解释是：对这两个变量的写总是发生在volatile/原子操作的之前，读总是发生在volatile/原子操作的之后。</p>
<p>上面提到SNode.mode的三个常量表示栈中节点的状态,f分别为：</p>
<ul>
<li>REQUEST：0，消费者的请求生成的节点</li>
<li>DATA：1，生产者的请求生成的节点</li>
<li>FULFILLING：2，正在匹配中的节点，具体对应的mode值是FULFILLING | REQUEST和FULFILLING | DATA</li>
</ul>
<p>其他内部基本同TransferQueue，不同之处是当匹配到一个节点时并非是将被匹配的节点出栈，而是将匹配的节点入栈，然后同时将匹配上的两个节点一起出栈。下面我们参照TransferQueue来看看TransferStacks的三个方法：transfer(Object, boolean, long)、awaitFulfill(QNode, Object, boolean, long)、clean(QNode, QNode)。</p>
<h4 id="transfer-1"><strong>transfer</strong></h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @By Vicky:交换数据，生产者和消费者通过e==null来区分</span><br><span class="line"> */</span></span><br><span class="line">Object transfer(Object <span class="keyword">e</span>, boolean timed, long nanos) &#123;</span><br><span class="line">	SNode s = null; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">	int mode = (<span class="keyword">e</span> == null)? REQUEST : DATA;<span class="comment">// 根据e==null判断生产者还是消费者，对应不同的mode值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		SNode <span class="keyword">h</span> = head;</span><br><span class="line">		<span class="comment">// 栈为null或者栈顶元素的模式同当前模式，则进行入栈操作</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">h</span> == null || <span class="keyword">h</span>.mode == mode) &#123;  <span class="comment">// empty or same-mode</span></span><br><span class="line">			<span class="comment">// 不等待，则直接返回null，返回之前顺带清理下被取消的元素</span></span><br><span class="line">			<span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= 0) &#123;      <span class="comment">// can't wait</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">h</span> != null &amp;&amp; <span class="keyword">h</span>.isCancelled())</span><br><span class="line">					casHead(<span class="keyword">h</span>, <span class="keyword">h</span>.next);     <span class="comment">// pop cancelled node</span></span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="keyword">return</span> null;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(<span class="keyword">h</span>, s = snode(s, <span class="keyword">e</span>, <span class="keyword">h</span>, mode))) &#123;<span class="comment">// 入栈，更新栈顶为新节点</span></span><br><span class="line">				<span class="comment">// 等待，返回值m==s，则被取消，需清除</span></span><br><span class="line">				SNode <span class="keyword">m</span> = awaitFulfill(s, timed, nanos);</span><br><span class="line">				<span class="comment">// m==s说明s被取消了，清除</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">m</span> == s) &#123;               <span class="comment">// wait was cancelled</span></span><br><span class="line">					clean(s);</span><br><span class="line">					<span class="keyword">return</span> null;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 帮忙出栈</span></span><br><span class="line">				<span class="keyword">if</span> ((<span class="keyword">h</span> = head) != null &amp;&amp; <span class="keyword">h</span>.next == s)</span><br><span class="line">					casHead(<span class="keyword">h</span>, s.next);     <span class="comment">// help s's fulfiller</span></span><br><span class="line">				<span class="comment">// 消费者则返回生产者的数据，生产者则返回自己的数据</span></span><br><span class="line">				<span class="keyword">return</span> mode == REQUEST? <span class="keyword">m</span>.item : s.item;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(<span class="keyword">h</span>.mode)) &#123; <span class="comment">// try to fulfill	// 栈顶未开始匹配，则开始匹配</span></span><br><span class="line">			<span class="comment">// h被取消，则出栈</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">h</span>.isCancelled())            <span class="comment">// already cancelled</span></span><br><span class="line">				casHead(<span class="keyword">h</span>, <span class="keyword">h</span>.next);         <span class="comment">// pop and retry</span></span><br><span class="line">			<span class="comment">// 更新栈顶为新插入的节点，并更新节点的mode为FULFILLING，对应判断是否正在出栈的方法</span></span><br><span class="line">			<span class="comment">// 匹配需要先将待匹配的节点入栈，所以不管是匹配还是不匹配都需要创建一个节点入栈</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (casHead(<span class="keyword">h</span>, s=snode(s, <span class="keyword">e</span>, <span class="keyword">h</span>, FULFILLING|mode))) &#123;</span><br><span class="line">				<span class="comment">// 循环直到找到一个可以匹配的节点</span></span><br><span class="line">				<span class="keyword">for</span> (;;) &#123; <span class="comment">// loop until matched or waiters disappear</span></span><br><span class="line">					<span class="comment">// m即与s匹配的节点</span></span><br><span class="line">					SNode <span class="keyword">m</span> = s.next;       <span class="comment">// m is s's match</span></span><br><span class="line">					<span class="comment">// m==null说明栈s之后无元素了，直接将栈顶设置为null，并重新进行最外层的循环</span></span><br><span class="line">					<span class="keyword">if</span> (<span class="keyword">m</span> == null) &#123;        <span class="comment">// all waiters are gone</span></span><br><span class="line">						casHead(s, null);   <span class="comment">// pop fulfill node</span></span><br><span class="line">						s = null;           <span class="comment">// use new node next time</span></span><br><span class="line">						<span class="keyword">break</span>;              <span class="comment">// restart main loop</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 将s设置为m的匹配节点，并更新栈顶为m.next，即将s和m同时出栈</span></span><br><span class="line">					SNode mn = <span class="keyword">m</span>.next;</span><br><span class="line">					<span class="keyword">if</span> (<span class="keyword">m</span>.tryMatch(s)) &#123;</span><br><span class="line">						casHead(s, mn);     <span class="comment">// pop both s and m</span></span><br><span class="line">						<span class="keyword">return</span> (mode == REQUEST)? <span class="keyword">m</span>.item : s.item;</span><br><span class="line">					&#125; <span class="keyword">else</span>                  <span class="comment">// lost match</span></span><br><span class="line">						<span class="comment">// 设置匹配失败，则说明m正准备出栈，帮助出栈</span></span><br><span class="line">						s.casNext(<span class="keyword">m</span>, mn);   <span class="comment">// help unlink</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;                            <span class="comment">// help a fulfiller	// 栈顶已开始匹配，帮助匹配</span></span><br><span class="line">			<span class="comment">// 此处的操作逻辑同上面的操作逻辑一致，目的就是帮助上面进行操作，因为此处完成匹配需要分成两步：</span></span><br><span class="line">			<span class="comment">// a.m.tryMatch(s)和b.casHead(s, mn)</span></span><br><span class="line">			<span class="comment">// 所以必然会插入其他线程，只要插入的线程也按照这个步骤执行那么就避免了不一致问题</span></span><br><span class="line">			SNode <span class="keyword">m</span> = <span class="keyword">h</span>.next;               <span class="comment">// m is h's match</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">m</span> == null)                  <span class="comment">// waiter is gone</span></span><br><span class="line">				casHead(<span class="keyword">h</span>, null);           <span class="comment">// pop fulfilling node</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				SNode mn = <span class="keyword">m</span>.next;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">m</span>.tryMatch(<span class="keyword">h</span>))          <span class="comment">// help match</span></span><br><span class="line">					casHead(<span class="keyword">h</span>, mn);         <span class="comment">// pop both h and m</span></span><br><span class="line">				<span class="keyword">else</span>                        <span class="comment">// lost match</span></span><br><span class="line">					<span class="keyword">h</span>.casNext(<span class="keyword">m</span>, mn);       <span class="comment">// help unlink</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出TransferStack.transfer()的整体流程：</p>
<ol>
<li>判断当前栈是否为null或者栈顶线程是否与当前线程匹配，为null或者不匹配都将进行入栈操作</li>
<li>入栈主要很简单，分成两步：插入一个节点入栈，该步无需同步，第二步需要head指针指向新节点，该步通过CAS保证安全</li>
<li>入栈之后需要将当前线程阻塞，调用LockSupport.park()方法，直到打断/超时/被匹配的线程唤醒</li>
<li>如果被取消，则需要调用clean()方法进行清除</li>
<li>由于LIFO，所以匹配的节点总是栈顶的两个节点，分成两步：原子性更新节点的match变量，更新head。由于两步无法保证原子性，所以通过将栈顶元素的mode更新为FULFILLING，阻止其他线程在栈顶发生匹配时进行其他操作，同时其他线程需帮助栈顶进行的匹配操作</li>
</ol>
<h4 id="awaitFulfill-1"><strong>awaitFulfill</strong></h4><p>下面看看TransferStack是如何让一个线程进入阻塞。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *@ By Vicky:等待匹配，逻辑大致同TransferQueue可参考阅读</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">SNode <span class="title">awaitFulfill</span><span class="params">(SNode s, boolean timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> lastTime = (timed)? System.nanoTime() : <span class="number">0</span>;</span><br><span class="line">	Thread w = Thread.currentThread();</span><br><span class="line">	SNode h = head;</span><br><span class="line">	<span class="comment">// 计算自旋的次数，逻辑大致同TransferQueue</span></span><br><span class="line">	<span class="keyword">int</span> spins = (shouldSpin(s)?</span><br><span class="line">				 (timed? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">			s.tryCancel();</span><br><span class="line">		<span class="comment">// 如果s的match不等于null，有三种情况：</span></span><br><span class="line">		<span class="comment">// a.等待被取消了，此时x==s</span></span><br><span class="line">		<span class="comment">// b.匹配上了，此时match==另一个节点</span></span><br><span class="line">		<span class="comment">// c.线程被打断，会取消，此时x==s</span></span><br><span class="line">		<span class="comment">// 不管是哪种情况都不要再等待了，返回即可</span></span><br><span class="line">		SNode m = s.match;</span><br><span class="line">		<span class="keyword">if</span> (m != null)</span><br><span class="line">			<span class="keyword">return</span> m;</span><br><span class="line">		<span class="keyword">if</span> (timed) &#123;</span><br><span class="line">			<span class="comment">// 等待</span></span><br><span class="line">			<span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">			nanos -= now - lastTime;</span><br><span class="line">			lastTime = now;</span><br><span class="line">			<span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				s.tryCancel();</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 自旋</span></span><br><span class="line">		<span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">			spins = shouldSpin(s)? (spins-<span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 设置等待线程</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == null)</span><br><span class="line">			s.waiter = w; <span class="comment">// establish waiter so can park next iter</span></span><br><span class="line">		<span class="comment">// 等待</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">			LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">			LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>逻辑基本同TransferQueue，不同之处是通过修改SNode的match变量标示匹配，以及取消。</p>
<h4 id="clean-1"><strong>clean</strong></h4><p>下面再看看如何清除被取消的节点。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @By Vicky:清除节点</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">void</span> clean(SNode s) &#123;</span><br><span class="line">	s.item = <span class="keyword">null</span>;   <span class="comment">// forget item</span></span><br><span class="line">	s.waiter = <span class="keyword">null</span>; <span class="comment">// forget thread</span></span><br><span class="line">	<span class="comment">// 清除</span></span><br><span class="line">	SNode past = s.<span class="keyword">next</span>;</span><br><span class="line">	<span class="keyword">if</span> (past != <span class="keyword">null</span> &amp;&amp; past.isCancelled())</span><br><span class="line">		past = past.<span class="keyword">next</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Absorb cancelled nodes at head</span></span><br><span class="line">	<span class="comment">// 从栈顶节点开始清除，一直到遇到未被取消的节点，或者直到s.next</span></span><br><span class="line">	SNode p;</span><br><span class="line">	<span class="keyword">while</span> ((p = head) != <span class="keyword">null</span> &amp;&amp; p != past &amp;&amp; p.isCancelled())</span><br><span class="line">		casHead(p, p.<span class="keyword">next</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Unsplice embedded nodes</span></span><br><span class="line">	<span class="comment">// 如果p本身未取消(上面的while碰到一个未取消的节点就会退出，但这个节点和past节点之间可能还有取消节点)，</span></span><br><span class="line">	<span class="comment">// 再把p到past之间的取消节点都移除。</span></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p != past) &#123;</span><br><span class="line">		SNode n = p.<span class="keyword">next</span>;</span><br><span class="line">		<span class="keyword">if</span> (n != <span class="keyword">null</span> &amp;&amp; n.isCancelled())</span><br><span class="line">			p.casNext(n, n.<span class="keyword">next</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			p = n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上即全部的TransferStack的操作逻辑。</p>
<p>看完了TransferQueue和TransferStack的逻辑，SynchronousQueue的逻辑基本清楚了。</p>
<h3 id="应用场景"><strong>应用场景</strong></h3><p>SynchronousQueue的应用场景得看具体业务需求，J.U.C下有一个应用案例：Executors.newCachedThreadPool()就是使用SynchronousQueue作为任务队列。</p>
<h3 id="参考文章"><strong>参考文章</strong></h3><p><a href="http://brokendreams.iteye.com/blog/2252081" target="_blank" rel="external">Jdk1.6 JUC源码解析(15)-SynchronousQueue</a><br><a href="http://www.cnblogs.com/wanly3643/p/3904681.html" target="_blank" rel="external">《java.util.concurrent 包源码阅读》16 一种特别的BlockingQueue：SynchronousQueue</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>SynchronousQueue是一种特殊的阻塞队列，不同于<a href="http://vickyqi.com/2015/11/23/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E]]>
    </summary>
    
      <category term="JDK" scheme="http://vickyqi.com/tags/JDK/"/>
    
      <category term="JUC" scheme="http://vickyqi.com/tags/JUC/"/>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="JDK源码" scheme="http://vickyqi.com/categories/Java/JDK%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构系列——后缀树Java实现代码]]></title>
    <link href="http://vickyqi.com/2015/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%90%8E%E7%BC%80%E6%A0%91Java%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81/"/>
    <id>http://vickyqi.com/2015/11/27/数据结构系列——后缀树Java实现代码/</id>
    <published>2015-11-27T11:35:00.000Z</published>
    <updated>2015-11-27T05:29:16.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://vickyqi.com/2015/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%90%8E%E7%BC%80%E6%A0%91%EF%BC%88%E9%99%84Java%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%EF%BC%89/">上一篇文章介绍了什么是后缀树以及后缀树的应用场景</a>，同时结合Ukkonen算法论文细述了如何在O（n）时间内构建一颗后缀树，这一篇详细介绍如何使用Java实现的Ukkonen后缀树构建算法。<a href="https://github.com/vickyqi/StudyBuddy/blob/master/java/datastructure/src/main/java/com/vicky/datastructure/tree/SuffixTree.java" target="_blank" rel="external"><strong>完整代码看这里Github</strong></a></p>
<p>Talk is cheap. Show me the code.</p>
<hr>
<p>首先定义一个SuffixTree类，用于封装后缀树，内部定义了两个内部类：Node和ActivePoint，分别封装树的节点和算法中提到的活动点。代码结构如下：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuffixTree</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Node root = <span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">0</span>]);<span class="comment">// 根节点</span></span><br><span class="line">	<span class="comment">// active point，一个三元组：(active_node,active_edge,active_length)</span></span><br><span class="line">	<span class="comment">// active_node是当前的活动点，用节点代表，active_edge是活动的边，这里用节点来表示，active_length是活动的长度</span></span><br><span class="line">	<span class="keyword">private</span> ActivePoint activePoint = <span class="keyword">new</span> ActivePoint(root, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> reminder = <span class="number">0</span>;<span class="comment">// remainder，表示还剩多少后缀需要插入</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * &lt;p&gt;</span><br><span class="line">	 * 后缀树的节点，即边</span><br><span class="line">	 * &lt;/p&gt;</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">char</span>[] chars;</span><br><span class="line">		<span class="keyword">public</span> Node child;</span><br><span class="line">		<span class="keyword">public</span> Node brother;</span><br><span class="line">		<span class="keyword">public</span> Node suffixNode;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> Node(<span class="keyword">char</span>[] chars) &#123;</span><br><span class="line">			<span class="keyword">this</span>.chars = chars;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * &lt;p&gt;</span><br><span class="line">	 * 活动点(active point)，一个三元组：(active_node,active_edge,active_length)</span><br><span class="line">	 * &lt;/p&gt;</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivePoint</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> Node point;</span><br><span class="line">		<span class="keyword">public</span> Node <span class="keyword">index</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> ActivePoint(Node point, Node <span class="keyword">index</span>, <span class="keyword">int</span> length) &#123;</span><br><span class="line">			<span class="keyword">this</span>.point = point;</span><br><span class="line">			<span class="keyword">this</span>.<span class="keyword">index</span> = <span class="keyword">index</span>;</span><br><span class="line">			<span class="keyword">this</span>.length = length;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明一下，算法中使用了边来保存字符，但是实现时没必要多维护一个类，直接使用节点（Node）来保存字符即可，效果上没有任何差别。同时树的结构通过子节点与兄弟节点的方式保存，如下结构图所示：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父节点</span><br><span class="line"><span class="string">|</span></span><br><span class="line">子节点—兄弟节点—兄弟节点</span><br></pre></td></tr></table></figure></p>
<p>采用这种方式的原因是因为一个节点的子节点数量是未知的，所以不适合使用一个固定长度的数组来保存节点的全部子节点，使用集合会造成数据结构嵌套数据结构，不适合。同时根节点也是一个普通节点，只是根节点不存在任何字符（字符数组长度==0）。ActivePoint是一个三元组（包含三个属性），分别对应：活动节点（Node），活动边（Node），活动长度。reminder对应算法中的reminder，记录剩余后缀数量。Node表示一个节点，有4个属性：chars表示该节点上的字符，child和brother是子节点和兄弟节点的指针，suffixNode是后缀连接。</p>
<p>介绍完了整体结构，下面来看看具体如何对一个字符串构建后缀树。</p>
<p><strong>注意</strong>：在构建后缀树时使用了一个优化手段，算法中提到每次修改#，使得边上的字符自动扩充一位，在实际实现时我们可直接将从插入字符开始到字符串结束所有的字符全部一次性放到边上，省去每次扩充#。该优化点引用如下（原文见参考文章二）：</p>
<blockquote>
<p>借助后缀树的特性, 我们可以做出一个相当有效的算法. 首先一个重要的特性是: 一朝为叶, 终生为叶. 一个叶节点自诞生以后绝不会有子孙. 更重要的是, 每当我们往树上加入一个新的前缀, 每一条通往叶节点的边都会延长一个字符(新前缀的最后一个字符). 这使得处理通往叶节点的边变得异常简单, 我们完全可以在创建叶节点的时候就把当前字符到文本末的所有字符一股脑塞进去. 是的, 我们不需要知道后面的字符是啥, 但我们知道它们最终都要被加进去. 因此, 一个叶节点诞生的时候, 也正是它可以被我们遗忘的时候. 你可能会担心通往叶节点的边被分割了怎么办, 那也不要紧, 分割之后只是起点变了, 尾部该怎么着还是怎么着。</p>
</blockquote>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 构建后缀树</span><br><span class="line"> * </span><br><span class="line"> * @param word</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> build(<span class="keyword">String</span> word) &#123;</span><br><span class="line">	<span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">char</span>[] chars = word.toCharArray();</span><br><span class="line">	<span class="keyword">while</span> (index &lt; chars.length) &#123;<span class="comment">// 循环建立后缀</span></span><br><span class="line">		<span class="built_in">int</span> currenctIndex = index++;<span class="comment">// 保存当前的位置</span></span><br><span class="line">		<span class="built_in">char</span> w = chars[currenctIndex];<span class="comment">// 当前的后缀字符</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">this</span>.<span class="built_in">print</span>();<span class="comment">// 打印</span></span><br><span class="line">		System.out.<span class="built_in">println</span>();</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"当前插入后缀："</span> + w + <span class="string">"========"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (find(w)) &#123;<span class="comment">// 查找是否存在保存有当前后缀字符的节点</span></span><br><span class="line">			reminder++;<span class="comment">// 存在，则将reminder+1，activePoint.length+1，然后返回即可</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 不存在的话，如果reminder==0表示之前在该字符之前未剩余有其他带插入的后缀字符，所以直接插入该后缀字符即可</span></span><br><span class="line">		<span class="keyword">if</span> (reminder == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 直接在当前活动节点插入一个节点即可</span></span><br><span class="line">			<span class="comment">// 这里插入的节点包含的字符是从当前字符开始该字符串剩余的全部字符，这里是一个优化，</span></span><br><span class="line">			<span class="comment">// 优化参考自：http://blog.csdn.net/v_july_v/article/details/6897097 (3.6、归纳, 反思, 优化)</span></span><br><span class="line">			Node node = <span class="keyword">new</span> Node(Arrays.copyOfRange(chars, currenctIndex, chars.length));</span><br><span class="line">			<span class="comment">// 如果当前活动点无子节点，则将新建的节点作为其子节点即可，否则循环遍历子节点(通过兄弟节点进行保存)</span></span><br><span class="line">			Node child = activePoint.<span class="built_in">point</span>.child;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> == child) &#123;</span><br><span class="line">				activePoint.<span class="built_in">point</span>.child = node;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">null</span> != child.brother) &#123;</span><br><span class="line">					child = child.brother;</span><br><span class="line">				&#125;</span><br><span class="line">				child.brother = node;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果reminder&gt;0，则说明该字符之前存在剩余字符，需要进行分割，然后插入新的后缀字符</span></span><br><span class="line">			Node splitNode = activePoint.index;<span class="comment">// 待分割的节点即为活动边(active_edge)</span></span><br><span class="line">			<span class="comment">// 创建切分后的节点，放到当前节点的子节点</span></span><br><span class="line">			<span class="comment">// 该节点继承了当前节点的子节点以及后缀节点信息</span></span><br><span class="line">			Node node = <span class="keyword">new</span> Node(Arrays.copyOfRange(splitNode.chars, activePoint.length, splitNode.chars.length));<span class="comment">// 从活动边长度开始截取剩余字符作为子节点</span></span><br><span class="line">			node.child = splitNode.child;</span><br><span class="line">			node.suffixNode = splitNode.suffixNode;</span><br><span class="line">			splitNode.child = node;</span><br><span class="line">			splitNode.suffixNode = <span class="keyword">null</span>;</span><br><span class="line">			<span class="comment">// 创建新插入的节点，放到当前节点的子节点(通过子节点的兄弟节点保存)</span></span><br><span class="line">			Node newNode = <span class="keyword">new</span> Node(Arrays.copyOfRange(chars, currenctIndex, chars.length));<span class="comment">// 插入新的后缀字符</span></span><br><span class="line">			splitNode.child.brother = newNode;</span><br><span class="line">			splitNode.chars = Arrays.copyOfRange(splitNode.chars, <span class="number">0</span>, activePoint.length);<span class="comment">// 修改当前节点的字符</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 分割完成之后需根据规则1和规则2进行区分对待</span></span><br><span class="line">			<span class="comment">// 按照规则1进行处理</span></span><br><span class="line">			<span class="keyword">if</span> (root == activePoint.<span class="built_in">point</span>) &#123;<span class="comment">// 活动节点是根节点的情况</span></span><br><span class="line">				<span class="comment">// activePoint.point == root</span></span><br><span class="line">			<span class="comment">// 按照规则3进行处理</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> == activePoint.<span class="built_in">point</span>.suffixNode) &#123;<span class="comment">// 无后缀节点，则活动节点变为root</span></span><br><span class="line">				activePoint.<span class="built_in">point</span> = root;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;<span class="comment">// 否则活动节点变为当前活动节点的后缀节点</span></span><br><span class="line">				activePoint.<span class="built_in">point</span> = activePoint.<span class="built_in">point</span>.suffixNode;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 活动边和活动边长度都重置</span></span><br><span class="line">			activePoint.index = <span class="keyword">null</span>;</span><br><span class="line">			activePoint.length = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 递归处理剩余的待插入后缀</span></span><br><span class="line">			innerSplit(chars, currenctIndex, splitNode);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在SuffixTree中定义一个build(String word)方法，参数word是待生成后缀树的字符串。首先将字符串转成字符数组，并按照算法步骤逐个插入。find(char w)用于查找指定的后缀是否存在（这里所说的后缀其实就是单个字符，因为单个字符代表的就是以该字符开头的后缀）。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 寻找当前活动点的子节点中是否存在包含后缀字符的节点(边)</span><br><span class="line"> * </span><br><span class="line"> * @param w</span><br><span class="line"> * @return</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> find(<span class="keyword">char</span> w) &#123;</span><br><span class="line">	<span class="keyword">final</span> Node start = activePoint.point;</span><br><span class="line">	<span class="keyword">final</span> Node current = activePoint.<span class="keyword">index</span>;</span><br><span class="line">	<span class="keyword">boolean</span> exist = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == current) &#123;<span class="comment">// current==null 无活动边，则从活动点的子节点开始查找</span></span><br><span class="line">		<span class="comment">// 寻找子节点</span></span><br><span class="line">		Node child = start.child;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">null</span> != child) &#123;</span><br><span class="line">			<span class="keyword">if</span> (child.chars[<span class="number">0</span>] == w) &#123;<span class="comment">// 存在</span></span><br><span class="line">				activePoint.<span class="keyword">index</span> = child;</span><br><span class="line">				activePoint.length++;<span class="comment">// activePoint.length++</span></span><br><span class="line">				exist = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				child = child.brother;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.chars[activePoint.length] == w) &#123;<span class="comment">// 有活动边，则在活动边上查找</span></span><br><span class="line">		activePoint.length++;</span><br><span class="line">		exist = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (current.chars.length == activePoint.length) &#123;</span><br><span class="line">			<span class="comment">// 如果活动边的长度已达到活动边的最后一个字符，则将活动点置为活动边，同时活动边置为null，长度置为0</span></span><br><span class="line">			activePoint.point = current;</span><br><span class="line">			activePoint.<span class="keyword">index</span> = <span class="keyword">null</span>;</span><br><span class="line">			activePoint.length = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		exist = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> exist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找后缀是否存在是从活动节边开始查找，如果活动边为NULL，则从活动节点的子节点挨个查找，查找是通过比较边上的指定位置（活动长度指定）与查找字符是否相等。这里有个地方需要注意：算法中提到，如果一个活动边已到达结尾（即活动长度==活动边的字符长度），则将活动边晋升为活动节点，并重置活动边和活动长度为NULL和0。如下代码所示：</p>
<figure class="highlight rsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (current.chars.<span class="built_in">length</span> == activePoint.<span class="built_in">length</span>) &#123;</span><br><span class="line">	<span class="comment">// 如果活动边的长度已达到活动边的最后一个字符，则将活动点置为活动边，同时活动边置为null，长度置为0</span></span><br><span class="line">	activePoint.<span class="keyword">point</span> = current;</span><br><span class="line">	activePoint.index = null;</span><br><span class="line">	activePoint.<span class="built_in">length</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果查找到后缀存在，则直接将活动长度+1（在find()方法内部处理的），reminder+1即可。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">find</span>(w)) &#123;<span class="comment">// 查找是否存在保存有当前后缀字符的节点</span></span><br><span class="line">	reminder++;<span class="comment">// 存在，则将reminder+1，activePoint.length+1，然后返回即可</span></span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不存在，需区分两种情况，一种是：前面没有堆积未插入的后缀，即reminder==0，另外一种是reminder&gt;0。<br>对于reminder==0（如算法中举例的前三个字符abc），只需要直接将当前后缀插入到活动节点即可。具体首先新建一个节点，<code>Node node = new Node(Arrays.copyOfRange(chars, currenctIndex, chars.length));</code>，该节点包含从当前字符往后所有的字符，即上面提到的优化点；接着将新建的节点作为活动节点的子节点插入，这里需判断子节点是否存在，不存在，作为子节点，存在则作为子节点的最后一个兄弟节点。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Node</span><span class="identifier"> </span><span class="title">child</span> = activePoint.point.child;</span><br><span class="line">if (null == child) &#123;</span><br><span class="line">	activePoint.point.child = <span class="keyword">node</span><span class="identifier"></span><span class="title">;</span><br><span class="line">&#125; else</span> &#123;</span><br><span class="line">	while (null != child.brother) &#123;</span><br><span class="line">		child = child.brother;</span><br><span class="line">	&#125;</span><br><span class="line">	child.brother = <span class="keyword">node</span><span class="identifier"></span><span class="title">;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>如果reminder&gt;0（如算法中举例<strong>步骤6</strong>，插入第四到第六个字符abx，到达x时就是这种情况），我们需要对当前活动边进行分割操作。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 如果reminder&gt;<span class="number">0</span>，则说明该字符之前存在剩余字符，需要进行分割，然后插入新的后缀字符</span><br><span class="line"><span class="keyword">Node</span><span class="identifier"> </span><span class="title">splitNode</span> = activePoint.index;// 待分割的节点即为活动边(active_edge)</span><br><span class="line">// 创建切分后的节点，放到当前节点的子节点</span><br><span class="line">// 该节点继承了当前节点的子节点以及后缀节点信息</span><br><span class="line"><span class="keyword">Node</span><span class="identifier"> </span><span class="title">node</span> = new <span class="keyword">Node</span><span class="identifier"></span><span class="title">(Arrays</span>.copyOfRange(splitNode.chars, activePoint.length, splitNode.chars.length));// 从活动边长度开始截取剩余字符作为子节点</span><br><span class="line"><span class="keyword">node</span>.<span class="identifier"></span><span class="title">child</span> = splitNode.child;</span><br><span class="line"><span class="keyword">node</span>.<span class="identifier"></span><span class="title">suffixNode</span> = splitNode.suffixNode;</span><br><span class="line">splitNode.child = <span class="keyword">node</span><span class="identifier"></span><span class="title">;</span><br><span class="line">splitNode</span>.suffixNode = null;</span><br><span class="line">// 创建新插入的节点，放到当前节点的子节点(通过子节点的兄弟节点保存)</span><br><span class="line"><span class="keyword">Node</span><span class="identifier"> </span><span class="title">newNode</span> = new <span class="keyword">Node</span><span class="identifier"></span><span class="title">(Arrays</span>.copyOfRange(chars, currenctIndex, chars.length));// 插入新的后缀字符</span><br><span class="line">splitNode.child.brother = newNode;</span><br><span class="line">splitNode.chars = Arrays.copyOfRange(splitNode.chars, <span class="number">0</span>, activePoint.length);// 修改当前节点的字符</span><br></pre></td></tr></table></figure>
<p>分割的节点是活动边指向的节点，分割的位置由活动长度指定。具体分割是新建一个节点A，该节点的字符是被分割节点分割之后剩余的字符（’cabx’），同时该节点需继承被分割节点的子节点信息，以及后缀连接信息；再新建一个节点B存放当前要插入的后缀（’x’）。以上两个新建的节点都将作为被分割节点的子节点存在，所以A的兄弟节点指向B，并将被分割节点的字符切去只剩活动长度指定的字符（’ab’）。分割完之后需要根据规则1和规则3重置活动点信息，但是不管活动节点如何设定，活动边和活动边长度必须要重置为NULL和0。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分割完成之后需根据规则1和规则3进行区分对待</span></span><br><span class="line"><span class="comment">// 按照规则1进行处理</span></span><br><span class="line"><span class="keyword">if</span> (root == activePoint.<span class="built_in">point</span>) &#123;<span class="comment">// 活动节点是根节点的情况</span></span><br><span class="line">	<span class="comment">// activePoint.point == root</span></span><br><span class="line"><span class="comment">// 按照规则3进行处理</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> == activePoint.<span class="built_in">point</span>.suffixNode) &#123;<span class="comment">// 无后缀节点，则活动节点变为root</span></span><br><span class="line">	activePoint.<span class="built_in">point</span> = root;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// 否则活动节点变为当前活动节点的后缀节点</span></span><br><span class="line">	activePoint.<span class="built_in">point</span> = activePoint.<span class="built_in">point</span>.suffixNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 活动边和活动边长度都重置</span></span><br><span class="line">activePoint.index = <span class="keyword">null</span>;</span><br><span class="line">activePoint.length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>到这里我们只是插入了后缀’abx’，由于reminder==2，还需要插入’bx’和’x’，所以引入一个递归方法：innerSplit(char[] chars, int currenctIndex, Node prefixNode)，用于插入’bx’和’x’。方法有三个参数：chars是构建后缀树的字符串的字符数组，currenctIndex是我们当前插入后缀的位置（for循环的位置），prefixNode是前一次进行分割的节点。所以此处分割完之后需调用innerSplit()方法处理剩余后缀。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归处理剩余的待插入后缀</span></span><br><span class="line"><span class="function">innerSplit</span>(chars, currenctIndex, splitNode);</span><br></pre></td></tr></table></figure></p>
<p>第三个参数传入splitNode，即将当前被分割的节点传入方法。下面看看innerSplit()如何递归如何剩余后缀。<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 处理剩余的待插入后缀</span><br><span class="line"> * @param chars	构建后缀树的全部字符</span><br><span class="line"> * @param currenctIndex	当前已处理到的字符位置</span><br><span class="line"> * @param prefixNode 前继节点，即已经进行分割的节点，用于标识后缀节点</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> innerSplit(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> currenctIndex, Node prefixNode) &#123;</span><br><span class="line">	<span class="comment">// 此处计算剩余待插入的后缀的开始位置，例如我们需要插入三个后缀(abx,bx,x)，已处理了abx，则还剩余ba和x，则下面计算的位置就是b的位置</span></span><br><span class="line">	<span class="keyword">int</span> start = currenctIndex - reminder + <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">this</span>.print();<span class="comment">// 打印</span></span><br><span class="line">	System.out.println();</span><br><span class="line">	System.out.println(<span class="string">"当前插入后缀："</span> + String.copyValueOf(chars, start, currenctIndex - start + <span class="number">1</span>) + <span class="string">"========"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// dealStart表示本次插入我们需要进行查找的开始字符位置，因为由于规则2，可能出现通过后缀节点直接找到活动节点的情况</span></span><br><span class="line">	<span class="comment">// 如通过ab节点的后缀节点，直接找到节点b，那么此时的activePoint(node[b], null, 0)，我们需要从node[b]开始查找x，dealStart的位置就是x的位置</span></span><br><span class="line">	<span class="keyword">int</span> dealStart = start + activePoint.point.chars.length + activePoint.length;</span><br><span class="line">	<span class="comment">// 从dealStart开始查找所有后缀字符是否都存在(相对与活动点)</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> <span class="keyword">index</span> = dealStart; <span class="keyword">index</span> &lt;= currenctIndex; <span class="keyword">index</span>++) &#123;</span><br><span class="line">		<span class="keyword">char</span> w = chars[<span class="keyword">index</span>];</span><br><span class="line">		<span class="keyword">if</span> (find(w)) &#123;<span class="comment">// 存在，则查找下一个，activePoint.length+1，这里不增加reminder</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node splitNode = <span class="keyword">null</span>;<span class="comment">// 被分割的节点</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">null</span>==activePoint.<span class="keyword">index</span>)&#123;<span class="comment">// 如果activePoint.index==null，说明没有找到活动边，那么只需要在活动节点下插入一个节点即可</span></span><br><span class="line">			<span class="comment">// --此处代码build()方法插入节点部分--</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">// 开始分割，分割部分同上面的分割</span></span><br><span class="line">			<span class="comment">// --此处代码build()方法分割部分--</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 规则2，连接后缀节点</span></span><br><span class="line">			prefixNode.suffixNode = splitNode;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// --</span></span><br><span class="line">		reminder--;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 分割完成之后需根据规则1和规则3进行区分对待</span></span><br><span class="line">		<span class="comment">// --代码同build()代码部分--</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(reminder &gt; <span class="number">0</span>)&#123;<span class="comment">// 如果reminder==0则不需要继续递归插入后缀</span></span><br><span class="line">			innerSplit(chars, currenctIndex, splitNode);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码为了消减篇幅省去了与build()方法重复的代码（完整代码会放到Github上），其实基本逻辑是一样的，只是所处理的方式略有不同，所以没法放到一起。</p>
<p>这里说一下start和dealStart这两个变量的用处。start是本次需要插入的后缀的开始位置，如’bx’，则start就是b的位置，通过reminder获得；dealStart是下面的for循环开始的位置，也就是需要查找后缀的位置，dealStart的出现是由于规则2的存在，如果没有规则2，那么dealStart就是start了，由于规则2活动节点会从root直接跳到一个节点，而无需进行查找，所以如果发生了跳转，比如字符串时’abcabxabcd’，待插入后缀是’bcd’时，这时就是根据规则2直接跳到一个节点b，所以要从’c’开始找，就是因为节点b为我们省了一个字符，所以说后缀连接是用于优化的。<code>prefixNode.suffixNode = splitNode;</code>就是将之前被分割的节点的后缀连接指向当前被分割的节点。</p>
<p>剩余的部分就是查找，分割了，同build()的代码一样，所以省去了。最后，如果本次处理完reminder依旧&gt;0，那么就需要进行递归调用该方法了。</p>
<p>到这里构建后缀树就完成了。下面介绍后缀树的一个应用：查找子串。具体看代码：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 查找给定字符串是否是其子串</span><br><span class="line"> * </span><br><span class="line"> * @param word</span><br><span class="line"> * @return</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> select(String word) &#123;</span><br><span class="line">	<span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">index</span> = <span class="number">0</span>;<span class="comment">// 查找到的节点的匹配的位置</span></span><br><span class="line">	<span class="comment">// 查找从根节点开始，遍历子节点</span></span><br><span class="line">	Node start = root;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (start.chars.length &lt; <span class="keyword">index</span> + <span class="number">1</span>) &#123;<span class="comment">// 如果当前节点已匹配完，则从子节点开始，同时需重置index==0</span></span><br><span class="line">			<span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">			start = start.child;</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">null</span> != start) &#123;</span><br><span class="line">				<span class="comment">// 比较当前节点指定位置(index)的字符是否与待查找字符一致</span></span><br><span class="line">				<span class="comment">// 由于是遍历子节点，所以如果不匹配换个子节点继续</span></span><br><span class="line">				<span class="keyword">if</span> (start.chars[<span class="keyword">index</span>] == chars[i]) &#123;</span><br><span class="line">					<span class="keyword">index</span>++;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					start = start.brother;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> == start) &#123;<span class="comment">// 子节点遍历完都无匹配则返回false</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (start.chars[<span class="keyword">index</span>] == chars[i]) &#123;</span><br><span class="line">			<span class="comment">// 如果当前查找到的节点的还有可比较字符，则进行比较，如果不同则直接返回false</span></span><br><span class="line">			<span class="keyword">index</span>++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于每个节点包含的字符数不确定，所以需要一个额外的索引记录当前匹配节点中字符的位置。查找的主要思想是先从根节点的字节点开始，挨个找，找不到则不是子串，找到一个节点后从节点上的所有字符挨个匹配，匹配不上则没有，匹配完了，就从这个节点的子节点继续找。</p>
<p><a href="https://github.com/vickyqi/StudyBuddy/blob/master/java/datastructure/src/main/java/com/vicky/datastructure/tree/SuffixTree.java" target="_blank" rel="external"><strong>完整代码看这里Github</strong></a></p>
<p><strong>参考文章</strong><br><a href="http://www.oschina.net/translate/ukkonens-suffix-tree-algorithm-in-plain-english" target="_blank" rel="external">Ukkonen 的后缀树算法的清晰解释</a><br><a href="http://www.cnblogs.com/gaochundong/p/suffix_tree.html" target="_blank" rel="external">后缀树</a><br><a href="http://blog.csdn.net/v_july_v/article/details/6897097" target="_blank" rel="external">从Trie树（字典树）谈到后缀树（10.28修订）</a></p>
<hr>
<p>以上就是自己实现的后缀树全部内容，欢迎大家测试，如发现问题请在下方留言，谢谢~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://vickyqi.com/2015/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%90%8E%E7%BC%80%E6%A0%9]]>
    </summary>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="数据结构" scheme="http://vickyqi.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构" scheme="http://vickyqi.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构系列——后缀树（附Java实现代码）]]></title>
    <link href="http://vickyqi.com/2015/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%90%8E%E7%BC%80%E6%A0%91%EF%BC%88%E9%99%84Java%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%EF%BC%89/"/>
    <id>http://vickyqi.com/2015/11/27/数据结构系列——后缀树（附Java实现代码）/</id>
    <published>2015-11-27T11:17:00.000Z</published>
    <updated>2015-11-27T05:30:08.000Z</updated>
    <content type="html"><![CDATA[<p>后缀树，说的通俗点就是将一个字符串所有的后缀按照<a href="http://vickyqi.com/2015/11/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94Trie%E6%A0%91/">前缀树（Trie树，可参考此篇文章）</a>的形式组织成一棵树。</p>
<h2 id="什么是后缀树"><strong>什么是后缀树</strong></h2><p>举例：“banana\0”，其中 “\0” 作为文本结束符号，该字符串所有的后缀如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">banana\<span class="number">0</span></span><br><span class="line"> anana\<span class="number">0</span></span><br><span class="line">  nana\<span class="number">0</span></span><br><span class="line">   ana\<span class="number">0</span></span><br><span class="line">    na\<span class="number">0</span></span><br><span class="line">     a\<span class="number">0</span></span><br><span class="line">      \<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>将所有的后缀构建成一个前缀树，如下：</p>
<p><strong>图1：粗陋的后缀树：</strong></p>
<center><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffix_tree_1.png" alt="图1：粗陋的后缀树"></center>

<p>从图中可以看出大量的重复子串，如存在三个“a\0”，浪费太多的空间，我们需要将其进行压缩，得到如下的后缀树：</p>
<p><strong>图2：真正的后缀树：</strong></p>
<center><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffix_tree_2.png" alt="图2：真正的后缀树"></center>

<p>瞬间感觉看不懂了是吧，其实就是把每个节点放一个字符，改成放多个字符，比如图1最左边的一条分支，每个节点一个字符，太浪费，到图2就成了一个节点，存储了全部的”banana\0”字符，大大节省了空间。当然也增加了查找的复杂度。</p>
<h2 id="后缀树的应用"><strong>后缀树的应用</strong></h2><p>在看如何构建这样一颗后缀树之前，先了解下后缀树的应用，如果没有很好地应用场景，那么我们就没必要浪费时间去了解这么一颗复杂的数据结构了。</p>
<ol>
<li>查找字符串o是否在字符串S中。<br>方案：用S构造后缀树，按在trie中搜索字串的方法搜索o即可。<br>原理：若o在S中，则o必然是S的某个后缀的前缀。<br>例如S: leconte，查找o: con是否在S中,则o(con)必然是S(leconte)的后缀之一conte的前缀.有了这个前提，采用trie搜索的方法就不难理解了。</li>
<li>指定字符串T在字符串S中的重复次数。<br>方案：用S+”$”构造后缀树，搜索T节点下的叶节点数目即为重复次数<br>原理：如果T在S中重复了两次，则S应有两个后缀以T为前缀，重复次数就自然统计出来了。</li>
<li>字符串S中的最长重复子串<br>方案：原理同2，具体做法就是找到最深的非叶节点。<br>这个深是指从root所经历过的字符个数，最深非叶节点所经历的字符串起来就是最长重复子串。<br>为什么要非叶节点呢?因为既然是要重复，当然叶节点个数要&gt;=2。 </li>
<li>两个字符串S1，S2的最长公共部分<br>方案：将S1#S2\$作为字符串压入后缀树，找到最深的非叶节点，且该节点的叶节点既有#也有\$(无#)。</li>
</ol>
<p>后面会用代码来描述如何应用后缀树进行字符串子串的查找，即应用1。下面先来看看后缀树的构建算法。</p>
<h2 id="后缀树的构建"><strong>后缀树的构建</strong></h2><p>在 1995 年，Esko Ukkonen 发表了论文<a href="http://www.cs.helsinki.fi/u/ukkonen/SuffixT1withFigs.pdf" target="_blank" rel="external">《On-line construction of suffix trees》</a>，描述了在线性时间内构建后缀树的方法。该文章当然是英文的了，不过国内已经有人翻译了，<a href="http://www.oschina.net/translate/ukkonens-suffix-tree-algorithm-in-plain-english" target="_blank" rel="external">翻译的文章可以看这里</a>。不过说真的，这是论文，还是老外的论文，就算翻译成中文，但是还是比较难以理解的，至少需要研究好几遍才能大致明白，而且文中出现了比较多的感官动词（不知道是不是这个名词），如“一眼看出”，“显然”等。所以我会结合这篇译文，并加上自己的理解，希望以此帮助大家快速的理解。原文会通过正文对译文进行原样照搬，注释采用斜体，请注意区分。</p>
<h3 id="Ukkonen算法"><strong>Ukkonen算法</strong></h3><hr>
<p>本文试图描述Ukkonen算法，首先显示当字符串是简单的(即不包含任何重复的字符)时候它做什么，然后扩展到完整的算法。</p>
<p>首先来看一些前言：<br>我们正在建设的，基本上像一个搜索特里结构（单词查找树）。所以有一个根节点，从根节点引出新的节点，以及进一步从新节点引出其它节点，依次类推。</p>
<p>但是：与搜索单词查找树中不同，边标签不是单个字符。相反,每个边的标签是使用一对整数[从哪,到哪]。这些都是指向文本的指针。从这个意义上说，每个边有任意长度的字符串标签，但只需要O(1)的空间(两个指针)。</p>
<h3 id="基本原理"><strong>基本原理</strong></h3><p>我想首先展示如何创建一个特别简单的字符串的后缀树，这个字符串没有重复的字符，如：</p>
<pre>abc</pre>

<p>这个<strong>算法工作的步骤，从左到右。字符串的每个字符都有一个步骤。</strong>每一步都可能涉及到多个个体的操作,但是我们将会看到(见结尾最后的观察)的总数量操作是O(n)。</p>
<p>所以我们从左开始，第一次插入单个字符“a“创建一个从根节点(在左边)到一个叶节点的边，和作为[0,#)的标签，这意味着边代表了子串在位置0开始，结束在当前的结尾。我使用符号#来表示当前末尾，这是在位置1(a之后的右边)。</p>
<p>因此，我们拥有一棵起始树，这棵树看起来如下：</p>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffixtree/ukkonens-suffixtree_1.png" alt="这里写图片描述"></p>
<p>而其意义如下：</p>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffixtree/ukkonens-suffixtree_2.png" alt="这里写图片描述"></p>
<p>现在我们前进到位置2(b的右边）。 我们每个步骤的目标是插入至当前位置的所有后缀。<br>我们通过以下动作完成目标： </p>
<ul>
<li>扩展已存在边a为ab</li>
<li>插入一条新边b</li>
</ul>
<p>在我们的图示里，它看起来如下： </p>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffixtree/ukkonens-suffixtree_3.png" alt="这里写图片描述"></p>
<p>而其意义如下： </p>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffixtree/ukkonens-suffixtree_4.png" alt="这里写图片描述"></p>
<p><strong>我们看到了</strong>两点：</p>
<ul>
<li>ab边的图示与它在起始树：[0,#]边的图示是相同的。它的意义却已经自动更改了，因为我们把当前的位置#从1更改到2。</li>
<li>每条边使用的空间复杂度为O(1)，因为无论边代表多少个字符 ，它都是由指向文本里的两个指针组成。</li>
</ul>
<p>接着我们再次增加位置，并且修改树：给每个已经存在的边增加c，插入一条表示新后缀c的边。<br>在我们的图示里，它看起来如下： </p>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffixtree/ukkonens-suffixtree_5.png" alt="这里写图片描述"></p>
<p>而其意义如下： </p>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffixtree/ukkonens-suffixtree_6.png" alt="这里写图片描述"></p>
<p><strong>我们看到</strong>： </p>
<ul>
<li>这棵树是经过上面的每个步骤后至当前位置的正确的后缀树。</li>
<li>步骤数目与文本中包含的字符一样多。</li>
<li>每个步骤的工作量是O(1)，因为所有已经存在的边都是增加#来自动更改的，而且为最后一个字符插入一条新边的时间复杂度为  O(1)。因此对一个长度为n的字符串来说，只需要O(n)时间复杂度。</li>
</ul>
<hr>
<p><em><b>注释1</b>：到这里论文中构建了一颗“abc”的后缀树，按照步骤一步一步很容易理解，唯一的地方就是那个#，不过我们可以忽略这个#，在使用程序实现的时候我们会有一个很好的优化的方式让我们很轻松的处理掉这个#。不过，从下面开始，事情似乎变得复杂了很多</em></p>
<hr>
<h3 id="第一次扩展：简单的重复"><strong>第一次扩展：简单的重复</strong></h3><p>当然，后缀树表示的如此良好只是因为我们的字符串没有包含任何重复。现在我们看一个更真实的字符串：</p>
<pre>abcabxabcd</pre>

<p>这个字符串像前面例子里一样是abc开始的，接着重复ab ，紧跟着x，再接着重复abc，紧跟着d。<br><strong>步骤1到3</strong>：经过了前三个步骤后，我们拥有了前面例子的那棵树：</p>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffixtree/ukkonens-suffixtree_7.png" alt="这里写图片描述"></p>
<p><strong>步骤4</strong>：我们移动#到位置4。这隐含地更改所有已经存在的边为如下：</p>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffixtree/ukkonens-suffixtree_8.png" alt="这里写图片描述"></p>
<p>而且我们需要在根节点插入当前步骤的最末的后缀a。<br>我们做这些之前，我们引入除#之外的 两个或者更多变量，当然这些变量一直都存在，只是我们迄今为止没有使用它们： </p>
<ul>
<li><strong>活动点(active point)</strong>，它是一个三元组（活动节点，活动边，活动长度）</li>
<li><strong>剩余后缀数(reminder)</strong>，它是一个整数，来说明我们需要插入多少个新的后缀。</li>
</ul>
<p>这两个图示的确切含义不久就会清晰，不过现在我们只能说： </p>
<ul>
<li>在简单的abc例子里，活动点总是(root,’0x’,0),也就是说，活动节点是根节点，活动边是由空字符’0x’指定的边，活动长度是0。这么做的结果是我们在每一步骤里插入的一条新边是作为新创建的边插入到根节点。不久我们就会明白为什么需要三元组表示这条信息。</li>
<li>在每个步骤开始时剩余后缀数总是设置为1。它的意义是我们主动插入到每一步骤末尾的后缀数目是1（总是最后一个字符）。</li>
</ul>
<hr>
<p><em><b>注释2</b>：关于这里的活动点和剩余后缀数简单解释下。活动点中的<strong>活动节点</strong>：是用于查找一个后缀是否已经存在这棵树里，即查找的时候从活动节点的子节点开始查找，同时当需要插入边的时候也是插入到该节点下；而<strong>活动边</strong>则是每次需要进行分割的边，即成为活动边就意味着需要被分割；而<strong>活动长度</strong>则是指明从活动边的哪个位置开始分割。<strong>剩余后缀数</strong>是我们需要插入的后缀的数量，说明程序员点就是缓存的数量，因为每次如果要插入的后缀存在，则缓存起来。</em></p>
<hr>
<p>现在将有变化了，当我们给根节点插入当前最后一个字符a的时候，我们特别注意到已经存在一条以a开始的边：abca。在这种情况下我们做如下工作： </p>
<ul>
<li>我们不向根节点插入一条新边[4,#]。相反，我们只是注意到后缀a已经在我们的树里。它终止在更长的边的中间位置，不过这么做我们并不疑惑，我们还是保留它们原来的样子。</li>
<li>我们设置活动点为(root,’a’,1)。这意味着活动点现在是在根节点的以a开始的向外的边的中间某个位置，具体地指这条边的位置1之后。我们注意到这条边只是由它的首个字符a来声明的。这就足够了，因为以一个特定的字符开始的只有一条边（通读整个文档之后可以确定这是真的）。</li>
<li>我们还增加了剩余后缀数， 那么在下一步骤开始的时候，剩余后缀数为2。</li>
</ul>
<p><strong>注意</strong>：当<strong>发现我们需要插入的最终后缀已经存在在这棵树里的时候</strong>，这棵树本身根本就<strong>没有改变</strong>（我们只是修改了活动节点和剩余后缀数）。那么这棵树就不再是能准确的表示至当前位置的后缀树了，不过它<strong>包含了</strong>所有的后缀（因为最终的后缀a隐含地包含了）。因此，除了修改变量外（所有这些变量都是定长的，因此空间复杂度是 O(1)），在这一步里<strong>没有做其他工作</strong>。</p>
<hr>
<p><em><b>注释3</b>：这里原文用了<strong>我们特别注意到</strong>，可惜，程序可不会注意到，所以在实现的时候这里会涉及到对活动节点的子节点的一个遍历操作。这里还更新了活动点，活动节点是root，而活动边是’a’，对于程序来说活动边则是一个边的对象，只是这个边包含的字符串时以’a’开头，同时活动长度是从0增加到了1。剩余后缀数是1，因为我们缓存了一个后缀’a’。</em></p>
<hr>
<p><strong>步骤5：</strong>我们修改当前的位置#为5。这将自动地如下更新这棵树：</p>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffixtree/ukkonens-suffixtree_9.png" alt="这里写图片描述"></p>
<p>而且<strong>由于剩余后缀数为2</strong>，我们需要插入目前位置的两个最终后缀：ab和b。这主要是因为： </p>
<ul>
<li>前一步骤的a后缀从来都没有真正地插入。因此它保留下来，然而由于我们已经向前走了一步，它现在由a延长为ab。</li>
<li>还有，我们需要插入新的最终边b。</li>
</ul>
<p>实际上，这意味着我们要修改活动点（它现在指向的是abcab边里的a之后），而且插入当前的最后一个字符b， <strong>不过</strong>：同时它也证明b也已经出现在同一条边里。 </p>
<p>因此，我们再次不修改这棵树，我们只是： </p>
<ul>
<li>修改活动点为(root,’a’,2)(是与前面相同的节点和边，只不过现在我们指向到b之后)</li>
<li>增加剩余后缀数为3 ，因为我们仍然不能插入前一个步骤的最终边，同时我们也不能插入当前的最终边</li>
</ul>
<p>为了清晰地说明：我们需要在当前的步骤里插入ab和b，不过由于ab已经找到，所以我们修改了活动点，而且甚至不试图插入b。为什么？因为如果ab处于这棵树里，那么它的<strong>每个后缀</strong>（包括b)也一定在这棵树里。也许仅仅是隐含性的，不过它一定在这棵树里，因为这是我们迄今为止建立这棵树所采用的方法。</p>
<hr>
<p><em><b>注释4</b>：<strong>同时它也证明b也已经出现在同一条边里</strong>，看到这句话时思考了半天，真的无法证明，只是我们用肉眼看出来而已，所以程序需要做的是：比较活动边在活动长度指定的字符与’b’是否相同，相同则证明了’b’也出现过在同一条边。此时活动长度的作用就出来了，其实就是标识活动边比较到哪里了。</em></p>
<hr>
<p>我们增加#而前进到<strong>步骤6</strong>。这棵树自动修改为：</p>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffixtree/ukkonens-suffixtree_10.png" alt="这里写图片描述"></p>
<p>由于<strong>剩余后缀数是3</strong> ，我们不得不增加abx,bx和x。活动点告诉我们ab结束在哪儿，因此我们仅仅需要跳过这儿，然后插入x。x确实还不在这棵树里，因此我们分割abcabx边，插入一个内部节点：</p>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffixtree/ukkonens-suffixtree_11.png" alt="这里写图片描述"></p>
<p>这条边表示的仍然是指向文本内部的指针，因此分割和插入内部节点的时间复杂度为O(1)。 </p>
<hr>
<p><em><b>注释5</b>：这里为什么突然不证明x也出现过在同一条边呢？因为被肉眼识破了，好吧，程序还是需要按照注释4所说的方法进行一次比较，最终得出x不存在活动边，所以如果需要插入abx，为了充分利用空间，所以不会单独建一个分支存放abx，而是将原来的abcabx分割成ab和cabx两段，然后再为ab增加一个分支存放x。而分割的边就是活动边，分割的长度就是活动长度。</em></p>
<hr>
<p>这时我们处理了abx,并且把剩余后缀数减为2。现在我们需要插入下一个剩余后缀bx。但是在我们做这些之前，我们需要修改活动节点。分割并插入一条边遵循的规则称作<strong>规则1</strong>，如下，而且它适用于活动节点是根节点的情况（针对下面后续的其他情况，我们将要了解规则3）。规则1如下：</p>
<p>向根节点插入遵循：</p>
<ul>
<li>活动节点保留为根节点</li>
<li>设置活动边为我们需要插入的新后缀的第一个字符，也就是b。</li>
<li>活动长度减1</li>
</ul>
<p>因此，新的活动节点三元组(root,’b’,1)表明要做的下一个插入在bcabx边，第一个字符之后，即b之后。我们可以确定插入点的时间复杂度为 O(1)，并且检查x是否已经出现在树里。如果它出现在这条边里，我们将结束当前的步骤，保持一切为原样。然而如果x没有出现在这条边里，那么我们分割这条边而插入它：</p>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffixtree/ukkonens-suffixtree_12.png" alt="这里写图片描述"></p>
<hr>
<p><em><b>注释6</b>：上面进行了一次分割，所以引入了规则1，规则1的前提条件是向根节点插入，但是我们插入的是在a这个分支，其实我觉得应该是这么理解：进行分割时如果活动节点是根节点，则依旧保留为根节点；至于第二个 设置活动边为b，这个可不是这么一句话就可以认定的，需要从活动节点进行一次查找，不过肯定是存在的，因为存在ab，则必然存在b。如果剩余的是bcx，则找到b之后还需要继续找c，找x。最终找不到就分割，然后重复以上步骤即可。</em></p>
<hr>
<p>再此说明，它的时间复杂度为 O(1)，而且我们按照规则1所示把剩余后缀数修改为1，活动节点修改为(root,’x’,0)。</p>
<p>不过还有一件事情我们必须做。我们称它为<strong>规则2</strong>：</p>
<blockquote>
<p>如果我们分割一条边并插入新的节点，而且如果它不是在当前步骤里创建的第一个节点的话，我们通过特殊的指针，即后缀连接，把 以前插入的节点和新增的节点连接起来。后面我们将明白为什么这么做是有用的。这儿我们要明白：后缀连接表示为虚线边</p>
</blockquote>
<hr>
<p><em><b>注释7</b>：后缀连接的目的是为了方便后面进行查找，不过需要注意的是：是将前一个分割的节点通过后缀节点指向后一个分割的节点，而且这两次分割必须是出现在一次插入中，即这里是出现在插入x的情况下发生的两次分割，所以可以增加后缀连接。</em></p>
<hr>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffixtree/ukkonens-suffixtree_13.png" alt="这里写图片描述"></p>
<p>我们仍然需要插入当前步骤的最终后缀x。因为活动节点的活动长度部分已经减少到0，最终直接插入到根节点上。由于根节点上没有以x开始的边，所以我们插入了新边：</p>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffixtree/ukkonens-suffixtree_14.png" alt="这里写图片描述"></p>
<p>正如你所能看到的，在当前的步骤里插入了所有剩余的后缀。</p>
<p>我们设置#=7而前进到<strong>步骤7</strong>，这将像往常一样自动添加下一个字符a到所有的叶子边上。然后我们试图插入新的最终字符到活动节点（根节点），然后发现它已经存在在这棵树里了。因此我们结束当前的步骤，不插入任何边，并且修改活动点位(root,’a’,1)。</p>
<p>设置#=8进入<strong>步骤8</strong>,我们添加b,像以前所看到的，这仅仅意味着我们修改活动点位(root,’a’,2) ,而且不需要做其他事情就增加剩余后缀数。因为b已经出现在这棵树里。然而我们（在 O(1)时间复杂度里）注意到活动节点现在是一条边的结尾。我们通过重置活动节点位(node1,’\0x’,0)来体现这个。这儿，我们用node1来指ab边结束的哪个内部节点。</p>
<hr>
<p><em><b>注释8</b>：这里出现了一个修改活动节点的规则：即如果活动边上的所有字符全部都被匹配完了(级活动边上的字符数==活动长度)，则将活动边晋升为活动节点，同时重置活动长度为0。所以下次查找时就得从该节点开始了，而不是根节点了。</em></p>
<hr>
<p>接着设置#=9进入<strong>步骤9</strong>，我们需要插入’c’,这将有助于我们理解的最后一条技巧。</p>
<h3 id="第二次扩展：使用后缀连接"><strong>第二次扩展：使用后缀连接</strong></h3><p>像往常一样，#的修改自动给每条是叶子的边添加了c，而且我们转到活动点看是否可以插入’c’。活动点显示’c’已经存在在那条边里，因此我们设置活动点为(node1,’c’,1),且增加剩余后缀数，不做任何其他事情。</p>
<p>现在设置#=10进入<strong>步骤10</strong>，剩余后缀数是4 ，因此我们首先需要在活动点插入d而实现插入abcd（这条边从第三步骤开始就一直保留着）。</p>
<p>试图在活动点插入d将引起时间复杂度为O(1)的边分割：</p>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffixtree/ukkonens-suffixtree_15.png" alt="这里写图片描述"></p>
<p>分割起始的活动点在上图中标记为红色。 最后一条规则即规则3如下： </p>
<blockquote>
<p>分割从不是根节点的活动点开始的边之后，我们应当紧跟着从活动点开始的后缀连接，如果存在一条这样的连接，那么重置活动节点使它指向这个节点。如果不存在这样后缀连接，那么我们设置活动节点为根节点，活动边和活动长度保持不变。</p>
</blockquote>
<p>因此活动节点现在是(node2,’c’,1),这里node2如下图所示标记为红色：</p>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffixtree/ukkonens-suffixtree_16.png" alt="这里写图片描述"></p>
<hr>
<p><em><b>注释9</b>：这里使用到了规则2，因为分割c的时候，活动节点是ab，而非根节点，而ab正好存在后缀节点，所以分割完活动节点就跑到了ab的后缀节点b。其实添加了abcd之后，要插入的就是bcd了，如果不使用后缀节点，则需要从根节点开始找b，但是b就一个字符，所以活动节点还是会变成b，而后缀节点就是省了这一步，所以后缀节点只是一个优化手段而已。可以看到b分割之后就需要从根节点找c了，因为b没有后缀连接快速找到c。</em></p>
<hr>
<p>由于abcd的插入已经完成，我们把剩余后缀数减为3，而且考虑当前步骤的下一个剩余后缀bcd。规则3已经设置活动点为右边的节点和边，因此插入bcd可以简单地向活动点插入剩余后缀的最后一个字符d来完成。<br>要做到这个将引起另一个边分割，<strong>根据规则2</strong> ，我们必须创建一条从以前已插入的节点开始的到新建节点的后缀连接：</p>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffixtree/ukkonens-suffixtree_17.png" alt="这里写图片描述"></p>
<p><strong>我们注意到</strong>：后缀连接使我们重置了活动点，因为我们能在O(1)复杂度下插入下一个剩余后缀。看看上面的图就可确定标签为ab的真正节点连接到节点b(它的后缀），而节点abc则连接到bc节点。</p>
<p>当前步骤仍然没有结束。现在剩余后缀数是2，我们需要遵循规则3再次重置活动节点。由于当前的活动节点（上图中红色标记的）已经没有后缀连接，我们重置活动节点位根节点。活动节点现在是(root,’c’,1)。</p>
<p>因此下一个插入发生在根节点的一条边上，以c开始的这条边的标签为：cabxabcd，位于第一个字符之后，即c之后。这将产生另一个分割：</p>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffixtree/ukkonens-suffixtree_18.png" alt="这里写图片描述"></p>
<p>另外，由于这涉及到新的内部节点的创建，我们遵循规则2，设置一条新的从前面已创建的内部节点开始的后缀连接：</p>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffixtree/ukkonens-suffixtree_19.png" alt="这里写图片描述"></p>
<p>（为了制作这些小图，我使用了<a href="http://www.graphviz.org/" target="_blank" rel="external">Graphviz Dot</a>软件。新的后缀连接使得Dot软件爱你重新布局了已经存在的边，因此仔细地检查并确定上图中插入的唯一的东西就是一条新的后缀连接。）</p>
<p>创建了这条连接，剩余后缀树可设置为1 ，另外由于活动节点是根节点，我们根据规则1修改活动点位(root,’d’,0)。这意味着这一步的最后一个插入是向根节点插入单独的d：</p>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffixtree/ukkonens-suffixtree_20.png" alt="这里写图片描述"></p>
<hr>
<p><em><b>注释10</b>：到这里全部的步骤就结束了，后面的一些需要主要的地方都是这个算法需要注意的地方，所以需要先了解这个算法的运作原理才能看懂后面的注意。</em></p>
<hr>
<p>这是最后一步，至此我们已经完成了后缀树的建立。虽然工作已经完成，但还有许多最后要注意的地方：</p>
<ul>
<li>在每一步里，我们向前移动#一个位置。这自动在时间复杂度O(1)内修改了所有的叶子结点。</li>
<li>不过，后缀树没有处理 a) 前一步骤保留下来的任何后缀 b)和当前步骤的最后一个字符。</li>
<li>剩余后缀树告诉我们我们需要做多少个后续的插入。这些插入把一对一对应为在当前位置#结束的字符串的最后的后缀。我们认为是一个接着一个，然后再对它们进行插入。重要的是：每条插入都在O(1)的时间复杂度内完成，因为活动点告诉我们确切的位置，然后我们只需要在活动点增加一个单独的字符。为什  么？因为其他字符都隐含地包含了（否则活动点将是其他地方）。</li>
<li>在做了每个这样的插入之后，我们把剩余后缀数减少，并且如果存在后缀的边，就添加一条后缀连接。如果不存在，(根据规则3）我们把活动节点设置为根节点。如果我们已经处在根节点，那么我们根据规则1修改活动节点。在任何情况下，它只花费O(1)的时间复杂度。</li>
<li>在任意插入期间，我们发现我们需要插入的字符已经存在，那么我们不作任何事情而结束当前步骤，甚至在剩余后缀树大于0的情况下。理由是保留的任何插入都是我们试图插入的边的后缀。因此它们所有都隐藏在当前的树里。事实是剩余后缀树大于0确保我们后续对剩余后缀的处理。</li>
<li>如果在算法结束时剩余后缀数大于0意味着什么呢？将是这中情况：结束的文本是以前出现在某个地方的这个文本的子字符串。在这种  情况下，我们必须给这个字符串结尾添加一个额外以前没有出现过的字符。在这样的文档里，通常使用美元符号$作为解决这个问题的符号。<strong>为什么会发生这种事情呢？</strong>—&gt;如果后来我们使用完整的后缀树搜寻后缀，那么我们只有在后缀结束于叶子时才接受搜寻匹配。否则我们会得到许多假的匹配，因为后缀树立简单地包含了不是猪字符串的真正后缀的许多这样的字符串。在结束的时候强制剩余后  缀数为0是确保所有的后缀都结束在叶子节点的重要方法。然而，如果玩么想用这棵树来寻找通常的子字符串，而不仅仅是主字符串的后缀，那么根据下面OP的评论的建议，最后一步确实不是必需的。</li>
<li>那么，整个算法的复杂性如何呢？如果文本是长度为n的字符组成，那么显然需要n步（或者如果我们增加了没有符号，那么就是n+1 步）。在每个步骤里，我们要么（除了修改变量外）什么都不做，要门我们插入剩余的后缀，每一步都花费O(1)时间复杂度。由于剩余后缀数表明了我们在以前的步骤里不做任何事情的次数，而且现在我们每做一次插入就对剩余后缀数递减，我们做这样的事情  总的次数准确地说是n(或者n+1)。因此，整体的复杂度是O(n)。</li>
<li><p>然而，有一处小的地方我没有正确地说明： 可能发生这样的情况，我们添加了一条后缀连接，修改活动点，然后发现活动点的活动长度与新的活动节点不能一起正常工作。例如，看看下面这种情况：</p>
<p>  <img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/suffixtree/ukkonens-suffixtree_21.png" alt="这里写图片描述"><br>（短划线指的是这棵树的剩余部分，虚线指的是后缀连接。）</p>
</li>
</ul>
<p>现在，假设活动节点是(red,’d’,3),因此它指向def边的f之后的位置。现在假设我们做了必须的修改，而且现在依据规则3续接了后缀连接并修改了活动节点。新的活动节点是(green,’d’,3)。然而从绿色节点出发的d边是de，因此这条边只有2个字符。为了找到正确的活动点，很明显我们需要添加一个到蓝色节点的边，然后重置活动节点为(blue,’f’,1)。</p>
<p>在特别糟的情况下，活动长度可以是剩余后缀数那么大，它甚至可以与n一样大。再在找正确的活动节点的时候，这种情况可能刚好发生，我们不仅仅需要跳过一个内部节点长度，不过也许很长，最坏的情况是高达n。由于在每一步里 剩余后缀的插入通常是O(n)，续接了后缀之后的对活动节点的后续调整也是O(n)的复杂度 ，这是否意味着这个算法具有隐藏的O(n 2)的复杂度？</p>
<p>不是这样的，理由是如果我们确实需要调整活动节点（例如，如上图所示从绿色节点调整到蓝色节点），那么这就给我们引入了一个拥有自己的后缀连接的新节点，而且活动长度将缩减。当我们沿着后缀连接这个链向下走，我们就要插入剩余的后缀，且只是缩减活动长度，使用这种方法我们可以调整的活动点的数目不可能超过任何给定时刻的活动长度。由于活动长度从来不会超过剩余后缀数，而后缀剩余数不仅仅在每个单一步骤里是O(n)，而且对整个处理过程进行的剩余后缀递增的总数也是O(n)，因此调整活动节点的数目也是以O(n)为界的。</p>
<hr>
<p><em><b>注释11</b>：最后一点注释，这里的<strong>注意</strong>其实主要证明为什么算法时O(n)，以及为了某种特殊目的需要在字符串后面加一个$。</em></p>
<hr>
<hr>
<p>上面就是Ukkonen算法的全部内容，下面就是将其使用程序进行实现了，太长了，<a href="http://vickyqi.com/2015/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%90%8E%E7%BC%80%E6%A0%91Java%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81/">见下一篇吧~~~</a></p>
<h2 id="参考文章"><strong>参考文章</strong></h2><p><a href="http://www.oschina.net/translate/ukkonens-suffix-tree-algorithm-in-plain-english" target="_blank" rel="external">Ukkonen 的后缀树算法的清晰解释</a><br><a href="http://www.cnblogs.com/gaochundong/p/suffix_tree.html" target="_blank" rel="external">后缀树</a><br><a href="http://blog.csdn.net/v_july_v/article/details/6897097" target="_blank" rel="external">从Trie树（字典树）谈到后缀树（10.28修订）</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>后缀树，说的通俗点就是将一个字符串所有的后缀按照<a href="http://vickyqi.com/2015/11/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94Tr]]>
    </summary>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="数据结构" scheme="http://vickyqi.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构" scheme="http://vickyqi.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JDK并发工具类源码学习系列——LinkedBlockingQueue]]></title>
    <link href="http://vickyqi.com/2015/11/23/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94LinkedBlockingQueue/"/>
    <id>http://vickyqi.com/2015/11/23/JDK并发工具类源码学习系列——LinkedBlockingQueue/</id>
    <published>2015-11-23T12:27:00.000Z</published>
    <updated>2015-11-23T10:49:26.000Z</updated>
    <content type="html"><![CDATA[<p>LinkedBlockingQueue是一个基于已链接节点的、范围任意的 blocking queue。此队列按 FIFO（先进先出）排序元素。队列的头部 是在队列中时间最长的元素。队列的尾部 是在队列中时间最短的元素。新元素插入到队列的尾部，并且队列获取操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。<br><a id="more"></a></p>
<h5 id="使用场景"><strong>使用场景</strong></h5><p>LinkedBlockingQueue常用于生产者/消费者模式中，作为生产者和消费者的通信桥梁。LinkedBlockingQueue与之前介绍的ConcurrentLinkedQueue以及PriorityBlockingQueue功能类似，都是Queue的一种，不同之处是：</p>
<ul>
<li>LinkedBlockingQueue和PriorityBlockingQueue是阻塞的，而ConcurrentLinkedQueue是非阻塞的，</li>
<li>同时LinkedBlockingQueue和PriorityBlockingQueue通过加锁实现线程安全，而ConcurrentLinkedQueue使用CAS实现无锁模式</li>
<li>PriorityBlockingQueue支持优先级</li>
</ul>
<p>由于不同的特征，所以以上三者的使用场景也不同：</p>
<ul>
<li>LinkedBlockingQueue适合需要阻塞的队列场景，如果能不阻塞或者可以通过代码自行实现阻塞，那么建议使用ConcurrentLinkedQueue代替</li>
<li>ConcurrentLinkedQueue适合对性能要求较高，同时无需阻塞的场景使用</li>
<li>PriorityBlockingQueue适合需要根据任务的不同优先级进行调整队列的顺序的场景</li>
</ul>
<h5 id="结构预览"><strong>结构预览</strong></h5><p>LinkedBlockingQueue内部实现相对较简单，直接使用一个链表存储数据，通过加锁实现线程安全，通过两个Condition分别实现入队和出队的等待。链表的节点使用内部类：Node表示，Node很简单，就两个变量，由外部类直接修改即可。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Linked list <span class="keyword">node</span><span class="identifier"> </span><span class="title">class</span></span><br><span class="line"> */</span><br><span class="line">static class <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;E</span>&gt; &#123;</span><br><span class="line">    /** The item, volatile to ensure barrier separating <span class="operator">write</span> <span class="operator">and</span> <span class="operator">read</span> */</span><br><span class="line">    volatile E item;</span><br><span class="line">    <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;E</span>&gt; next;</span><br><span class="line">    <span class="keyword">Node</span><span class="identifier"></span><span class="title">(E</span> x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>item使用volatile修饰，解决内存可见性。</p>
<h5 id="常用方法解析"><strong>常用方法解析</strong></h5><p>LinkedBlockingQueue常用方法有：入队（offer(E)/offer(E, long, TimeUnit)/put(E)）、出队（poll()/poll(long, TimeUnit)/take()）、删除（remove(Object)）。下面分别看看这三类方法。</p>
<h6 id="入队"><strong>入队</strong></h6><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @By Vicky:入队，无阻塞，队列未满则直接入队，否则直接返回false</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> offer(E e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger <span class="keyword">count</span> = <span class="keyword">this</span>.<span class="keyword">count</span>;<span class="comment">// 保存当前队列的长度</span></span><br><span class="line">    <span class="comment">// 这里因为count是Atomic的，所以有类似volatile的内存可见性效果</span></span><br><span class="line">    <span class="comment">// 即对count的修改能够立即被其他线程可见，所以此处不加锁的情况下读取count值是会读取到最新值的</span></span><br><span class="line">    <span class="comment">// 然后根据此值进行前置判断，避免不必要的加锁操作</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">count</span>.get() == capacity)<span class="comment">// 队列已满直接返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;<span class="comment">// 获取putLock，加锁</span></span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">count</span>.get() &lt; capacity) &#123;<span class="comment">// 队列未满则插入</span></span><br><span class="line">            insert(e);</span><br><span class="line">            c = <span class="keyword">count</span>.getAndIncrement();<span class="comment">// 更新count值</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)<span class="comment">// 未满则唤醒等待在notFull上的线程</span></span><br><span class="line">            	<span class="comment">// 此处有点怪异，入队唤醒notFull~</span></span><br><span class="line">            	<span class="comment">// 此处唤醒notFull是考虑有可能如果多个线程同时出队，由于出队唤醒notFull时也需要对putLock进行加锁</span></span><br><span class="line">            	<span class="comment">// 所以有可能一个线程出队，唤醒notFull，但是被另一个出队线程抢到了锁，所以入队线程依旧在等待</span></span><br><span class="line">            	<span class="comment">// 当另一个线程也唤醒了notFull，释放了putLock后，只能唤醒一个入队线程，所以其他线程依旧在等待</span></span><br><span class="line">            	<span class="comment">// 所以此处需要再次唤醒notFull</span></span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// c==0表示队列在插入之前是空的，所以需要唤醒等待在notEmpty上的线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @By Vicky:唤醒notEmpty，需对takeLock进行加锁，因为notEmpty与takeLock相关</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> signalNotEmpty() &#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先解析offer()，另外两个入队操作只是在队列已满的情况下进行一些特殊处理而已。文中代码给出了详细注释，这里着重说明两个地方：</p>
<ul>
<li>对Condition的操作需要在加锁的环境下进行，而且是需要对与Condition相关的锁进行加锁，如此处notEmpty是由takeLock.newCondition()得来，所以对notEmpty的操作需要对takeLock进行加锁</li>
<li>入队操作也执行<code>notFull.signal();</code>的原因是避免入队线程未抢到锁而遗失了出队的唤醒操作。详细解析可以见文中的注释</li>
</ul>
<p>下面直接贴出offer(E, long, TimeUnit)和put(E)的代码，基本同offer(E)。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @By Vicky:入队，等待指定时间</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> offer(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger <span class="keyword">count</span> = <span class="keyword">this</span>.<span class="keyword">count</span>;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        	<span class="comment">// 此处同offer()</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">count</span>.get() &lt; capacity) &#123;</span><br><span class="line">                insert(e);</span><br><span class="line">                c = <span class="keyword">count</span>.getAndIncrement();</span><br><span class="line">                <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                    notFull.signal();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// nanos是剩余的等待时间，&lt;=0表示等待时间已到</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            	<span class="comment">// 调用notFull的awaitNanos，指定等待时间，如果等待期间被唤醒，则返回剩余等待时间，&lt;0表示等待时间已到</span></span><br><span class="line">                nanos = notFull.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                notFull.signal(); <span class="comment">// propagate to a non-interrupted thread</span></span><br><span class="line">                <span class="keyword">throw</span> ie;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @By Vicky:入队，无期限等待</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> put(E e) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// <span class="doctag">Note:</span> convention in all put/take/etc is to preset</span></span><br><span class="line">    <span class="comment">// local var holding count  negative to indicate failure unless set.</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger <span class="keyword">count</span> = <span class="keyword">this</span>.<span class="keyword">count</span>;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">count</span>.get() == capacity)<span class="comment">// 无限等待，直到可用</span></span><br><span class="line">                notFull.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">            notFull.signal(); <span class="comment">// propagate to a non-interrupted thread</span></span><br><span class="line">            <span class="keyword">throw</span> ie;</span><br><span class="line">        &#125;</span><br><span class="line">        insert(e);</span><br><span class="line">        c = <span class="keyword">count</span>.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="出队"><strong>出队</strong></h6><p>出队操作和入队逻辑相同，看代码。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @By Vicky:出队，无阻塞，队列为空则直接返回null</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> E poll() &#123;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger <span class="keyword">count</span> = <span class="keyword">this</span>.<span class="keyword">count</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">count</span>.get() == <span class="number">0</span>)<span class="comment">// 队列为空，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">count</span>.get() &gt; <span class="number">0</span>) &#123;<span class="comment">// 不为空，获取一个元素</span></span><br><span class="line">            x = extract();</span><br><span class="line">            c = <span class="keyword">count</span>.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)<span class="comment">// 同offer()，此处需唤醒notEmpty</span></span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();<span class="comment">// 同offer()，此处需唤醒notFull</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @By Vicky:出队，将head指向head.next</span><br><span class="line"> * @return</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> E extract() &#123;</span><br><span class="line">    Node&lt;E&gt; first = head.<span class="keyword">next</span>;</span><br><span class="line">    head = first;</span><br><span class="line">    E x = first.item;</span><br><span class="line">    first.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @By Vicky:唤醒notFull，需对putLock进行加锁，因为notFull与putLock相关</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> signalNotFull() &#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队一个元素：<code>extract()</code>，逻辑很简单，将head指向head.next即可。其他地方与offer()的逻辑相同，如队列未空需唤醒notEmpty，队列由满变空需唤醒notFull，原因完全同offer()。poll(long, TimeUnit)和take()代码就不贴出来了，完全与offer()相同。</p>
<h6 id="删除"><strong>删除</strong></h6><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @By Vicky:删除指定元素</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> remove(Object o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    fullyLock();<span class="comment">// 同时对takeLock和pullLock加锁，避免任何的入队和出队操作</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Node&lt;E&gt; trail = head;</span><br><span class="line">        Node&lt;E&gt; p = head.<span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;<span class="comment">// 从队列的head开始循环查找与o相同的元素</span></span><br><span class="line">            <span class="keyword">if</span> (o.equals(p.item)) &#123;<span class="comment">// 找到相同的元素则设置remove为true</span></span><br><span class="line">                removed = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            trail = p;<span class="comment">// 继续循环</span></span><br><span class="line">            p = p.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">        	<span class="comment">// remove==true，则表示查找到待删除元素，即p，将trail的next指向p的next，即将p从队列移除及完成删除</span></span><br><span class="line">            p.item = <span class="keyword">null</span>;</span><br><span class="line">            trail.<span class="keyword">next</span> = p.<span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">if</span> (last == p)</span><br><span class="line">                last = trail;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">count</span>.getAndDecrement() == capacity)</span><br><span class="line">                notFull.signalAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fullyUnlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除的逻辑也很简单，代码中给出了注释。</p>
<p>以上即本篇全部内容，比较简单，更多关于队列的研究可参考：</p>
<ul>
<li><a href="http://vickyqi.com/2015/10/29/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentLinkedQueue/">JDK并发工具类源码学习系列——ConcurrentLinkedQueue</a></li>
<li><a href="http://vickyqi.com/2015/11/20/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94PriorityBlockingQueue/">JDK并发工具类源码学习系列——PriorityBlockingQueue</a></li>
</ul>
<p>以上内容如有错误，请不吝赐教~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>LinkedBlockingQueue是一个基于已链接节点的、范围任意的 blocking queue。此队列按 FIFO（先进先出）排序元素。队列的头部 是在队列中时间最长的元素。队列的尾部 是在队列中时间最短的元素。新元素插入到队列的尾部，并且队列获取操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。<br>]]>
    
    </summary>
    
      <category term="JDK" scheme="http://vickyqi.com/tags/JDK/"/>
    
      <category term="JUC" scheme="http://vickyqi.com/tags/JUC/"/>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="JDK源码" scheme="http://vickyqi.com/categories/Java/JDK%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构系列——Trie树]]></title>
    <link href="http://vickyqi.com/2015/11/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94Trie%E6%A0%91/"/>
    <id>http://vickyqi.com/2015/11/23/数据结构系列——Trie树/</id>
    <published>2015-11-23T12:14:00.000Z</published>
    <updated>2015-11-23T07:21:10.000Z</updated>
    <content type="html"><![CDATA[<p>Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。<br><a id="more"></a></p>
<h5 id="Trie树结构"><strong>Trie树结构</strong></h5><p>Trie的核心思想是空间换时间：利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p>
<p>举例：将tea，ten，to，in，inn，int几个单词构建成一个Trie树，看一下具体的Tried树的结构：</p>
<p><strong>图：Trie树结构</strong><br><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/trietree.jpg" alt="Trie树结构"></p>
<p>从图中可以看出Trie树的某些特性：</p>
<ol>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ol>
<h5 id="Trie树实现"><strong>Trie树实现</strong></h5><p>Trie树的插入、删除、查找的操作都是一样的，只需要简单的对树进行一遍遍历即可，时间复杂度：O（n）（n是字符串的长度）。<br>对于Tried树的实现可以使用数组和链表两种方式：</p>
<ul>
<li>数组：由于我们知道一个Tried树节点的子节点的数量是固定26个（针对不同情况会不同，比如兼容数字，则是36等），所以可以使用固定长度的数组来保存节点的子节点<ul>
<li>优点：在对子节点进行查找时速度快</li>
<li>缺点：浪费空间，不管子节点有多少个，总是需要分配26个空间</li>
</ul>
</li>
<li>链表：使用链表的话我们需要在每个子节点中保存其兄弟节点的链接，当我们在一个节点的子节点中查找是否存在一个字符时，需要先找到其子节点，然后顺着子节点的链表从左往右进行遍历<ul>
<li>优点：节省空间，有多少个子节点就占用多少空间，不会造成空间浪费</li>
<li>缺点：对子节点进行查找相对较慢，需要进行链表遍历，同时实现也较数组麻烦</li>
</ul>
</li>
</ul>
<p>下面是最简单的Trie树的实现，采用数组的方式。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 最简单的Trie树结构，仅表示出Trie树的结构，实际应用需进行扩展</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * @author Vicky</span><br><span class="line"> * @email vicky01200059@163.com</span><br><span class="line"> * @2015年11月23日</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> TrieNode root = <span class="keyword">new</span> TrieNode(<span class="string">'a'</span>);<span class="comment">// TrieTree的根节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 插入</span><br><span class="line">	 * </span><br><span class="line">	 * @param word</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> insertWord(String word) &#123;</span><br><span class="line">		TrieNode <span class="keyword">index</span> = <span class="keyword">this</span>.root;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : word.toLowerCase().toCharArray()) &#123;</span><br><span class="line">			<span class="keyword">index</span> = <span class="keyword">index</span>.addChild(c);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * TrieTree的节点</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">		<span class="comment">/** 该节点的字符 */</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> nodeChar;<span class="comment">//</span></span><br><span class="line">		<span class="comment">/** 一个TrieTree的节点的子节点 */</span></span><br><span class="line">		<span class="keyword">private</span> TrieNode[] childNodes = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> TrieNode(<span class="keyword">char</span> nodeChar) &#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">			<span class="keyword">this</span>.nodeChar = nodeChar;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> TrieNode addChild(<span class="keyword">char</span> ch) &#123;</span><br><span class="line">			<span class="keyword">int</span> <span class="keyword">index</span> = ch - <span class="string">'a'</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> == childNodes) &#123;</span><br><span class="line">				<span class="keyword">this</span>.childNodes = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> == childNodes[<span class="keyword">index</span>]) &#123;</span><br><span class="line">				childNodes[<span class="keyword">index</span>] = <span class="keyword">new</span> TrieNode(ch);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> childNodes[<span class="keyword">index</span>];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		<span class="keyword">public</span> String toString() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"TrieNode [nodeChar="</span> + nodeChar + <span class="string">"]"</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">		Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line">		trie.insertWord(<span class="string">"Vicky"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Trie树应用"><strong>Trie树应用</strong></h5><p>Trie树的应用主要是集中于字符串的处理。<br>（1）字符串检索</p>
<ul>
<li>精确查找：给定一组字符串，查找某个字符串是否出现过</li>
<li>前缀匹配：给定一组字符串，查找以某个字符串为前缀的字符串集合</li>
<li>…</li>
</ul>
<p>（2）最长公共前缀</p>
<ul>
<li>查找一组字符串的最长公共前缀，只需要将这组字符串构建成Trie树，然后从跟节点开始遍历，直到出现多个节点为止（即出现分叉）</li>
</ul>
<p>（3）排序</p>
<ul>
<li>将一组字符串按照字典序进行排序，只需构建成Trie树，然后按照先序遍历即可</li>
</ul>
<p>。。。</p>
<p>下面我们针对Trie树的应用，选择一个相对简单且有代表性的案例：从一组单词中查找所有以“vi”开头的字符串，同时查找“Vicky”是否出现过。（由于我们只保存26个字符，所以不区分大小写，也不支持非单词字符）。</p>
<p>从网上download下一个单词表，根据单词表构建Trie树，并进行查找，单词表可以从<a href="https://github.com/dwyl/english-words" target="_blank" rel="external">https://github.com/dwyl/english-words</a>进行下载。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vicky.datastructure.tree.trie;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 一个支持前缀查找以及精确查找的Trie树</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@author</span> Vicky</span><br><span class="line"> * <span class="doctag">@email</span> vicky01200059@163.com</span><br><span class="line"> * @2015年11月23日</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixTrie</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> TrieNode root = <span class="keyword">new</span> TrieNode(<span class="string">'a'</span>);<span class="comment">// TrieTree的根节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 插入</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> word</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">insertWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">		TrieNode index = <span class="keyword">this</span>.root;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : word.toLowerCase().toCharArray()) &#123;</span><br><span class="line">			index = index.addChild(c);</span><br><span class="line">			index.addPrefixCount();</span><br><span class="line">		&#125;</span><br><span class="line">		index.addCount();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 查找</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> word</span><br><span class="line">	 * <span class="doctag">@return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">selectWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">		TrieNode index = <span class="keyword">this</span>.root;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : word.toLowerCase().toCharArray()) &#123;</span><br><span class="line">			index = index.getChild(c);</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> == index) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> index.getCount() &gt; <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 查找前缀出现的次数</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> prefix</span><br><span class="line">	 * <span class="doctag">@return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">selectPrefixCount</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">		TrieNode index = <span class="keyword">this</span>.root;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : prefix.toLowerCase().toCharArray()) &#123;</span><br><span class="line">			index = index.getChild(c);</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> == index) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">return</span> index.<span class="title">getPrefixCount</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * TrieTree的节点</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">		<span class="comment">/** 该节点的字符 */</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> nodeChar;<span class="comment">//</span></span><br><span class="line">		<span class="comment">/** 一个TrieTree的节点的子节点 */</span></span><br><span class="line">		<span class="keyword">private</span> TrieNode[] childNodes = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">// 单词数量，用于判断一个单词是否存在</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> prefixCount = <span class="number">0</span>;<span class="comment">// 前缀数量，用于查找该前缀出现的次数</span></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> nodeChar)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">			<span class="keyword">this</span>.nodeChar = nodeChar;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="function">TrieNode <span class="title">addChild</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">int</span> index = ch - <span class="string">'a'</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> == childNodes) &#123;</span><br><span class="line">				<span class="keyword">this</span>.childNodes = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> == childNodes[index]) &#123;</span><br><span class="line">				childNodes[index] = <span class="keyword">new</span> TrieNode(ch);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> childNodes[index];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="function">TrieNode <span class="title">getChild</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">int</span> index = ch - <span class="string">'a'</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> == childNodes || <span class="keyword">null</span> == childNodes[index]) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> childNodes[index];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">addCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.count++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">addPrefixCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.prefixCount++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">getPrefixCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.prefixCount;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="function">String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"TrieNode [nodeChar="</span> + nodeChar + <span class="string">"]"</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.vicky.datastructure.tree.trie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieUsedTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> PrefixTrie trie;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Before</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		Pattern pattern = Pattern.compile(<span class="string">"[a-zA-Z]+"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从文件中读取单词，构建TriedTree</span></span><br><span class="line">		InputStreamReader read = <span class="keyword">new</span> InputStreamReader(<span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"words.txt"</span>));</span><br><span class="line">		BufferedReader reader = <span class="keyword">new</span> BufferedReader(read);</span><br><span class="line">		trie = <span class="keyword">new</span> PrefixTrie();</span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">null</span> != (line = reader.readLine())) &#123;</span><br><span class="line">			line = line.trim();</span><br><span class="line">			<span class="keyword">if</span> (!pattern.matcher(line).matches()) &#123;<span class="comment">// 去除非法单词，如包含“-”</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			trie.insertWord(line);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 测试使用TriedTree搜索前缀出现的次数</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="annotation">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">searchPrefixWords</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String prefix = <span class="string">"vi"</span>;</span><br><span class="line">		System.out.println(trie.selectPrefixCount(prefix));</span><br><span class="line">		System.out.println(trie.selectWord(<span class="string">"Vicky"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中为了支持精确查找和前缀查找两种方式，我们对TrieNode进行修改，增加了<code>private int count = 0;private int prefixCount = 0;</code>两个变量，分别用于保存单词出现的次数，以及前缀出现的次数。测试结果可通过使用文本编辑器进行查找对比。</p>
<p>更多关于Trie树的应用场景可阅读参考文章1。</p>
<h5 id="参考文章"><strong>参考文章</strong></h5><p><a href="http://dongxicheng.org/structure/trietree/" target="_blank" rel="external">数据结构之Trie树</a><br><a href="http://blog.csdn.net/v_july_v/article/details/6897097" target="_blank" rel="external">从Trie树（字典树）谈到后缀树（10.28修订）</a><br><a href="http://www.cnblogs.com/huangxincheng/archive/2012/11/25/2788268.html" target="_blank" rel="external">6天通吃树结构—— 第五天 Trie树</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="数据结构" scheme="http://vickyqi.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构" scheme="http://vickyqi.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JDK并发工具类源码学习系列——PriorityBlockingQueue]]></title>
    <link href="http://vickyqi.com/2015/11/20/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94PriorityBlockingQueue/"/>
    <id>http://vickyqi.com/2015/11/20/JDK并发工具类源码学习系列——PriorityBlockingQueue/</id>
    <published>2015-11-20T12:18:00.000Z</published>
    <updated>2015-11-23T10:48:22.000Z</updated>
    <content type="html"><![CDATA[<p>PriorityBlockingQueue是一个基于优先级堆的无界的并发安全的优先级队列（FIFO），队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。<br><a id="more"></a></p>
<h5 id="实现原理"><strong>实现原理</strong></h5><p>PriorityBlockingQueue通过使用堆这种数据结构实现将队列中的元素按照某种排序规则进行排序，从而改变先进先出的队列顺序，提供开发者改变队列中元素的顺序的能力。队列中的元素必须是可比较的，即实现Comparable接口，或者在构建函数时提供可对队列元素进行比较的Comparator对象。</p>
<h5 id="堆的介绍"><strong>堆的介绍</strong></h5><p>由于PriorityBlockingQueue是基于堆的，所以这里简单介绍下堆的结构。堆是一种二叉树结构，堆的根元素是整个树的最大值或者最小值（称为大顶堆或者小顶堆），同时堆的每个子树都是满足堆的树结构。由于堆的顶部是最大值或者最小值，所以每次从堆获取数据都是直接获取堆顶元素，然后再将堆调整成堆结构。</p>
<p>更多关于堆的介绍请参考：<a href="http://vickyqi.com/2015/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%A0%86/">数据结构系列——堆</a></p>
<h5 id="结构介绍"><strong>结构介绍</strong></h5><p>PriorityBlockingQueue通过内部组合PriorityQueue的方式实现优先级队列（<code>private final PriorityQueue<e> q;</e></code>），另外在外层通过ReentrantLock实现线程安全，同时通过Condition实现阻塞唤醒。</p>
<h5 id="常用方法介绍"><strong>常用方法介绍</strong></h5><p>PriorityBlockingQueue继承自AbstractQueue，以及实现了BlockingQueue接口，是一个阻塞队列，主要方法：offer(E)/poll()/poll(long, TimeUnit)/take()/remove(Object)。下面我们结合源码堆这些方法进行深入分析。</p>
<h6 id="offer(E)"><strong>offer(E)</strong></h6><p>入队操作。此处虽然PriorityBlockingQueue是阻塞队列，但是其并没有阻塞的入队方法，因为该队列是无界的，所以入队是不会阻塞的。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">offer</span>(<span class="params">E e</span>) </span>&#123;</span><br><span class="line">	final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();<span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// 通过PriorityQueue入队一个元素</span></span><br><span class="line">        boolean ok = q.offer(e);</span><br><span class="line">        assert ok;</span><br><span class="line">        <span class="comment">// 唤醒等在notEmpty上的线程</span></span><br><span class="line">        notEmpty.signal();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">return</span> <span class="title">offer</span><span class="params">(e)</span></span>; <span class="comment">// never need to block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>offer()方法正如在结构介绍中提到的通过组合的方式，通过外部加锁内部直接调用PriorityQueue的offer()方法。所以主要的工作在PriorityQueue内部。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *@By Vicky:入队一个元素</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (e == null)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">	modCount++;</span><br><span class="line">	<span class="keyword">int</span> i = size;</span><br><span class="line">	<span class="comment">// 内部使用数组保存队列的元素，所以如果队列的大小超过数组的长度，则需要进行扩容</span></span><br><span class="line">	<span class="comment">// 扩容的标准是：&lt;64扩大2倍，&gt;=64则扩大1.5倍</span></span><br><span class="line">	<span class="keyword">if</span> (i &gt;= <span class="built_in">queue</span>.length)</span><br><span class="line">		grow(i + <span class="number">1</span>);</span><br><span class="line">	size = i + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// i==0表示队列目前没有元素，则直接将带插入元素添加到数组即可</span></span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">queue</span>[<span class="number">0</span>] = e;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="comment">// 将带插入元素添加到队列的最后一个元素，然后自下而上调整堆</span></span><br><span class="line">		siftUp(i, e);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *@By Vicky:自下而上调整堆 </span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 两者逻辑一样，只是采用的比较方式不同而已</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != null)</span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">*@By Vicky:自下而上调整堆 </span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 循环，直到根元素</span></span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">// 寻找k的父元素下标，固定规则，可参考博客：http://vickyqi.com/</span></span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = <span class="built_in">queue</span>[parent];</span><br><span class="line">        <span class="comment">// 如果x &gt;= e，即子节点&gt;=父节点，则直接退出循环</span></span><br><span class="line">        <span class="comment">// 解释：自下而上一般出现在插入元素时调用，插入元素是插入到队列的最后，则需要将该元素调整到合适的位置</span></span><br><span class="line">        <span class="comment">// 即从队列的最后往上调整堆，直到不小于其父节点为止，相当于冒泡</span></span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 如果当前节点&lt;其父节点，则将其与父节点进行交换，并继续往上访问父节点</span></span><br><span class="line">        <span class="built_in">queue</span>[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队时通过调用ReentrantLock.lock()进行加锁，然后调用PriorityQueue.offer()方法进行入队操作，最后通过Condition.signal()唤醒等待其上的线程。PriorityQueue.offer()方法将元素插入到队列的最后，然后自上而下调整堆。文中代码都给出了注释，同时可参考博客：<a href="http://vickyqi.com/2015/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%A0%86/">数据结构系列——堆</a>进行详细的了解。</p>
<h6 id="poll()和poll(long,_TimeUnit)，take()"><strong>poll()和poll(long, TimeUnit)，take()</strong></h6><p>出队操作。poll(long, TimeUnit)是poll()的阻塞版本，同时take()是无限阻塞版poll()（即无期限阻塞，直到获取到数据），通过Condition.awaitNanos()实现阻塞。三者实现主要逻辑相同，只是在等待时不同，这里主要介绍poll(long, TimeUnit)。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @By Vicky:阻塞版的出队</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span>(<span class="params"><span class="keyword">long</span> timeout, TimeUnit unit</span>) throws InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">	final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">	<span class="comment">// 此处不同于其他非阻塞方法，调用了ReentrantLock的lockInterruptibly()方法，考虑了当前线程是否被打断</span></span><br><span class="line">	<span class="keyword">lock</span>.lockInterruptibly();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 循环，直到获取到元素，或者到达等待时间</span></span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">			<span class="comment">// 从PriorityQueue获取一个元素，该方法不会阻塞</span></span><br><span class="line">			E x = q.poll();</span><br><span class="line">			<span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">return</span> x;</span><br><span class="line">			<span class="comment">// 此处的nanos会因为每次调用Condition.awaitNanos而减少，如果&lt;0则说明累计等待时间已达到设定的等待时间</span></span><br><span class="line">			<span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Condition.awaitNanos指定等待时间，但是有可能会被“虚假唤醒”（参考API），导致等待时间未满，返回值即剩余的等待时间</span></span><br><span class="line">				<span class="comment">// 所以需要在外层进行循环，每次等待的时候是上次剩余的时间</span></span><br><span class="line">				nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">				notEmpty.signal(); <span class="comment">// propagate to non-interrupted thread</span></span><br><span class="line">				<span class="keyword">throw</span> ie;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">lock</span>.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的出队操作依然是调用PriorityQueue.poll()。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @By Vicky:出队一个元素</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// size==0队列为0，直接返回null</span></span><br><span class="line">	<span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> null;</span><br><span class="line">	<span class="keyword">int</span> s = --size;</span><br><span class="line">	modCount++;</span><br><span class="line">	<span class="comment">// 出队总是将数组的第一个元素进行出队，</span></span><br><span class="line">	E result = (E) <span class="built_in">queue</span>[<span class="number">0</span>];</span><br><span class="line">	E x = (E) <span class="built_in">queue</span>[s];</span><br><span class="line">	<span class="built_in">queue</span>[s] = null;</span><br><span class="line">	<span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">		<span class="comment">// 同时将队列的最后一个元素放到第一个位置，然后自上而下调整堆</span></span><br><span class="line">		siftDown(<span class="number">0</span>, x);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @By Vicky:自下而上调整堆</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != null)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @By Vicky:自下而上调整堆</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 由于堆是一个二叉树，所以size/2是树中的最后一个非叶子节点</span></span><br><span class="line">	<span class="comment">// 如果k是叶子节点，那么其无子节点，则不需要再往下调整堆</span></span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">    	<span class="comment">// 左节点，固定规则，可参考博客：http://vickyqi.com/</span></span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        Object c = <span class="built_in">queue</span>[child];</span><br><span class="line">        <span class="comment">// 右节点</span></span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 找出两个子节点以及父节点中较小的一个</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) <span class="built_in">queue</span>[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = <span class="built_in">queue</span>[child = right];</span><br><span class="line">        <span class="comment">// 如果父节点最小，则无需继续往下调整堆</span></span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 否则将父节点与两个子节点中较小的一个交换，然后往下继续调整</span></span><br><span class="line">        <span class="built_in">queue</span>[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本操作原理见代码注释，同时可参考博客：<a href="http://vickyqi.com/2015/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%A0%86/">数据结构系列——堆</a>进行详细的了解。</p>
<h6 id="remove(Object)"><strong>remove(Object)</strong></h6><p>删除其实并不是常用的方法，主要是堆在删除时还是有点值得介绍的。这里我们直接看PriorityQueue.remove()方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @By Vicky:移除指定元素</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 在队列中查询元素，返回待删除元素在队列中的位置</span></span><br><span class="line">	<span class="keyword">int</span> i = indexOf(o);</span><br><span class="line">	<span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 删除指定位置的元素</span></span><br><span class="line">		removeAt(i);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @By Vicky:删除指定位置的元素</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	assert i &gt;= <span class="number">0</span> &amp;&amp; i &lt; size;</span><br><span class="line">	modCount++;</span><br><span class="line">	<span class="keyword">int</span> s = --size;</span><br><span class="line">	<span class="keyword">if</span> (s == i) <span class="comment">// removed last element</span></span><br><span class="line">		<span class="built_in">queue</span>[i] = null;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 删除最后一个元素，将最后一个元素放到i的位置，然后从i开始上而下调整堆</span></span><br><span class="line">		E moved = (E) <span class="built_in">queue</span>[s];</span><br><span class="line">		<span class="built_in">queue</span>[s] = null;</span><br><span class="line">		siftDown(i, moved);</span><br><span class="line">		<span class="comment">// 如果queue[i] == moved说明未发生调整，那么则需要自下而上调整堆</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">queue</span>[i] == moved) &#123;</span><br><span class="line">			siftUp(i, moved);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">queue</span>[i] != moved)</span><br><span class="line">				<span class="keyword">return</span> moved;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当删除堆中的一个元素时，将堆的最后一个元素移动到被删除的位置，然后将最后一个位置值为NULL，当把最后一个元素移动到堆中的某个位置时，这时首先需要从该位置开始自上而下的调整堆，如果该位置的元素在调整时发生变化，即堆有变化，则说明该元素是大于其子节点的，那么该节点就不可能小于其上的父节点（因为堆的结构是传递性的，即子节点小于父节点，其孙子节点同时小于其父节点），所以就不需要再网上调整了；但是如果未发生变化，则说明该位置的节点小于其子节点，那么就无法保证其一定比父节点大，所以需要从该节点开始自上而下的调整堆。调整堆的方法是入队和出队时都有介绍，这里就不介绍了。</p>
<p>以上即PriorityBlockingQueue常用的一些方法，另外一些peek()，迭代等方法就不介绍了，毕竟不涉及堆的改变。</p>
<h5 id="使用场景"><strong>使用场景</strong></h5><p>PriorityBlockingQueue与普通阻塞队列的不同之处就是在于其支持对队列中的元素进行比较，而已决定出队的顺序，所以可以使用PriorityBlockingQueue实现高优先级的线程优先执行。</p>
<hr>
<p>以上即本篇的全部内容，如有错误之处，请不吝赐教~~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>PriorityBlockingQueue是一个基于优先级堆的无界的并发安全的优先级队列（FIFO），队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。<br>]]>
    
    </summary>
    
      <category term="JDK" scheme="http://vickyqi.com/tags/JDK/"/>
    
      <category term="JUC" scheme="http://vickyqi.com/tags/JUC/"/>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="JDK源码" scheme="http://vickyqi.com/categories/Java/JDK%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构系列——堆]]></title>
    <link href="http://vickyqi.com/2015/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%A0%86/"/>
    <id>http://vickyqi.com/2015/11/19/数据结构系列——堆/</id>
    <published>2015-11-19T11:30:00.000Z</published>
    <updated>2015-11-19T05:15:44.000Z</updated>
    <content type="html"><![CDATA[<p>堆（Heap）是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。在队列中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。<br><a id="more"></a></p>
<h5 id="堆的性质"><strong>堆的性质</strong></h5><p>堆的实现通过构造二叉堆（binary heap），实为二叉树的一种；由于其应用的普遍性，当不加限定时，均指该数据结构的这种实现。这种数据结构具有以下性质：</p>
<ul>
<li>任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）。</li>
<li>堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。<br>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。</li>
</ul>
<p>堆的主要应用场景有：堆排序以及优先队列</p>
<ul>
<li>堆排序可具体参考<a href="http://vickyqi.com/2015/08/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%A0%86%E6%8E%92%E5%BA%8F/">排序算法系列——堆排序</a></li>
<li>优先队列可参考<a href="http://blog.csdn.net/vickyway/article/details/49005011" target="_blank" rel="external">JDK并发工具类源码学习系列——介绍</a></li>
</ul>
<h5 id="堆的表现形式"><strong>堆的表现形式</strong></h5><p>对于理解堆以及实现堆很重要的一点就是明白堆的表现形式，堆是树的一种，所以很自然的想到使用链表来实现堆，其实不然，由于我们需要频繁的对堆进行增加删除，所以一般堆的底层都是通过数组来实现，那么就有一个问题：数组如何表现出堆的结构呢？这里就有一个规则，即数组的第一个元素（即下标为0的元素）为堆的根节点，其他节点按照堆结构自上而下，自左而右依次表示为数组中的元素，这是一种既非前序也非后序，更非中序的遍历树的方式。具体见下图。</p>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/%E5%A0%86%E7%9A%84%E6%95%B0%E7%BB%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F.jpg" alt="堆的数组表现形式"></p>
<p>明白了堆如何使用数组来表述，那么我们就很容易理解下面堆的结构特征了。</p>
<ul>
<li>parent(t)=(t - 1) &gt;&gt; 1，即t的父节点的下标=(t-1)/2，注意此处是整除，例如：t = 6，parent(t) = 2</li>
<li>left(t)=t &lt;&lt; 1 + 1，即t的左孩子的节点下标=t * 2 + 1，例如：t = 2，left(t) = 5</li>
<li>right(t)=t &lt;&lt; 1 + 2，即t的右孩子的节点下标=t * 2 + 2，例如：t = 2, right(t) = 6</li>
<li>说明：此处的下标是从0开始</li>
</ul>
<h5 id="堆的操作"><strong>堆的操作</strong></h5><p>针对堆主要的操作有：</p>
<ul>
<li>构建堆：将一个数组构建成堆的结构</li>
<li>移除堆的根节点：从堆中移除最大值（大顶堆）或者最小值（小顶堆）</li>
<li>往堆中插入一个节点：插入节点</li>
<li>调整堆：在对堆的结构进行修改之后需要进行的操作，以保证堆结构</li>
</ul>
<h5 id="堆的具体实现"><strong>堆的具体实现</strong></h5><p>下面看看一个Java版的堆的实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line">package com.vicky.datastructure.tree.heap;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * </span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 数据结构——树——堆</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * @author Vicky</span><br><span class="line"> * @email vicky01200059@163.com</span><br><span class="line"> * @2015年11月18日</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> abstract <span class="keyword">class</span> Heap &#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">int</span>[] data;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">		<span class="keyword">this</span>.length = data.length;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 构建堆</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> abstract Heap <span class="title">buildHeap</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 删除一个节点，只能删除根节点</span><br><span class="line">	 * </span><br><span class="line">	 * @return</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> abstract Heap <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 插入一个节点，只能插入到最后</span><br><span class="line">	 * </span><br><span class="line">	 * @param value</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> abstract Heap <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 从node开始自上而下调整堆</span><br><span class="line">	 * </span><br><span class="line">	 * @param node</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> abstract <span class="keyword">void</span> <span class="title">adjustDownHeap</span><span class="params">(<span class="keyword">int</span> node)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 从node开始自下而上调整堆</span><br><span class="line">	 * </span><br><span class="line">	 * @param node</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> abstract <span class="keyword">void</span> <span class="title">adjustUpHeap</span><span class="params">(<span class="keyword">int</span> node)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 交换元素</span><br><span class="line">	 * </span><br><span class="line">	 * @param n1</span><br><span class="line">	 * @param n2</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = data[n1];</span><br><span class="line">		data[n1] = data[n2];</span><br><span class="line">		data[n2] = temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 获取node的父节点的索引</span><br><span class="line">	 * </span><br><span class="line">	 * @param node</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getParentIndex</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (node - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 获取node的右孩子索引</span><br><span class="line">	 * </span><br><span class="line">	 * @param node</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getRightChildIndex</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (node &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 获取node的左孩子索引</span><br><span class="line">	 * </span><br><span class="line">	 * @param node</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getLeftChildIndex</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (node &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 打印堆</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(Arrays.toString(data));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.vicky.datastructure.tree.heap;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 最大堆</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * @author Vicky</span><br><span class="line"> * @email vicky01200059@163.com</span><br><span class="line"> * @2015年11月18日</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> MaxHeap extends Heap &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">		super(data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * &#123;@inheritDoc&#125;</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Heap <span class="title">buildHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 从最后一个节点的父节点开始构建堆</span></span><br><span class="line">		<span class="keyword">int</span> start = getParentIndex(length - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (; start &gt;= <span class="number">0</span>; start--) &#123;</span><br><span class="line">			adjustDownHeap(start);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * &#123;@inheritDoc&#125;</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Heap <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 将最后一个节点与头结点交换</span></span><br><span class="line">		swap(<span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 重新复制一个数组</span></span><br><span class="line">		<span class="keyword">int</span>[] newData = <span class="keyword">new</span> <span class="keyword">int</span>[length - <span class="number">1</span>];</span><br><span class="line">		System.arraycopy(data, <span class="number">0</span>, newData, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">this</span>.data = newData;</span><br><span class="line">		<span class="keyword">this</span>.length = length - <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 从头开始调整堆</span></span><br><span class="line">		adjustDownHeap(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * &#123;@inheritDoc&#125;</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Heap <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 插入到数组最后</span></span><br><span class="line">		<span class="keyword">int</span>[] newData = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">1</span>];</span><br><span class="line">		System.arraycopy(data, <span class="number">0</span>, newData, <span class="number">0</span>, length);</span><br><span class="line">		newData[length] = value;</span><br><span class="line">		<span class="keyword">this</span>.data = newData;</span><br><span class="line">		<span class="keyword">this</span>.length = length + <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 从最后一个节点开始自下而上调整堆</span></span><br><span class="line">		adjustUpHeap(<span class="keyword">this</span>.length - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * &#123;@inheritDoc&#125;</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjustDownHeap</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> right = getRightChildIndex(node);<span class="comment">// 右孩子</span></span><br><span class="line">		<span class="keyword">int</span> left = getLeftChildIndex(node);<span class="comment">// 左孩子</span></span><br><span class="line">		<span class="keyword">int</span> max = node;<span class="comment">// 三者最大的节点的索引</span></span><br><span class="line">		<span class="keyword">if</span> (right &lt; length &amp;&amp; data[right] &gt; data[max]) &#123;</span><br><span class="line">			max = right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (left &lt; length &amp;&amp; data[left] &gt; data[max]) &#123;</span><br><span class="line">			max = left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (max != node) &#123;<span class="comment">// 需要调整</span></span><br><span class="line">			swap(node, max);</span><br><span class="line">			adjustDownHeap(max);<span class="comment">// 递归调整与根节点进行交换的节点，保证下层也是堆</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * &#123;@inheritDoc&#125;</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjustUpHeap</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> parent = getParentIndex(node);<span class="comment">// 父节点</span></span><br><span class="line">		<span class="keyword">if</span> (parent &gt;= <span class="number">0</span> &amp;&amp; data[parent] &lt; data[node]) &#123;</span><br><span class="line">			swap(node, parent);</span><br><span class="line">			adjustUpHeap(parent);<span class="comment">// 递归调整与根节点进行交换的节点，保证上层也是堆</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">			data[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Arrays.toString(data));</span><br><span class="line">		Heap heap = <span class="keyword">new</span> MaxHeap(data);</span><br><span class="line">		heap.buildHeap().print();</span><br><span class="line">		heap.remove().print();</span><br><span class="line">		heap.insert((<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>)).print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码使用了继承，首先定义了一个堆的抽象类（Heap），封装了一些堆的公用方法，如：swap/getParentIndex/getRightChildIndex/getLeftChildIndex/print，其中具体的实现跟堆相关的方法通过抽象类由子类来实现，如：buildHeap/remove/insert/adjustHeap。大顶堆（MaxHeap）继承自Heap，实现具体的大顶堆的操作。小顶堆（MinHeap）的代码就不贴了，跟大顶堆相差不大，完整代码可见：<a href="https://github.com/vickyqi/StudyBuddy/tree/master/java/datastructure/src/main/java/com/vicky/datastructure/tree/heap" target="_blank" rel="external">GitHub</a>。<br>下面结合上面的代码分别对堆的四个操作进行简单解释，都比较简单。</p>
<h6 id="构建堆"><strong>构建堆</strong></h6><p>首先构建堆，对于给定一个数组，我们需要将其构建成一个堆的结构，这个过程是一个递归的过程，相当于盖楼，先从最底层开始构建，并逐层往上构建，最终构建成一个完整的堆。<br>所以这里从最后一个节点的父节点开始构建堆，即构建最底层的堆，看图。</p>
<p><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/%E6%9E%84%E5%BB%BA%E5%A0%86.png" alt="构建堆的过程"></p>
<h6 id="移除元素"><strong>移除元素</strong></h6><p>从一个堆的结构中移除元素，一般都是移除堆顶元素，即最大值或者最小值，当我们移除堆顶元素之后，需要用堆的最后一个元素来填补到堆顶元素，然后这个堆的结构已经被破坏，我们需要调整这个堆，使其满足堆的结构。调整堆将在下面说。</p>
<h6 id="插入元素"><strong>插入元素</strong></h6><p>堆中插入元素一般是将其插入到堆的最后一个元素，然后自下而上递归调整堆。</p>
<h6 id="调整堆"><strong>调整堆</strong></h6><p>调整堆的方式有两种：自上而下和自下而上，分别对应移除堆和插入元素。但是两种方式的逻辑是一致的，即递归调整堆，如自上而下则寻找其两个子节点，将三者最大的放到根节点（三者小堆的根，不是整个大堆），然后递归调整移动了的节点（如右节点最大，则将右节点与根节点发生交换，递归调整右节点），最终到达底层，或者中途未发生交换则结束。自下而上原理类似，只是将一个节点与其父节点进行比较。</p>
<p>以上是我个人对堆的了解，如有错误请不宁赐教~</p>
<p>如果想了解更多关于堆的使用案例，可参考：</p>
<ul>
<li>堆排序可具体参考<a href="http://vickyqi.com/2015/08/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%A0%86%E6%8E%92%E5%BA%8F/">排序算法系列——堆排序</a></li>
<li>优先队列可参考<a href="http://blog.csdn.net/vickyway/article/details/49005011" target="_blank" rel="external">JDK并发工具类源码学习系列——介绍</a></li>
</ul>
<h5 id="参考文章"><strong>参考文章</strong></h5><p><a href="https://zh.wikipedia.org/wiki/%E5%A0%86_%28%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%29" target="_blank" rel="external">堆 (数据结构)</a><br><a href="http://dongxicheng.org/structure/heap/" target="_blank" rel="external">数据结构之堆</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>堆（Heap）是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。在队列中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="数据结构" scheme="http://vickyqi.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构" scheme="http://vickyqi.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JDK并发工具类源码学习系列——CopyOnWriteArrayList]]></title>
    <link href="http://vickyqi.com/2015/11/17/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94CopyOnWriteArrayList/"/>
    <id>http://vickyqi.com/2015/11/17/JDK并发工具类源码学习系列——CopyOnWriteArrayList/</id>
    <published>2015-11-17T11:05:00.000Z</published>
    <updated>2015-11-17T06:43:58.000Z</updated>
    <content type="html"><![CDATA[<p><strong>CopyOnWriteArrayList</strong>是ArrayList的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。 这一般需要很大的开销，但是当遍历操作的数量大大超过可变操作的数量时，这种方法可能比其他替代方法更 有效。在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时，它也很有用。“快照”风格的迭代器方法在创建迭代器时使用了对数组状态的引用。此数组在迭代器的生存期内不会更改，因此不可能发生冲突，并且迭代器保证不会抛出 ConcurrentModificationException。创建迭代器以后，迭代器就不会反映列表的添加、移除或者更改。在迭代器上进行的元素更改操作（remove、set 和 add）不受支持。这些方法将抛出 UnsupportedOperationException。 允许使用所有元素，包括 null。 </p>
<p><strong>内存一致性效果</strong>：当存在其他并发 collection 时，将对象放入 CopyOnWriteArrayList 之前的线程中的操作 happen-before 随后通过另一线程从 CopyOnWriteArrayList 中访问或移除该元素的操作。 </p>
<hr>
<p>以上介绍摘自API文档。</p>
<p>根据API对CopyOnWriteArrayList的介绍，其原理以及使用场景已经比较清晰了，下面我们通过源码来分析下。</p>
<h5 id="实现原理"><strong>实现原理</strong></h5><p>API已经说的比较清楚了，由于数组的特殊结构，所以如果想要对数据进行结构性修改，如增加一个元素，删除一个元素，都是很麻烦的，所以无法将对一个数组的结构性修改缩小到一个原子指令范围，不像链表可以通过CAS修改next指针来修改链表。所以CopyOnWriteArrayList通过将任何对底层数组进行结构性修改的操作变成针对一个新的副本的修改，然后用修改后的副本来替换原来的数组，来实现遍历与修改分离，以保证数组高效的访问效率。</p>
<h5 id="常用方法解读"><strong>常用方法解读</strong></h5><p>CopyOnWriteArrayList的重要的几个方法：add(int, E)/add(E)/set(int, E)/remove(int)/iterator()，其中前四个是对CopyOnWriteArrayList的结构进行修改，最后一个是对CopyOnWriteArrayList进行遍历。下面针对源码逐一进行分析。</p>
<h6 id="add(int,_E)和add(E)"><strong>add(int, E)和add(E)</strong></h6><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* Inserts the specified element at the specified position in this list.</span><br><span class="line"> * Shifts the element currently at that position (if any) and any subsequent</span><br><span class="line"> * elements to the right (adds one to their indices).</span><br><span class="line"> *</span><br><span class="line"> * @throws IndexOutOfBoundsException</span><br><span class="line"> *             &#123;@inheritDoc&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> add(<span class="keyword">int</span> <span class="keyword">index</span>, E element) &#123;</span><br><span class="line">	<span class="comment">// 加锁</span></span><br><span class="line">	<span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 读取底层数组对象</span></span><br><span class="line">		Object[] elements = getArray();</span><br><span class="line">		<span class="keyword">int</span> len = elements.length;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">index</span> &gt; len || <span class="keyword">index</span> &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span> + <span class="keyword">index</span> + <span class="string">", Size: "</span> + len);</span><br><span class="line">		Object[] newElements;</span><br><span class="line">		<span class="comment">// 由于数组的长度不可变，所以插入一个元素需要新建一个新的数组以容纳新插入的元素</span></span><br><span class="line">		<span class="comment">// 所以需要将原数组复制到新的数组</span></span><br><span class="line">		<span class="keyword">int</span> numMoved = len - <span class="keyword">index</span>;<span class="comment">// 需要移动的元素的开始位置(要插入位置的下一个位置)</span></span><br><span class="line">		<span class="keyword">if</span> (numMoved == <span class="number">0</span>) <span class="comment">// ==0表示插入的位置是数组的最后一个位置，所以该位置前面的元素原样不动复制到新的数组即可</span></span><br><span class="line">			<span class="comment">// 这里通过复制elements数组生成一个新的数组，注意这里新的数组长度是原数组+1，所以新数组的最后一个元素是NULL</span></span><br><span class="line">			newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 将原数组的0~index-1原样复制到新的数组中，</span></span><br><span class="line">			<span class="comment">// 而index之后的元素对应复制到新数组的index+1之后，即中间空出一个位置用于放置带插入元素</span></span><br><span class="line">			newElements = <span class="keyword">new</span> Object[len + <span class="number">1</span>];</span><br><span class="line">			System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, <span class="keyword">index</span>);</span><br><span class="line">			System.arraycopy(elements, <span class="keyword">index</span>, newElements, <span class="keyword">index</span> + <span class="number">1</span>, numMoved);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将element插入到新的数组</span></span><br><span class="line">		newElements[<span class="keyword">index</span>] = element;</span><br><span class="line">		<span class="comment">// 将更新底层数组的引用，由于array是volatile的，所以对其的修改能够立即被后续线程可见</span></span><br><span class="line">		setArray(newElements);</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 释放锁</span></span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* Appends the specified element to the end of this list.</span><br><span class="line"> *</span><br><span class="line"> * @param e</span><br><span class="line"> *            element to be appended to this list</span><br><span class="line"> * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">// @By Vicky:该方法相当于调用add(array.length, e)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> add(E e) &#123;</span><br><span class="line">	<span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Object[] elements = getArray();</span><br><span class="line">		<span class="keyword">int</span> len = elements.length;</span><br><span class="line">		Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">		newElements[len] = e;</span><br><span class="line">		setArray(newElements);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>add()方法的实现很简单，通过加锁保证线程安全，通过Arrays.copyOf根据原数组复制一个新的数组，将要插入的元素插入到新的数组的对应位置，然后将新的数组赋值给array，通过volatile保证内存可见。</p>
<h6 id="set(int,_E)"><strong>set(int, E)</strong></h6><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Replaces the element at the specified position in this list with the</span><br><span class="line"> * specified element.</span><br><span class="line"> *</span><br><span class="line"> * @throws IndexOutOfBoundsException</span><br><span class="line"> *             &#123;@inheritDoc&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">// @By Vicky:更新指定位置元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span>(<span class="params"><span class="keyword">int</span> index, E element</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 加锁</span></span><br><span class="line">	final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">	<span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Object[] elements = getArray();</span><br><span class="line">		<span class="comment">// 获取需更新的元素</span></span><br><span class="line">		Object oldValue = elements[index];</span><br><span class="line">		<span class="comment">// //</span></span><br><span class="line">		<span class="comment">// 需更新的值不等于原值(注意此处的不等是==，不是equals()，即oldValue和element必须是引用同一个对象才可)</span></span><br><span class="line">		<span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">			<span class="keyword">int</span> len = elements.length;</span><br><span class="line">			<span class="comment">// 复制一个新的数组，并将index更新成新的值，更新引用</span></span><br><span class="line">			Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">			newElements[index] = element;</span><br><span class="line">			setArray(newElements);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">			<span class="comment">// 此处由于更新的值与原值是同一个对象，所以其实可不更新引用</span></span><br><span class="line">			<span class="comment">// 从注释可以看出更新的目的是出于写volatile变量</span></span><br><span class="line">			setArray(elements);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (E) oldValue;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 释放锁</span></span><br><span class="line">		<span class="keyword">lock</span>.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>set()比add()更新简单，只需要复制一个新的数组，然后更新新的数组的指定位置的元素，然后更新引用即可。</p>
<h6 id="remove(int)"><strong>remove(int)</strong></h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">   * Removes the element at the specified position in this list.</span><br><span class="line">    * Shifts any subsequent elements to the left (subtracts one from their</span><br><span class="line">    * indices).  Returns the element that was removed from the list.</span><br><span class="line">    *</span><br><span class="line">    * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span><br><span class="line">    */</span></span><br><span class="line"><span class="comment">// @By Vicky:删除指定位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 加锁</span></span><br><span class="line">	final ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Object[] elements = getArray();</span><br><span class="line">		<span class="keyword">int</span> len = elements.length;</span><br><span class="line">		Object oldValue = elements[index];</span><br><span class="line">		<span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;<span class="comment">// 需要移动的元素的个数</span></span><br><span class="line">		<span class="keyword">if</span> (numMoved == <span class="number">0</span>) <span class="comment">// ==0表示删除的位置是数组的最后一个元素，只需要简单的复制原数组的len-1个元素到新数组即可</span></span><br><span class="line">			setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 将原数组的0-index-1复制到新数组的对应位置</span></span><br><span class="line">			<span class="comment">// 将原数组的index+1之后的元素复制到新数组，丢弃原数组的index位置的元素</span></span><br><span class="line">			Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">			System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">			System.arraycopy(elements, index + <span class="number">1</span>, newElements, index, numMoved);</span><br><span class="line">			setArray(newElements);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (E) oldValue;</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @By Vicky:删除指定元素，而非指定位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 加锁</span></span><br><span class="line">	final ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Object[] elements = getArray();</span><br><span class="line">		<span class="keyword">int</span> len = elements.length;</span><br><span class="line">		<span class="keyword">if</span> (len != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// Copy while searching for element to remove</span></span><br><span class="line">			<span class="comment">// This wins in the normal case of element being present</span></span><br><span class="line">			<span class="keyword">int</span> newlen = len - <span class="number">1</span>;<span class="comment">// 删除之后数组的长度</span></span><br><span class="line">			Object[] newElements = <span class="keyword">new</span> Object[newlen];<span class="comment">// 创建新的数组</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newlen; ++i) &#123;<span class="comment">// 从0-len-1遍历原数组</span></span><br><span class="line">				<span class="keyword">if</span> (eq(o, elements[i])) &#123;<span class="comment">// 如果是待删除元素，则将该元素之后的元素复制到新数组中</span></span><br><span class="line">					<span class="comment">// found one; copy remaining and exit</span></span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; len; ++k)</span><br><span class="line">						newElements[k - <span class="number">1</span>] = elements[k];</span><br><span class="line">					<span class="comment">// 设置新数组</span></span><br><span class="line">					setArray(newElements);</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span></span><br><span class="line">					<span class="comment">// 将该元素插入到新数组</span></span><br><span class="line">					newElements[i] = elements[i];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 确认最后原数组一个元素是否与待删除元素相等，是的话直接将修改引用即可，因为前面已经为新数组赋完值了</span></span><br><span class="line">			<span class="comment">// special handling for last cell</span></span><br><span class="line">			<span class="keyword">if</span> (eq(o, elements[newlen])) &#123;</span><br><span class="line">				setArray(newElements);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 到这里说明数组中没有与待删除元素相等的元素，所以直接返回false，</span></span><br><span class="line">		<span class="comment">// 但是这里并没有写volatile变量，看来set那里也只是写着好玩</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>remove()有两种方式，根据指定位置删除以及指定元素删除两种方式。</p>
<h6 id="iterator()"><strong>iterator()</strong></h6><p>这里的iterator()只是很简单的迭代器，内部将remove/set/add三个修改操作进行了限制，因为这里的迭代器不能修改集合，代码就不细看了。注意到iterator并没有加锁，因为iterator所访问的数组是不会变的，就算有其他线程对集合进行修改。</p>
<h5 id="使用场景"><strong>使用场景</strong></h5><p>CopyOnWriteArrayList适合读多写少的场景。通过空间换时间的方式来提高读的效率并保证写的安全性。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>CopyOnWriteArrayList</strong>是ArrayList的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。 这一般需要很大的开销，但是当遍历操作的数量大大超过可变操作的数量时，这种]]>
    </summary>
    
      <category term="JDK" scheme="http://vickyqi.com/tags/JDK/"/>
    
      <category term="JUC" scheme="http://vickyqi.com/tags/JUC/"/>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="JDK源码" scheme="http://vickyqi.com/categories/Java/JDK%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PythonOS库练习——模拟linux文件管理命令]]></title>
    <link href="http://vickyqi.com/2015/11/17/PythonOS%E5%BA%93%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9Flinux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    <id>http://vickyqi.com/2015/11/17/PythonOS库练习——模拟linux文件管理命令/</id>
    <published>2015-11-17T04:52:47.000Z</published>
    <updated>2015-11-17T03:54:28.000Z</updated>
    <content type="html"><![CDATA[<p>最近对Python大有兴趣，由于将官网文档看了一遍，但是看完只是简单的了解了Python的语法，而且还只是最基础的语法，所以后续除了了解Python的高级功能外（例外并发机制，锁机制，IO机制等），另一个重要要学习的就是Python的基本类库，如os/sys/datetime等。</p>
<p>本篇文章就是针对Python OS标准库的练习，OS库的功能主要是针对操作系统的文件管理，所以练习无外乎就是针对文件进行操作，如果只是普通的创建个文件/删除个文件/读写下文件/etc，感觉没啥意思，所以就想自己模拟Linux下的文件管理命令来实现一个Python版的，但是在写的过程中发现真的不简单，尤其对于我这样一个初学者来说，不过还是希望能够坚持下去~好了，废话不多说，能写多少写多少吧！</p>
<h5 id="实现框架"><strong>实现框架</strong></h5><p>首先介绍下整体的框架，框架通过FileManage类进入文件管理器；Context类用于定义上下文，上下文主要用来保存当前工作目录，以后可能还有用户信息等；Command类是一个父类，用于定义通用命令角色；LLCommand类继承自Command类，是一个具体的命令类，LLCommand是用于处理ll命令。目前整体架构还是很简单的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">'''</span><br><span class="line">Created on 2015年11月16日</span><br><span class="line"></span><br><span class="line">@author: Vicky</span><br><span class="line">'''</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">__dir = <span class="string">""</span></span><br><span class="line">    </span><br><span class="line"><span class="string">"""模拟资源管理器"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileManage</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span><br><span class="line">    classdocs</span><br><span class="line">    '''</span></span><br><span class="line">    __tab__ = <span class="string">"    "</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, _dir)</span>:</span></span><br><span class="line">        <span class="string">'''</span><br><span class="line">        Constructor</span><br><span class="line">        '''</span></span><br><span class="line">        self._dir = _dir</span><br><span class="line">        self._context = Context(self._dir)</span><br><span class="line">        os.chdir(self._dir)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_parse</span><span class="params">(self, inp)</span>:</span></span><br><span class="line">        <span class="string">"""解析用户输入"""</span></span><br><span class="line">        _cmd, _params, _vals = (<span class="string">""</span>, [], [])</span><br><span class="line">        </span><br><span class="line">        cmds = inp.split(<span class="string">" "</span>)</span><br><span class="line">        _len = len(cmds)</span><br><span class="line">        _cmd = cmds[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> _len &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, _len):</span><br><span class="line">                <span class="keyword">if</span> cmds[i].startswith(<span class="string">"-"</span>):</span><br><span class="line">                    <span class="keyword">for</span> s <span class="keyword">in</span> cmds[i][<span class="number">1</span>:]:</span><br><span class="line">                        _params.append(s)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    _vals.extend(cmds[i:])</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> (_cmd, _params, _vals)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__main__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">global</span> __dir</span><br><span class="line">            inp = input(<span class="string">"fe[%s]:"</span> % self._context._dir)</span><br><span class="line">            res = self._parse(inp)</span><br><span class="line">            <span class="keyword">if</span> res[<span class="number">0</span>] == <span class="string">"ll"</span>:</span><br><span class="line">                LLCommand(self._context, res[<span class="number">0</span>], res[<span class="number">1</span>], res[<span class="number">2</span>]).execute()</span><br><span class="line">            <span class="keyword">elif</span> res[<span class="number">0</span>] == <span class="string">"cd"</span>:</span><br><span class="line">                print(res)</span><br><span class="line">            <span class="keyword">elif</span> res[<span class="number">0</span>] == <span class="string">"cp"</span>:</span><br><span class="line">                print(res)</span><br><span class="line">            <span class="keyword">elif</span> res[<span class="number">0</span>] == <span class="string">"exit"</span>:  <span class="comment"># 退出</span></span><br><span class="line">                print(<span class="string">"logout..."</span>)</span><br><span class="line">                sys.exit()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"-fe: %s: command not found"</span> % res[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""上下文，保存信息，如当前工作空间"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, _dir)</span>:</span></span><br><span class="line">        self._dir = _dir  <span class="comment"># 当前用户目录</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span><span class="params">(object)</span>:</span></span><br><span class="line">        <span class="string">"""命令"""</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, context, cmd=None, options=None, vals=None)</span>:</span></span><br><span class="line">            <span class="string">"""</span><br><span class="line">            @param cmd: 命令</span><br><span class="line">            @param options: 选项(-a)</span><br><span class="line">            @param vals: 参数</span><br><span class="line">            @param context:    上下文</span><br><span class="line">            """</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> context:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">"context is necessary"</span>)</span><br><span class="line">            self._cmd = cmd</span><br><span class="line">            self._options = options</span><br><span class="line">            self._vals = vals</span><br><span class="line">            self._context = context</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">setCmd</span><span class="params">(self, cmd)</span>:</span></span><br><span class="line">            self._cmd = cmd</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">setOptions</span><span class="params">(self, options)</span>:</span></span><br><span class="line">            self._options = options</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">setVals</span><span class="params">(self, vals)</span>:</span></span><br><span class="line">            self._vals = vals</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeToStr</span><span class="params">(timestamp, _format = <span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span>:</span></span><br><span class="line">    <span class="string">"""将时间戳转成字符串"""</span></span><br><span class="line">    _time = datetime.datetime.fromtimestamp(timestamp)</span><br><span class="line">    <span class="keyword">return</span> datetime.date.strftime(_time, _format)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    fm = FileManage(<span class="string">"E:/Work/Python/files"</span>)</span><br><span class="line">    fm.__main__()</span><br></pre></td></tr></table></figure>
<h5 id="ll命令实现"><strong>ll命令实现</strong></h5><p>直接上代码吧，实现没有什么难度，只是简单的调用os函数而已。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LLCommand</span><span class="params">(Command)</span>:</span></span><br><span class="line">    <span class="string">"""继承自Command，处理ll命令"""</span></span><br><span class="line">    __tab__ = <span class="string">"\t"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""执行命令"""</span></span><br><span class="line">        _dirs = self._vals <span class="keyword">if</span> self._vals <span class="keyword">else</span> []</span><br><span class="line">        <span class="keyword">if</span> len(_dirs) == <span class="number">0</span>:</span><br><span class="line">            _dirs.append(self._context._dir)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环列出目录下的文件</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> _dirs:</span><br><span class="line">            self.__none(d)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__none</span><span class="params">(self, _dir)</span>:</span></span><br><span class="line">        <span class="string">"""递归列出子目录"""</span></span><br><span class="line">        _recursion = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">"r"</span> <span class="keyword">in</span> self._options:</span><br><span class="line">            _recursion = <span class="keyword">True</span></span><br><span class="line">        files = []</span><br><span class="line">        total = self._list(_dir, files, <span class="string">""</span>, _recursion)</span><br><span class="line">        print(<span class="string">"total files:%s"</span> % total)</span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">            print(<span class="string">"&#123;0:7d&#125; &#123;1:19s&#125; &#123;2:s&#125;"</span>.format(*f))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_list</span><span class="params">(self, _dir, files, _tab=<span class="string">""</span>, recursion=False)</span>:</span></span><br><span class="line">        old_dir = os.getcwd(); <span class="comment"># 保存当前目录</span></span><br><span class="line">        os.chdir(_dir) <span class="comment">#进入需要遍历的目录</span></span><br><span class="line">        _total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir():</span><br><span class="line">            _total = _total + <span class="number">1</span></span><br><span class="line">            stat = os.stat(f)</span><br><span class="line">            _size = stat.st_size</span><br><span class="line">            _time = timeToStr(int(stat.st_mtime))</span><br><span class="line">            files.append((_size, _time, f))</span><br><span class="line">            <span class="keyword">if</span> recursion <span class="keyword">and</span> os.path.isdir(f):</span><br><span class="line">                _total = _total + self._list(f, _tab + self.__tab__, recursion, files)</span><br><span class="line">        </span><br><span class="line">        os.chdir(old_dir)  <span class="comment">#进入原来的目录</span></span><br><span class="line">        <span class="keyword">return</span> _total</span><br></pre></td></tr></table></figure>
<p>写下这篇文章主要是鼓励自己学下去，当然如果有人看见了，而且有好的建议，那么就请不宁赐教~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近对Python大有兴趣，由于将官网文档看了一遍，但是看完只是简单的了解了Python的语法，而且还只是最基础的语法，所以后续除了了解Python的高级功能外（例外并发机制，锁机制，IO机制等），另一个重要要学习的就是Python的基本类库，如os/sys/datetim]]>
    </summary>
    
      <category term="FM项目" scheme="http://vickyqi.com/tags/FM%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="Python" scheme="http://vickyqi.com/tags/Python/"/>
    
      <category term="Python" scheme="http://vickyqi.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JDK并发工具类源码学习系列——ConcurrentSkipListMap(续)]]></title>
    <link href="http://vickyqi.com/2015/11/13/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentSkipListMap(%E7%BB%AD)/"/>
    <id>http://vickyqi.com/2015/11/13/JDK并发工具类源码学习系列——ConcurrentSkipListMap(续)/</id>
    <published>2015-11-13T12:05:00.000Z</published>
    <updated>2015-11-13T06:13:02.000Z</updated>
    <content type="html"><![CDATA[<p>ConcurrentSkipListMap在JDK并发工具类使用范围不是很广，它是针对某一特殊需求而设计的——支持排序，同时支持搜索目标返回最接近匹配项的导航方法。一般情况下开发者很少会使用到该类，但是如果你有如上的特殊需求，那么ConcurrentSkipListMap将是一个很好地解决方案。 本文通过对JDK的ConcurrentSkipListMap的代码详细分析，深入分析其实现原理。<br><a id="more"></a><br><a href="http://vickyqi.com/2015/11/13/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentSkipListMap/">上一篇介绍了ConcurrentSkipListMap的原理以及对put()方法进行了解析</a>，本篇继续接着上一篇往下看。</p>
<h5 id="常用方法解读"><strong>常用方法解读</strong></h5><p>上一篇说到put()的最后一句：<code>insertIndex(z, level);</code>这一句是将一个新节点插入到跳表结构中，下面看看是如何实现的。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> insertIndex(Node&lt;K,V&gt; z, <span class="built_in">int</span> level) &#123;</span><br><span class="line"> HeadIndex&lt;K,V&gt; h = head;<span class="comment">// 读取跳表的头</span></span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">max</span> = h.level;<span class="comment">// 跳表的最高层级</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (level &lt;= <span class="built_in">max</span>) &#123;<span class="comment">// level &lt;= max则需要将自最底层到level层的每一层插入该节点</span></span><br><span class="line">    	<span class="comment">// 此处从最底层开始往上创建跳表节点，每个节点的down指向下一层的节点，</span></span><br><span class="line">    	<span class="comment">// 最后的idx为level层的节点，通过down形成一个链表结构</span></span><br><span class="line">        Index&lt;K,V&gt; idx = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">            idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 将该节点插入跳表</span></span><br><span class="line">        addIndex(idx, h, level);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// Add a new level(新增加一层)</span></span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * To reduce interference by other threads checking for</span><br><span class="line">         * empty levels in tryReduceLevel, new levels are added</span><br><span class="line">         * with initialized right pointers. Which in turn requires</span><br><span class="line">         * keeping levels in an array to access them while</span><br><span class="line">         * creating new head index nodes from the opposite</span><br><span class="line">         * direction.</span><br><span class="line">         */</span></span><br><span class="line">        level = <span class="built_in">max</span> + <span class="number">1</span>;<span class="comment">// 最大值+1</span></span><br><span class="line">Index&lt;K,V&gt;[] idxs = (Index&lt;K,V&gt;[])<span class="keyword">new</span> Index[level+<span class="number">1</span>];<span class="comment">//一个数组</span></span><br><span class="line">        Index&lt;K,V&gt; idx = <span class="keyword">null</span>;<span class="comment">// 一个新的跳表头结点</span></span><br><span class="line">        <span class="comment">// 该数组是一个从level层开始一直向下引用的垂直链表，用于方便获取某层的节点</span></span><br><span class="line">        <span class="comment">// 用处在下面if (level &lt;= oldLevel)出可以看出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">            idxs[i] = idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        HeadIndex&lt;K,V&gt; oldh;<span class="comment">//旧头结点</span></span><br><span class="line">        <span class="built_in">int</span> k;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            oldh = head;</span><br><span class="line">            <span class="built_in">int</span> oldLevel = oldh.level;</span><br><span class="line">            <span class="comment">// 此处如果发生level &lt;= oldLevel说明其他线程已经增加了这一层，那么当前线程要插入的层已经不&gt;跳表的最大层了</span></span><br><span class="line">            <span class="comment">// 那直接从数组中渠道level层的节点插入到跳表即可，插入方式同上面</span></span><br><span class="line">            <span class="keyword">if</span> (level &lt;= oldLevel) &#123; <span class="comment">// lost race to add level</span></span><br><span class="line">                k = level;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            HeadIndex&lt;K,V&gt; newh = oldh;</span><br><span class="line">            Node&lt;K,V&gt; oldbase = oldh.node;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = oldLevel+<span class="number">1</span>; j &lt;= level; ++j)</span><br><span class="line">            	<span class="comment">// 循环创建头结点，直到level层，其实从level = max + 1;这里可以看出也就最多增加一层</span></span><br><span class="line">            	<span class="comment">// 新的头结点node和下一层的node一样，down引用下一层，right是我们新建的节点(通过idxs数组直接访问第N层的节点)</span></span><br><span class="line">                newh = <span class="keyword">new</span> HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);</span><br><span class="line">            <span class="comment">// 用新的头结点取代旧的头结点，使用CAS避免并发安全问题</span></span><br><span class="line">            <span class="keyword">if</span> (casHead(oldh, newh)) &#123;</span><br><span class="line">            	<span class="comment">// 此处k = oldLevel，直接导致下面插入节点的时候从oldLevel开始插入，</span></span><br><span class="line">            	<span class="comment">// 因为oldLevel之上是新插入的层级，每层都是一个接节点，所以已经是OK的了</span></span><br><span class="line">                k = oldLevel;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入节点</span></span><br><span class="line">        addIndex(idxs[k], oldh, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> addIndex(Index&lt;K,V&gt; idx, HeadIndex&lt;K,V&gt; h, <span class="built_in">int</span> indexLevel) &#123;</span><br><span class="line"><span class="comment">// Track next level to insert in case of retries</span></span><br><span class="line">    <span class="built_in">int</span> insertionLevel = indexLevel;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; <span class="variable">key</span> = comparable(idx.node.<span class="variable">key</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">key</span> == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Similar to findPredecessor, but adding index nodes along</span></span><br><span class="line">    <span class="comment">// path to key.</span></span><br><span class="line">    <span class="comment">// 此处死循环是在发生不一致时进行重试</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">// 此处从跳表头部开始找到该插入该节点的位置，类似findPredecessor</span></span><br><span class="line">        <span class="built_in">int</span> j = h.level;</span><br><span class="line">        Index&lt;K,V&gt; q = h;</span><br><span class="line">        Index&lt;K,V&gt; r = q.right;</span><br><span class="line">        Index&lt;K,V&gt; t = idx;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        	<span class="comment">// 在当前层级查找适合插入节点的位置</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                <span class="comment">// compare before deletion check avoids needing recheck</span></span><br><span class="line">                <span class="built_in">int</span> c = <span class="variable">key</span>.compareTo(n.<span class="variable">key</span>);</span><br><span class="line">                <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;<span class="comment">// 如果r已被删除，则移除r</span></span><br><span class="line">                    <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    r = q.right;<span class="comment">//r指向下一层节点，继续</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;<span class="comment">//如果当前访问的节点key&lt;需插入节点的key，则继续右移</span></span><br><span class="line">                    q = r;</span><br><span class="line">                    r = r.right;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 到达此处有两种情况：</span></span><br><span class="line">            <span class="comment">//	1.已访问到该层链表的最右边</span></span><br><span class="line">            <span class="comment">//	2.当前访问的节点(r)的key&gt;=需插入节点的key，则继续右移</span></span><br><span class="line">            <span class="keyword">if</span> (j == insertionLevel) &#123;<span class="comment">// 如果找到的层级==要插入的层级，那么就在该层级插入该节点</span></span><br><span class="line">                <span class="comment">// Don't insert index if node already deleted</span></span><br><span class="line">                <span class="keyword">if</span> (t.indexesDeletedNode()) &#123;<span class="comment">// 判断要插入的节点是否已经被删除，此处考虑的是多线程情况下可能发生的并发问题</span></span><br><span class="line">                    findNode(<span class="variable">key</span>); <span class="comment">// cleans up</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将t插入到q的右边，替代之前的r，通过CAS确保并发安全</span></span><br><span class="line">                <span class="keyword">if</span> (!q.link(r, t))</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// restart</span></span><br><span class="line">                <span class="keyword">if</span> (--insertionLevel == <span class="number">0</span>) &#123;<span class="comment">// 插入下一层，直到0为止</span></span><br><span class="line">                    <span class="comment">// need final deletion check before return</span></span><br><span class="line">                    <span class="keyword">if</span> (t.indexesDeletedNode())</span><br><span class="line">                        findNode(<span class="variable">key</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将j-1有两个目的：</span></span><br><span class="line">            <span class="comment">// 	1.如果在-1之前j == insertionLevel，即查找已经定位到要插入节点的那一层，则insertionLevel会-1，所以j也要跟着-1</span></span><br><span class="line">            <span class="comment">//	2.在-1之前j != insertionLevel，说明还未查找到要插入的那一层，需要继续往下查找</span></span><br><span class="line">            <span class="comment">//此处需要同时满足两个条件才可向下一层查找：</span></span><br><span class="line">            <span class="comment">//	1.-1之后的j&gt;=insertionLevel(此处可能是还未找到要插入的层，也可能已经找到了)</span></span><br><span class="line">            <span class="comment">//	2.j &lt; indexLevel，针对第一点还未找到要插入的层，如果j&gt;=indeLevel说明该层不需要插入节点</span></span><br><span class="line">            <span class="keyword">if</span> (--j &gt;= insertionLevel &amp;&amp; j &lt; indexLevel)</span><br><span class="line">            	<span class="comment">// t=t.down即将t往下移动一层，此处的t是在每一层要插入的节点，其实也就是要插入节点的下一层</span></span><br><span class="line">                t = t.down;</span><br><span class="line">            <span class="comment">// 到这里存在两种情况：</span></span><br><span class="line">            <span class="comment">//	1.上层已经插入了</span></span><br><span class="line">            <span class="comment">//	2.还未找到要插入的层(第一个要插入的层，也就是新插入节点被分配到的层级)</span></span><br><span class="line">            <span class="comment">// 不管上面如何处理，到这里都需要往下遍历了</span></span><br><span class="line">            q = q.down;</span><br><span class="line">            r = q.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>真的挺复杂的逻辑，本身跳表的插入就有点复杂，现在还需要考虑并发问题，就更多复杂难懂了。代码中加入了大量的注释，希望能够说明白吧，其实自己看着也挺蒙，明白原理就行，哈哈。<br>put()总算说完了，下面看看get()吧。</p>
<h6 id="get(Object)"><strong>get(Object)</strong></h6><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> V doGet(<span class="keyword">Object</span> okey) &#123;</span><br><span class="line">Comparable&lt;? <span class="keyword">super</span> K&gt; <span class="variable">key</span> = comparable(okey);</span><br><span class="line">    Node&lt;K,V&gt; bound = <span class="keyword">null</span>;</span><br><span class="line">    Index&lt;K,V&gt; q = head;</span><br><span class="line">    Index&lt;K,V&gt; r = q.right;</span><br><span class="line">    Node&lt;K,V&gt; n;</span><br><span class="line">    K k;</span><br><span class="line">    <span class="built_in">int</span> c;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Index&lt;K,V&gt; d;</span><br><span class="line">        <span class="comment">// Traverse rights</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; (n = r.node) != bound &amp;&amp; (k = n.<span class="variable">key</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((c = <span class="variable">key</span>.compareTo(k)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                q = r;</span><br><span class="line">                r = r.right;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">Object</span> v = n.value;</span><br><span class="line">                <span class="keyword">return</span> (v != <span class="keyword">null</span>)? (V)v : getUsingFindNode(<span class="variable">key</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">            	<span class="comment">// 这里当前查找的节点(n)key&gt;指定key说明已经跑过头了，此时需要往下找了</span></span><br><span class="line">            	<span class="comment">// bound在这里的作用是在下一层进行查找时如果找到了这一层的bound节点则说明又需要往下找了</span></span><br><span class="line">            	<span class="comment">// 这里如果理解了跳表的结构就好理解了，因为有的节点并不是每层都有</span></span><br><span class="line">                bound = n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Traverse down</span></span><br><span class="line">        <span class="keyword">if</span> ((d = q.down) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            q = d;</span><br><span class="line">            r = d.right;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果执行到这里，说明已经找到最底层了，但是依旧没找到该节点，所以要找的节点如果存在那么就是在最底层的靠右端</span></span><br><span class="line">    <span class="comment">// 所以还需要往右查找</span></span><br><span class="line">    <span class="comment">// Traverse nexts</span></span><br><span class="line">    <span class="keyword">for</span> (n = q.node.next;  n != <span class="keyword">null</span>; n = n.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((k = n.<span class="variable">key</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((c = <span class="variable">key</span>.compareTo(k)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">Object</span> v = n.value;</span><br><span class="line">                <span class="keyword">return</span> (v != <span class="keyword">null</span>)? (V)v : getUsingFindNode(<span class="variable">key</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> V getUsingFindNode(Comparable&lt;? <span class="keyword">super</span> K&gt; <span class="variable">key</span>) &#123;</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">     * Loop needed here and elsewhere in case value field goes</span><br><span class="line">     * null just as it is about to be returned, in which case we</span><br><span class="line">     * lost a race with a deletion, so must retry.</span><br><span class="line">     */</span></span><br><span class="line">	<span class="comment">// 该方法循环查找key的节点，如果找不到key对应的节点，则直接返回null</span></span><br><span class="line">	<span class="comment">// 如果找到对应的节点，但是value==null，则重试(原因尚不清楚，注释也不是太明白)</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">// findNode返回的n如果不为null，那么就已经判断过n的value是否为null了，</span></span><br><span class="line">    	<span class="comment">// 下面再次判断可能是为了避免其他线程在这段时间内删掉了这个节点</span></span><br><span class="line">    	<span class="comment">// 不过既然被其他线程删掉了为什么还要去找呢，直接返回null不就好了，是在不明白，难道是为了再去删掉这个节点？</span></span><br><span class="line">        Node&lt;K,V&gt; n = findNode(<span class="variable">key</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">Object</span> v = n.value;</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (V)v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* @By Vicky:此方法用于根据key查找对应的节点</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;K,V&gt; findNode(Comparable&lt;? <span class="keyword">super</span> K&gt; <span class="variable">key</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">// findPredecessor找到key的左边的节点，之前有介绍</span></span><br><span class="line">        Node&lt;K,V&gt; b = findPredecessor(<span class="variable">key</span>);</span><br><span class="line">        <span class="comment">// n是b的next节点，正确情况下n的key==key</span></span><br><span class="line">        Node&lt;K,V&gt; n = b.next;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)	<span class="comment">// n==null说明b是最右边的节点，所以其实未找到key对应的节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">Object</span> v = n.value;</span><br><span class="line">            <span class="comment">// n被删除了，helpDelete掉</span></span><br><span class="line">            <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;                <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// b被打上了delete标记，等待其他线程将其删除</span></span><br><span class="line">            <span class="keyword">if</span> (v == n || b.value == <span class="keyword">null</span>)  <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">int</span> c = <span class="variable">key</span>.compareTo(n.<span class="variable">key</span>);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)<span class="comment">// 即n就是要查找的节点</span></span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)<span class="comment">// b的key小于指定key，但是b的下一个节点的key大于指定key，说明没指定key对应的节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            b = n;<span class="comment">// 继续往右走</span></span><br><span class="line">            n = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get()过程涉及三个方法，都是查找，相对put()来说，get简单多了，就是按跳表的结构查找，只是需要判断节点是否被删除，同时还需要帮忙将被删除的节点移除跳表结构。代码中的注释应该比较清楚了，就不再细述了，下面看remove()方法。</p>
<h6 id="remove(Object)"><strong>remove(Object)</strong></h6><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V remove(<span class="keyword">Object</span> <span class="variable">key</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> doRemove(<span class="variable">key</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* @By Vicky:删除的逻辑和查找类似，将找到的节点的value置为null，同时将其打上删除标记 </span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">final</span> V doRemove(<span class="keyword">Object</span> okey, <span class="keyword">Object</span> value) &#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; <span class="variable">key</span> = comparable(okey);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">// findPredecessor找到最底层的前一个节点(这里的节点是链表的节点，而非跳表的节点)</span></span><br><span class="line">        Node&lt;K,V&gt; b = findPredecessor(<span class="variable">key</span>);</span><br><span class="line">        Node&lt;K,V&gt; n = b.next;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        	<span class="comment">// b.next==null说明未找到响应的节点，直接返回null</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                    <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">Object</span> v = n.value;</span><br><span class="line">            <span class="comment">// 下面分别判断n和b是否已被删除</span></span><br><span class="line">            <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;                    <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v == n || b.value == <span class="keyword">null</span>)      <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">int</span> c = <span class="variable">key</span>.compareTo(n.<span class="variable">key</span>);</span><br><span class="line">            <span class="comment">// c&lt;0说明findPredecessor找到的节点的下一个节点的key&lt;要删除的key</span></span><br><span class="line">            <span class="comment">// 正确情况下(无并发情况下)c应该是&gt;=0才对</span></span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// c&gt;0继续查找</span></span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                b = n;</span><br><span class="line">                n = f;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// value!=null则说明需要待删除的节点的值和指定的值一样才可删除</span></span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !value.equals(v))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 将节点的value置为null即表示删除</span></span><br><span class="line">            <span class="keyword">if</span> (!n.casValue(v, <span class="keyword">null</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 同时为n添加删除标记</span></span><br><span class="line">            <span class="keyword">if</span> (!n.appendMarker(f) || !b.casNext(n, f))</span><br><span class="line">            	<span class="comment">// 这一步其实就是为了触发删除节点</span></span><br><span class="line">                findNode(<span class="variable">key</span>);                  <span class="comment">// Retry via findNode</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">// 触发删除节点，同时如果最高层的节点被删完了则降一层</span></span><br><span class="line">                findPredecessor(<span class="variable">key</span>);           <span class="comment">// Clean index</span></span><br><span class="line">                <span class="keyword">if</span> (head.right == <span class="keyword">null</span>)</span><br><span class="line">                    tryReduceLevel();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (V)v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>remove()和get()差不多，毕竟删除节点的第一步就是找到这个节点，代码中添加了注释，这里不再细述。</p>
<p>看完了三个重要方法，说实话虽然每个方法中的每行代码都可以理解，但是想要理解为什么这么做还是很难的，毕竟代码是死的。就比如说remove和get，remove中也要查找节点，但是remove是调用findPredecessor()来直接查找最底层链表的前继节点，而get是自己按照跳表的结构进行查找，为什么呢？还有一点，所有的跳表节点中引用的node(链表节点)都是一样的，即如果第2层跳表引用一个node(key=4)和第1层引用的node(key=4)其实是同一个引用，而且同最底层的链表的node也是同一个，所以如果找到最上层的那个节点，不就是相当于找到最底层的那个节点了吗？为什么非得找最底层呢？<br>这里可以给出一个答案，那就是findPredecessor()会将已经被删除的跳表的节点从跳表结构中移除，因为删除节点只是将value置为null，顺便加个删除标记，但是这些节点还挂在跳表中，所以需要人为的触发findPredecessor()去一个个删除，也许这就是目的吧。</p>
<p>这三个方法都没有加锁，使用了CAS进行更新，同时修改结构的时候都是控制在一个CAS操作中完成，例如put()方法在将一个节点插入到链表时，是先创建一个新的节点，这个节点的next指向要插入的位置的下一个节点，这步操作不会影响整体的结构，所以是安全的，然后将要插入位置的前一个节点的next原子性的更新成新的节点，所以也不会影响到其他线程，而remove则只是将节点的value值修改为null，以及原子的更新节点的next，所以CAS+volatile就是JDKconcurrent包下的并发控制的实现原理。</p>
<h5 id="使用场景"><strong>使用场景</strong></h5><p>ConcurrentSkipListMap使用跳表结构来保存链表的顺序，解决了在有序链表中快速查找的问题，所以ConcurrentSkipListMap适合在需要链表的高效更新效率(删除/插入)以及还要保证一定的随机访问效率(查找/更新)的场景下使用。</p>
<h5 id="参考文章"><strong>参考文章</strong></h5><p><a href="http://kenby.iteye.com/blog/1187303" target="_blank" rel="external">SkipList 跳表</a><br><a href="http://blog.csdn.net/guangcigeyun/article/details/8278349" target="_blank" rel="external">Java多线程（四）之ConcurrentSkipListMap深入分析</a><br><a href="http://www.cnblogs.com/skywang12345/p/3498556.html" target="_blank" rel="external">Java多线程系列–“JUC集合”05之 ConcurrentSkipListMap</a></p>
<hr>
<p>以上就是本篇的全部内容，如有错误之处，还望大家指出，谢谢~~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ConcurrentSkipListMap在JDK并发工具类使用范围不是很广，它是针对某一特殊需求而设计的——支持排序，同时支持搜索目标返回最接近匹配项的导航方法。一般情况下开发者很少会使用到该类，但是如果你有如上的特殊需求，那么ConcurrentSkipListMap将是一个很好地解决方案。 本文通过对JDK的ConcurrentSkipListMap的代码详细分析，深入分析其实现原理。<br>]]>
    
    </summary>
    
      <category term="JDK" scheme="http://vickyqi.com/tags/JDK/"/>
    
      <category term="JUC" scheme="http://vickyqi.com/tags/JUC/"/>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="JDK源码" scheme="http://vickyqi.com/categories/Java/JDK%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为Hexo博客文章添加关键字]]></title>
    <link href="http://vickyqi.com/2015/11/10/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://vickyqi.com/2015/11/10/为Hexo博客文章添加关键字/</id>
    <published>2015-11-10T09:12:00.000Z</published>
    <updated>2015-11-10T09:14:08.000Z</updated>
    <content type="html"><![CDATA[<p>本文章是为Hexo博客的next主题的文章增加关键字的设定，默认next主题的文章关键字取文章的标签，所以如果想要设置很全的关键字，肯定会造成自己的标签页的标签过多，看着过于杂乱，所以就想将文章的关键字与标签分开，下面做简单的修改即可达到此目的。<br><a id="more"></a></p>
<p>本文章是为Hexo博客的next主题的文章增加关键字的设定，默认next主题的文章关键字取文章的标签，所以如果想要设置很全的关键字，肯定会造成自己的标签页的标签过多，看着过于杂乱，所以就想将文章的关键字与标签分开，下面做简单的修改即可达到此目的。</p>
<p>修改文件：themes\next\layout_partials\head.swig<br>修改内容：35行左右，将原来的设置ketwords的代码覆盖即可</p>
<figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template_tag">&#123;% <span class="keyword">if</span> page.keywords and page.keywords.length %&#125;</span><span class="xml"></span><br><span class="line">  <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"keywords"</span> <span class="attribute">content</span>=<span class="value">"</span></span></span><span class="template_tag">&#123;% <span class="keyword">for</span> key <span class="keyword">in</span> page.keywords %&#125;</span><span class="xml"><span class="tag"><span class="value"></span></span></span><span class="variable">&#123;&#123; key &#125;&#125;</span><span class="xml"><span class="tag"><span class="value">,</span></span></span><span class="template_tag">&#123;% <span class="keyword">endfor</span> %&#125;</span><span class="xml"><span class="tag"><span class="value">"</span> /&gt;</span></span><br><span class="line"></span><span class="template_tag">&#123;% <span class="keyword">elif</span> page.tags and page.tags.length %&#125;</span><span class="xml"></span><br><span class="line">  <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"keywords"</span> <span class="attribute">content</span>=<span class="value">"</span></span></span><span class="template_tag">&#123;% <span class="keyword">for</span> tag <span class="keyword">in</span> page.tags %&#125;</span><span class="xml"><span class="tag"><span class="value"></span></span></span><span class="variable">&#123;&#123; tag.name &#125;&#125;</span><span class="xml"><span class="tag"><span class="value">,</span></span></span><span class="template_tag">&#123;% <span class="keyword">endfor</span> %&#125;</span><span class="xml"><span class="tag"><span class="value">"</span> /&gt;</span></span><br><span class="line"></span><span class="template_tag">&#123;% <span class="keyword">elif</span> theme.keywords %&#125;</span><span class="xml"></span><br><span class="line">  <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"keywords"</span> <span class="attribute">content</span>=<span class="value">"</span></span></span><span class="variable">&#123;&#123; theme.keywords &#125;&#125;</span><span class="xml"><span class="tag"><span class="value">"</span> /&gt;</span></span><br><span class="line"></span><span class="template_tag">&#123;% <span class="keyword">endif</span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure>
<hr>
<p>原创文章，转载请注明出处，多谢~~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文章是为Hexo博客的next主题的文章增加关键字的设定，默认next主题的文章关键字取文章的标签，所以如果想要设置很全的关键字，肯定会造成自己的标签页的标签过多，看着过于杂乱，所以就想将文章的关键字与标签分开，下面做简单的修改即可达到此目的。<br>]]>
    
    </summary>
    
      <category term="hexo" scheme="http://vickyqi.com/tags/hexo/"/>
    
      <category term="博客" scheme="http://vickyqi.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="博客" scheme="http://vickyqi.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[坑爹的Spring数据源——自动提交事务]]></title>
    <link href="http://vickyqi.com/2015/11/10/%E5%9D%91%E7%88%B9%E7%9A%84Spring%E6%95%B0%E6%8D%AE%E6%BA%90%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1/"/>
    <id>http://vickyqi.com/2015/11/10/坑爹的Spring数据源——自动提交事务/</id>
    <published>2015-11-10T07:56:00.000Z</published>
    <updated>2015-11-10T08:18:22.000Z</updated>
    <content type="html"><![CDATA[<p>记一次数据源的自动提交事务带来的烦恼，并通过分析找到JBoss JNDI数据源默认自动提交事务的解决方案<br><a id="more"></a></p>
<h4 id="问题描述"><strong>问题描述</strong></h4><p>项目中涉及充值、扣费逻辑，由于习惯，所以所有的业务逻辑都是通过Mysql存储过程来控制的，所以很自然的将Mysql设置为手动提交(全局的)，然后存储过程中根据返回码决定是提交还是回滚。但是今天出现一个存储过程返回错误码，但是部分事务提交了，研究了半天，发现并没有任务问题，手动调用存储过程是返回错误码，但是不会部分提交事务。于是决定找下问题，不找不知道，一找吓一跳。</p>
<p><strong>（先说明下，项目未使用Spring的事务管理，而是通过存储过程手动控制事务，所以此处与Spring的事务管理无任何关系。）</strong></p>
<p>由于经过测试排除了数据库层面的问题，那么问题只能出现在程序层了。</p>
<h4 id="问题发现"><strong>问题发现</strong></h4><p>项目使用的Spring配置的JBoss的JNDI数据源，JBoss也比较老（是很老），通过使用Spring执行select @@autocommit;发现autocommit竟然是1（自动提交事务），但是明明已经在数据库层将autocommit设置为0（手动提交事务）了，很显然Connection中主动设置了当前会话的autocommit。</p>
<h4 id="问题深究"><strong>问题深究</strong></h4><p>由于Connection来自DataSource，而Spring中对Connection并未做任何的封装，同时通过Debug发现Spring获得的Connection是org.jboss.resource.adapter.jdbc.WrappedConnection类，看来是JBoss的JNDI数据源的Connection没错了。没找到源码，所以只好用jd反编辑查看了，发现里面有个jdbcAutoCommit，默认是true，WrappedConnection是实现java.sql.Connection的，所以提供了setAutoCommit()，但是由于能力有限无法找到JBoss初始化JNDI数据源的代码，也没找到任何可配置该参数的地方，所以没整了。</p>
<h4 id="问题解决"><strong>问题解决</strong></h4><p>既然写这篇文章，总归有个解决方案，不管好还是不好，总不能留着打自己脸呀。</p>
<p>解决方案就是发现JBoss配置数据源时有一个参数：new-connection-sql，通过注释发现该参数是在每次创建一个新的Connection时调用的，目的可能是用来测试或者其他的，有了这个参数我们就可以在所有通过该Connection的请求之前设置当前Connection的autoCommit=0，所以这个参数的值设置为set autocommit=0就可以解决啦。</p>
<p>同时发现有些数据源页不提供自动提交事务配置，默认还都是true（不知道是自己没找对还是真的没有，如C3P0）。</p>
<hr>
<p>原创文章，转载请注明出处，多谢~~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>记一次数据源的自动提交事务带来的烦恼，并通过分析找到JBoss JNDI数据源默认自动提交事务的解决方案<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="事务" scheme="http://vickyqi.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="数据源" scheme="http://vickyqi.com/tags/%E6%95%B0%E6%8D%AE%E6%BA%90/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JDK并发工具类源码学习系列——ConcurrentSkipListMap]]></title>
    <link href="http://vickyqi.com/2015/11/08/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentSkipListMap/"/>
    <id>http://vickyqi.com/2015/11/08/JDK并发工具类源码学习系列——ConcurrentSkipListMap/</id>
    <published>2015-11-08T12:05:00.000Z</published>
    <updated>2015-11-13T06:12:26.000Z</updated>
    <content type="html"><![CDATA[<p>ConcurrentSkipListMap在JDK并发工具类使用范围不是很广，它是针对某一特殊需求而设计的——支持排序，同时支持搜索目标返回最接近匹配项的导航方法。一般情况下开发者很少会使用到该类，但是如果你有如上的特殊需求，那么ConcurrentSkipListMap将是一个很好地解决方案。 本文通过对JDK的ConcurrentSkipListMap的代码详细分析，深入分析其实现原理。<br><a id="more"></a><br>更多文章请阅读：<a href="http://vickyqi.com/2015/10/24/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E4%BB%8B%E7%BB%8D/">JDK并发工具类源码学习系列目录</a>。<br>ConcurrentSkipListMap在JDK并发工具类使用范围不是很广，它是针对某一特殊需求而设计的——支持排序，同时支持搜索目标返回最接近匹配项的导航方法。一般情况下开发者很少会使用到该类，但是如果你有如上的特殊需求，那么ConcurrentSkipListMap将是一个很好地解决方案。<br>Java Collections Framework中另一个支持排序的Map是TreeMap，两者都是有序的哈希表，但是TreeMap是非线程安全的，当然可以使用Collections.synchronizedSortedMap将TreeMap进行包装，但是性能方面就显得捉急了，毕竟多个线程一起读都需要加锁是不太合理的，至少做到读写分离呀。但是从JDK1.6开始我们就多了一个选择：ConcurrentSkipListMap。这是一个支持高并发度的有序哈希表，并且是无锁的，可在多线程环境下替代TreeMap。<br>下面我们从几个方面来分析ConcurrentSkipListMap的实现，主要分析ConcurrentSkipListMap的数据结构以及如何实现高并发且无锁读写的。</p>
<ul>
<li>实现原理</li>
<li>数据结构</li>
<li>常用方法解读</li>
<li>使用场景</li>
</ul>
<h5 id="实现原理"><strong>实现原理</strong></h5><p>ConcurrentSkipListMap不同于TreeMap，前者使用SkipList(跳表)实现排序，而后者使用红黑树。相比红黑树，跳表的原理比较容易理解，简单点说就是在有序的链表上使用多级索引来定位元素。下面是简单看看SkipList的原理：</p>
<p>现在假设我们拥有一个有序的列表，如果我们想要在这个列表中查找一个元素，最优的查找算法应该是二分    查找了，但是链表不想数组，链表的元素是非连续的，所以无法使用二分查找来进行高效查找，那么抛开其他查找算法不说，最低效的算法就是从链表头部开始遍历，直至找到要查找的元素，虽说低效但是确是最大化使用了链表的优势——遍历。那么我们有没有可能同时提高查找效率，而且还使用链表的优势呢？跳表就是我们想要的查找算法。其实说白了跳表就是一种多级索引，通过索引链表中的部分值来确定被查找的值所处的范围。</p>
<p>跳表分为多层，层数越高，最高层元素越少，查找时也会越快，但是所占空间也就越多，所以跳表是用空间换时间（可见如果大量数据不是太适用，毕竟内存是有限的）。</p>
<p><strong>跳表结构示意图：</strong></p>
<p><img src="http://img.blog.csdn.net/20151106120258045" alt="跳表"></p>
<p>可以看见每一层都是一个有序的链表，而且是原始链表的子集，最底层（level1）是完整的链表结构，越往上链表的元素越少，同时查找也就越快。当我们需要查找一个元素时，会从跳表的最上层链表开始查询，定位元素的大致位置，然后通过向下指针再在下层查找。</p>
<p><strong>跳表查找示意图：</strong></p>
<p><img src="http://img.blog.csdn.net/20151106120618501" alt="跳表查找示意图"></p>
<p>上图是从跳表中查找32的过程。<br>跳表的查找时间复杂度是：O(log(n))，更多详细关于跳表的介绍可参考：<a href="http://kenby.iteye.com/blog/1187303" target="_blank" rel="external">http://kenby.iteye.com/blog/1187303</a></p>
<h5 id="数据结构"><strong>数据结构</strong></h5><p>ConcurrentSkipListMap在原始链表的基础上增加了跳表的结构，所以需要两个额外的内部类来封装链表的节点，以及跳表的节点——<strong>Node</strong>和<strong>Index</strong>。</p>
<h6 id="Node：链表的节点"><strong>Node：链表的节点</strong></h6><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static final class <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; &#123;</span><br><span class="line">	final K key;</span><br><span class="line">	volatile Object value;</span><br><span class="line">	volatile <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同ConcurrentHashMap的Node节点一样，key为final，是不可变的，value和next通过volatile修饰保证内存可见性。</p>
<h6 id="Index：跳表的节点"><strong>Index：跳表的节点</strong></h6><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static class Index<span class="tag">&lt;K,V&gt;</span> &#123;</span><br><span class="line">	final <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; <span class="keyword">node</span><span class="identifier"></span><span class="title">;</span><br><span class="line">	final</span> Index<span class="tag">&lt;K,V&gt;</span> down;</span><br><span class="line">	volatile Index<span class="tag">&lt;K,V&gt;</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Index封装了跳表需要的结构，首先node包装了链表的节点，down指向下一层的节点（不是Node，而是Index），right指向同层右边的节点。node和down都是final的，说明跳表的节点一旦创建，其中的值以及所处的层就不会发生变化（因为down不会变化，所以其下层的down都不会变化，那他的层显然不会变化）。<br>Node和Index内部都提供了用于CAS原子更新的AtomicReferenceFieldUpdater对象，至于该对象的原理下面是不会深入研究的。</p>
<h5 id="常用方法解读"><strong>常用方法解读</strong></h5><p>从API文档可以看到ConcurrentHashMap的方法很多，很多都是一些为了方便开发者的提供的，例如subMap(K, boolean, K, boolean)、headMap(K, boolean)、tailMap(K, boolean)等都是用来返回一个子视图的方法。这里我们主要看看能够表达ConcurrentHashMap实现原理的三个方法：put(K, V)、get(Object)、remove(Object, Object)。<br>在介绍这三个方法之前，我们先看一个辅助工具方法：comparable(Object)。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * If using comparator, return a ComparableUsingComparator, else</span><br><span class="line"> * cast key as Comparable, which may cause ClassCastException,</span><br><span class="line"> * which is propagated back to caller.</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">// @By Vicky:将key封装成一个Comparable对象</span></span><br><span class="line"><span class="keyword">private</span> Comparable&lt;? <span class="keyword">super</span> K&gt; comparable(<span class="keyword">Object</span> <span class="variable">key</span>) <span class="keyword">throws</span> ClassCastException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">key</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// @By Vicky:有两种封装方法，如果在构造时指定了comparator，则使用comparator封装key</span></span><br><span class="line">    <span class="comment">// 如果没有指定comparator，则key必须是一个继承自Comparable接口的类，否则会抛出ClassCastException</span></span><br><span class="line">    <span class="comment">// 所以ConcurrentSkipListMap的key要么是继承自Comparable接口的类，如果不是的话需要显示提供comparator进行比较</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ComparableUsingComparator&lt;K&gt;((K)<span class="variable">key</span>, comparator);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (Comparable&lt;? <span class="keyword">super</span> K&gt;)<span class="variable">key</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面那个辅助方法可以看到ConcurrentSkipListMap的key必须要能够进行比较，可以有两种方式提供比较方法，代码注释中已提到。</p>
<h6 id="put(K,_V)"><strong>put(K, V)</strong></h6><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">   <span class="comment">// @By Vicky:实际调用内部的doPut方法</span></span><br><span class="line">   <span class="keyword">return</span> doPut(key, <span class="keyword">value</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* @By Vicky:</span><br><span class="line"> * 三个参数，其中onlyIfAbsent表示是否只在Map中不包含该key的情况下才插入value，默认是false</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doPut</span>(<span class="params">K kkey, V <span class="keyword">value</span>, boolean onlyIfAbsent</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 将key封装成一个Comparable对象，便于直接与其他key进行比较</span></span><br><span class="line">    Comparable&lt;? super K&gt; key = comparable(kkey);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">// 从跳表中查找最接近指定key的节点：该节点的key小于等于指定key，且处于最底层</span></span><br><span class="line">        Node&lt;K,V&gt; b = findPredecessor(key);</span><br><span class="line">        Node&lt;K,V&gt; n = b.next;<span class="comment">// b的下一个节点，新节点即将插入到b与n之间</span></span><br><span class="line">        <span class="comment">// 准备插入</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;<span class="comment">// n==null则说明b是链表的最后一个节点，则新节点直接插入到链表尾部即可</span></span><br><span class="line">                Node&lt;K,V&gt; f = n.next;<span class="comment">// n的下一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (n != b.next)               <span class="comment">// inconsistent read 此处增加判断，避免链表结构已被修改(针对节点b)</span></span><br><span class="line">                    <span class="keyword">break</span>;;</span><br><span class="line">                Object v = n.<span class="keyword">value</span>;</span><br><span class="line">                <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;               <span class="comment">// n is deleted</span></span><br><span class="line">                    n.helpDelete(b, f);<span class="comment">// 将n从链表移除，b和f分别为n的前继节点与后继节点</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里如果v==n说明n是一个删除标记，用来标记其前继节点已被删除，即b已被删除</span></span><br><span class="line">                <span class="comment">// 查看helpDelete()的注释</span></span><br><span class="line">                <span class="keyword">if</span> (v == n || b.<span class="keyword">value</span> == <span class="keyword">null</span>) <span class="comment">// b is deleted</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 比较key，此处进行二次比较是避免链表已发生改变，比如b后面已被插入一个新的节点</span></span><br><span class="line">                <span class="comment">// (findPredecessor时已经比较过b的next节点(n)的key与指定key的大小，因为n的key&gt;指定key才会返回b)</span></span><br><span class="line">                <span class="keyword">int</span> c = key.compareTo(n.key);</span><br><span class="line">                <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果指定key&gt;n的key，则判断下一个节点，直到n==null，或者指定key&lt;n的key</span></span><br><span class="line">                    b = n;</span><br><span class="line">                    n = f;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">// 相等，则更新value即可，更新失败，就再来一次，一直到成功为止</span></span><br><span class="line">                    <span class="keyword">if</span> (onlyIfAbsent || n.casValue(v, <span class="keyword">value</span>))</span><br><span class="line">                        <span class="keyword">return</span> (V)v;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// restart if lost race to replace value</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// else c &lt; 0; fall through</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建一个节点，next指向n</span></span><br><span class="line">            Node&lt;K,V&gt; z = <span class="keyword">new</span> Node&lt;K,V&gt;(kkey, <span class="keyword">value</span>, n);</span><br><span class="line">            <span class="comment">// 将b的next指向新创建的节点，则新的链表为：b--&gt;new--&gt;n，即将新节点插入到b和n之间</span></span><br><span class="line">            <span class="keyword">if</span> (!b.casNext(n, z))</span><br><span class="line">                <span class="keyword">break</span>;         <span class="comment">// restart if lost race to append to b</span></span><br><span class="line">            <span class="comment">// 随机计算一个层级</span></span><br><span class="line">            <span class="keyword">int</span> level = randomLevel();</span><br><span class="line">            <span class="comment">// 将z插入到该层级</span></span><br><span class="line">            <span class="keyword">if</span> (level &gt; <span class="number">0</span>)</span><br><span class="line">                insertIndex(z, level);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中已经附上了大量的注释，这里再简单的梳理下流程。首先put()方法是调用内部的doPut()方法。<code>Comparable&lt; ? super K&amp;&gt; key = comparable(kkey);</code>这一句将key封装成一个Comparable对象，上面已经介绍了comparable这个方法。接着进入到死循环，循环第一步是调用<strong>findPredecessor(key)</strong>方法，该方法返回一个key最接近指定key的节点(最接近指的是小于等于)，该节点是处于最底层的，下面介绍下这个方法的逻辑。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span><br><span class="line">* @By Vicky:</span><br><span class="line"> * 在跳表中查找节点的key小于指定key，且处于最底层的节点，即找到指定key的前继节点</span><br><span class="line"> * 基本逻辑是从head(跳表的最高层链表的头结点)开始自右开始查找，当找到该层链表的最接近且小于指定key的节点时，往下开始查找，</span><br><span class="line"> * 最终找到最底层的那个节点</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;K,V&gt; findPredecessor(Comparable&lt;? <span class="keyword">super</span> K&gt; <span class="variable">key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">key</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don't postpone errors</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Index&lt;K,V&gt; q = head;<span class="comment">// head是跳表的最高层链表的头结点</span></span><br><span class="line">        Index&lt;K,V&gt; r = q.right;<span class="comment">// head的右边节点</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;<span class="comment">// 循环</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;<span class="comment">// r==null说明该层链表已经查找到头，且未找到符合条件的节点，需开始往下查找</span></span><br><span class="line">                Node&lt;K,V&gt; n = r.node;<span class="comment">// r的数据节点</span></span><br><span class="line">                K k = n.<span class="variable">key</span>;<span class="comment">// r的key，用于跟指定key进行比较</span></span><br><span class="line">                <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123; <span class="comment">// n的value为null，说明该节点已被删除</span></span><br><span class="line">                    <span class="keyword">if</span> (!q.unlink(r))<span class="comment">// 将该节点从链表移除，通过将其(n)前置节点的right指向其(n)的后置节点</span></span><br><span class="line">                        <span class="keyword">break</span>;           <span class="comment">// restart</span></span><br><span class="line">                    r = q.right;         <span class="comment">// reread r 移除value==null的n节点之后，继续从n的下一个节点查找</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">key</span>.compareTo(k) &gt; <span class="number">0</span>) &#123;<span class="comment">// 比较当前查找的节点的key与指定key，如果小于指定key，则继续查找，</span></span><br><span class="line">                						   <span class="comment">// 大于等于key则q即为该层链表最接近指定key的</span></span><br><span class="line">                    q = r;</span><br><span class="line">                    r = r.right;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 到这里有两种情况：1)该层链表已经查找完，仍未找到符号条件的节点 2)找到一个符合条件的节点</span></span><br><span class="line">            <span class="comment">// 开始往下一层链表进行查找</span></span><br><span class="line">            Index&lt;K,V&gt; d = q.down;</span><br><span class="line">            <span class="keyword">if</span> (d != <span class="keyword">null</span>) &#123;<span class="comment">// 从下层对应位置继续查找</span></span><br><span class="line">                q = d;</span><br><span class="line">                r = d.right;</span><br><span class="line">            &#125; <span class="keyword">else</span><span class="comment">// 如果无下层链表则直接返回当前节点的node</span></span><br><span class="line">                <span class="keyword">return</span> q.node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @By Vicky:将当前节点的right指向succ的right指向的节点，即将succ从链表移除</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">boolean</span> unlink(Index&lt;K,V&gt; succ) &#123;</span><br><span class="line">    <span class="keyword">return</span> !indexesDeletedNode() &amp;&amp; casRight(succ, succ.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的查找逻辑是：从head(跳表的最高层链表的头结点)开始自右开始查找，当找到该层链表的最接近且小于指定key的节点时，往下开始查找，最终找到最底层的那个节点。具体的代码可以看注释，应该说的挺明白的了，针对PUT方法，这个方法返回的节点就是将要插入的节点的前继节点，即新节点将插到该节点后面。下面是查找的示意图。</p>
<p><strong>findPredecessor查找示意图:</strong></p>
<p><img src="http://img.blog.csdn.net/20151106144215941" alt="findPredecessor查找示意图"></p>
<p>findPredecessor()介绍完，我们返回doPut()继续往下走。通过findPredecessor()返回节点b，获取b的next节点赋值n，接着进入死循环。判断n是否为null，n==null则说明b是链表的最后一个节点，则新节点直接插入到链表尾部即可，下面我们来看看n!=null的情况。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; f = <span class="keyword">n</span>.next;<span class="comment">// n的下一个节点</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">n</span> != b.next)     <span class="comment">// inconsistent read 此处增加判断，避免链表结构已被修改(针对节点b)</span></span><br><span class="line">   <span class="keyword">break</span>;;</span><br><span class="line">Object v = <span class="keyword">n</span>.value;</span><br><span class="line"><span class="keyword">if</span> (v == null) &#123;               <span class="comment">// n is deleted</span></span><br><span class="line">    <span class="keyword">n</span>.helpDelete(b, f);<span class="comment">// 将n从链表移除，b和f分别为n的前继节点与后继节点</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里如果v==n说明n是一个删除标记，用来标记其前继节点已被删除，即b已被删除</span></span><br><span class="line"><span class="comment">// 查看helpDelete()的注释</span></span><br><span class="line"><span class="keyword">if</span> (v == <span class="keyword">n</span> || b.value == null) <span class="comment">// b is deleted</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>这里首先判断在这段时间内b的next是否被修改，如果被修改则重新获取。再接着判断n和b是否被删除。这里说下helpDelete()方法，这个方法比较绕。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void helpDelete(<span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; b, <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; f) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * Rechecking links <span class="operator">and</span> then doing only one of the</span><br><span class="line">     * help-out stages per call tends to minimize CAS</span><br><span class="line">     * interference among helping threads.</span><br><span class="line">     */</span><br><span class="line">    if (f == next &amp;&amp; this == b.next) &#123;</span><br><span class="line">    	// 判断当前节点是否已添加删除标记，未添加则添加删除标记</span><br><span class="line">        if (f == null || f.value != f) // not already marked</span><br><span class="line">            appendMarker(f);</span><br><span class="line">        else</span><br><span class="line">        // 如果已添加删除标记，则将b的next指向f的next</span><br><span class="line">      	// 因为当前节点已添加了删除标记，所以这里的f只是一个标记：<span class="variable">value=</span>=本事的节点，其next才是链表的下一个节点</span><br><span class="line">        // 这里应该是remove方法相关，涉及到ConcurrentSkipListMap的删除方式</span><br><span class="line">            b.casNext(this, f.next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* @By Vicky:为当前节点增加一个删除标记 </span><br><span class="line"> * 将当前节点的next指向一个新节点，该新节点的next指向f，所以从结构是：当前--&gt;new--&gt;f</span><br><span class="line"> * 新节点的value就是他自己，参见<span class="keyword">Node</span><span class="identifier"></span><span class="title">(Node</span><span class="tag">&lt;K,V&gt;</span> next)构造函数</span><br><span class="line"> * 即删除标记就是将一个节点与其next节点之间插入一个value就是本事的节点</span><br><span class="line"> */</span><br><span class="line">boolean appendMarker(<span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; f) &#123;</span><br><span class="line">    return casNext(f, new <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt;(f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>介绍helpDelete()之前，先简单介绍ConcurrentSkipListMap是如何删除一个节点的，其实ConcurrentSkipListMap删除一个节点现将该节点的value值为NULL，然后再为这个节点添加一个删除标记，但是这个操作有可能失败，所以如果一个节点的value为NULL，或者节点有一个删除标记都被认为该节点已被删除。appendMarker()就是用来添加删除标记，helpDelete()是用来将添加了删除标记的节点清除。添加标记和如何清除在代码中的注释已经说的很清楚了，就不多说了。继续看doPut()。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较key，此处进行二次比较是避免链表已发生改变，比如b后面已被插入一个新的节点</span></span><br><span class="line"><span class="comment">// (findPredecessor时已经比较过b的next节点(n)的key与指定key的大小，因为n的key&gt;指定key才会返回b)</span></span><br><span class="line">int c = key.compareTo(<span class="keyword">n</span>.key);</span><br><span class="line"><span class="keyword">if</span> (c &gt; 0) &#123;<span class="comment">// 如果指定key&gt;n的key，则判断下一个节点，直到n==null，或者指定key&lt;n的key</span></span><br><span class="line">    b = <span class="keyword">n</span>;</span><br><span class="line">    <span class="keyword">n</span> = f;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c == 0) &#123;<span class="comment">// 相等，则更新value即可，更新失败，就再来一次，一直到成功为止</span></span><br><span class="line">    <span class="keyword">if</span> (onlyIfAbsent || <span class="keyword">n</span>.casValue(v, value))</span><br><span class="line">        <span class="keyword">return</span> (V)v;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// restart if lost race to replace value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// else c &lt; 0; fall through</span></span><br></pre></td></tr></table></figure>
<p>这几句是考虑当我们找到一个最接近指定key的节点之后有可能链表被修改，所以还需要进行二次校验，从b开始往右边查找，直至找到一个key大于指定key的节点，那么新的节点就插入到该节点前面。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个节点，next指向n</span></span><br><span class="line">Node&lt;K,V&gt; z = <span class="keyword">new</span> Node&lt;K,V&gt;(kkey, <span class="keyword">value</span>, n);</span><br><span class="line"><span class="comment">// 将b的next指向新创建的节点，则新的链表为：b--&gt;new--&gt;n，即将新节点插入到b和n之间</span></span><br><span class="line"><span class="keyword">if</span> (!b.casNext(n, z))</span><br><span class="line">    <span class="keyword">break</span>;         <span class="comment">// restart if lost race to append to b</span></span><br><span class="line"><span class="comment">// 随机计算一个层级</span></span><br><span class="line"><span class="keyword">int</span> level = randomLevel();</span><br><span class="line"><span class="comment">// 将z插入到该层级</span></span><br><span class="line"><span class="keyword">if</span> (level &gt; <span class="number">0</span>)</span><br><span class="line">    insertIndex(z, level);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>这几句就是创建一个新的节点，并插入到原链表中，所有的修改操作都是使用CAS，只要失败就会重试，直至成功，所以就算多线程并发操作也不会出现错误，而且通过CAS避免了使用锁，性能比用锁好很多。</p>
<hr>
<p><a href="http://vickyqi.com/2015/11/13/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentSkipListMap(%E7%BB%AD">请继续阅读后续部分~~~</a>/)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ConcurrentSkipListMap在JDK并发工具类使用范围不是很广，它是针对某一特殊需求而设计的——支持排序，同时支持搜索目标返回最接近匹配项的导航方法。一般情况下开发者很少会使用到该类，但是如果你有如上的特殊需求，那么ConcurrentSkipListMap将是一个很好地解决方案。 本文通过对JDK的ConcurrentSkipListMap的代码详细分析，深入分析其实现原理。<br>]]>
    
    </summary>
    
      <category term="JDK" scheme="http://vickyqi.com/tags/JDK/"/>
    
      <category term="JUC" scheme="http://vickyqi.com/tags/JUC/"/>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="JDK源码" scheme="http://vickyqi.com/categories/Java/JDK%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JDK并发工具类源码学习系列——ConcurrentLinkedQueue]]></title>
    <link href="http://vickyqi.com/2015/10/29/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentLinkedQueue/"/>
    <id>http://vickyqi.com/2015/10/29/JDK并发工具类源码学习系列——ConcurrentLinkedQueue/</id>
    <published>2015-10-29T13:51:00.000Z</published>
    <updated>2015-11-13T06:08:10.000Z</updated>
    <content type="html"><![CDATA[<p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现，该算法在Michael &amp; Scott算法上进行了一些修改, Michael &amp; Scott算法的详细信息可以参见<a href="http://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf" target="_blank" rel="external">参考资料一</a>。<br><a id="more"></a><br>上一篇文章介绍了JDK java.util.concurrent包下很重要的一个类：<a href="http://vickyqi.com/2015/10/26/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentHashMap/">ConcurrentHashMap</a>，今天来看下另一个重要的类——ConcurrentLinkedQueue。<br>在多线程编程环境下并发安全队列是不可或缺的一个重要工具类，为了实现并发安全可以有两种方式：一种是阻塞式的，例如：LinkedBlockingQueue；另一种即是我们将要探讨的非阻塞式，例如：ConcurrentLinkedQueue。相比较于阻塞式，非阻塞的最显著的优点就是性能，非阻塞式算法使用CAS来原子性的更新数据，避免了加锁的时间，同时也保证了数据的一致性。</p>
<h4 id="简单介绍"><strong>简单介绍</strong></h4><p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现，该算法在Michael &amp; Scott算法上进行了一些修改, Michael &amp; Scott算法的详细信息可以参见<a href="http://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf" target="_blank" rel="external">参考资料一</a>。</p>
<h4 id="结构预览"><strong>结构预览</strong></h4><p>首先看看结构图：</p>
<p><strong>图1：ConcurrentLinkedQueue结构图：</strong><br><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blogConcurrentLinkedQueue%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="ConcurrentLinkedQueue结构图"><br>从图中可以看到ConcurrentLinkedQueue中包含两个内部类：Node&lt;E&gt;和Itr。Node&lt;E&gt;用来表示ConcurrentLinkedQueue链表中的一个节点，通过Node&lt;E&gt;的next字段指向下一个节点，从而形成一个链表结构；Itr实现Iterator&lt;E&gt;接口，用来遍历ConcurrentLinkedQueue。ConcurrentLinkedQueue中的方法不多，其中最主要的两个方法是：offer(E)和poll()，分别实现队列的两个重要的操作：入队和出队。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>offer(E)</td>
<td>插入一个元素到队列尾部</td>
</tr>
<tr>
<td>poll()</td>
<td>从队列头部取出一个元素</td>
</tr>
<tr>
<td>add(E)</td>
<td>同offer(E)</td>
</tr>
<tr>
<td>peek()</td>
<td>获取头部元素，但不删除</td>
</tr>
<tr>
<td>isEmpty()</td>
<td>判断队列是否为空</td>
</tr>
<tr>
<td>size()</td>
<td>获取队列长度(元素个数)</td>
</tr>
<tr>
<td>contains(Object)</td>
<td>判断队列是否包含指定元素</td>
</tr>
<tr>
<td>remove(Object)</td>
<td>删除队列中指定元素</td>
</tr>
<tr>
<td>toArray(T[])</td>
<td>将队列的元素复制到一个数组</td>
</tr>
<tr>
<td>iterator()</td>
<td>返回一个可遍历该队列的迭代器</td>
</tr>
</tbody>
</table>
<p>下面会着重分析offer(E)和poll()两个方法，同时会讲解remove(Object)和iterator()方法。</p>
<h4 id="常用方法解读"><strong>常用方法解读</strong></h4><h5 id="入队——offer"><strong>入队——offer</strong></h5><p>首先看看入队操作，由于是无阻塞的队列，所以整个入队操作是在无锁模式下进行的，下面来分析下JDK到底是如何实现无锁并保证安全性的。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Inserts the specified element at the tail of this queue.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Queue#offer&#125;)</span><br><span class="line"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//①</span></span><br><span class="line">        Node&lt;E&gt; t = tail;<span class="comment">//②</span></span><br><span class="line">        Node&lt;E&gt; s = t.getNext();<span class="comment">//②</span></span><br><span class="line">        <span class="keyword">if</span> (t == tail) &#123;<span class="comment">//③</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;<span class="comment">//④</span></span><br><span class="line">                <span class="keyword">if</span> (t.casNext(s, n)) &#123;<span class="comment">//⑥</span></span><br><span class="line">                    casTail(t, n);<span class="comment">//⑦</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                casTail(t, s);<span class="comment">//⑤</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码不长，但是思路还是很巧妙的，下面我们逐句深入分析每一行代码。<code>if (e == null) throw new NullPointerException(); Node<e> n = new Node<e>(e, null);</e></e></code>检查NULL，避免NullPointerException，然后创建一个Node，该Node的item为传入的参数e，next为NULL。<code>for (;;) {}</code>接着是一个死循环，死循环保证该入队操作能够一直重试直至入队成功。<code>Node<e> t = tail; Node<e> s = t.getNext();</e></e></code>使用局部变量t引用tail节点，同时获取tail节点的next节点，赋予变量s。<code>if (t == tail) {}</code>只有在t==tail的情况下才会执行入队操作，否则进行下一轮循环，直到t==tail，因为是无锁模式，所以如果同时有多个线程在执行入队操作，那么在一个线程读取了tail之后，很可能会有其他线程已经修改了tail（<strong>此处的修改是指将tail指向另一个节点，所以t还引用着原来的节点，导致t!=tail，而并非是修改了tail所指向的节点的值</strong>），此处的判断避免了一开始的错误，但是并不能保证后续的执行过程中不会插入其他线程的操作，其实ConcurrentLinkedQueue的设计使得if内的代码即使在有其他线程插入的情况下依旧能够很好地执行，下面我们接着分析。</p>
<p><code>if (s == null) {} else { casTail(t, s); }</code>这里判断s（tail的next是否为NULL），如果不为NULL，则直接将tail指向s。这里需要说明一下：由于tail指向的是队列的尾部，所以tail的next应该始终是NULL，那么当发生tail的next不为NULL，则说明当前队列处于不一致状态，这时当前线程需要帮助队列进入一致性状态，这就是ConcurrentLinkedQueue设计的巧妙之处！那么如果帮助队列进入一致性状态呢？这个问题我们先留着，继续看什么情况下会导致队列进入不一致状态！<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t.casNext(s, <span class="keyword">n</span>)) &#123;</span><br><span class="line">	casTail(t, <span class="keyword">n</span>);</span><br><span class="line">    <span class="keyword">return</span> true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这几句代码完成了入队的操作，第一步CAS的设置t（指向tail）的next为n（新创建的节点），该更新操作能够完成的前提是t的next值==s，即tail的next值在该线程首次读取期间并未发生变化。此处的CAS操作保证了tail的next值更新的原子性，所以不会出现不一致情况。当成功更新了tail的next节点之后，接下来就是原子性的更新tail为n，此处如果更新成功，则入队顺利完成完成，但是奇怪的是如果此处更新失败，入队依旧是成功的！为什么呢？看下文。</p>
<p>我们试想如果一个线程成功的原子性更新了tail的next值为新创建的节点，由于Node的next是volatile修饰的，所以会立即被之后的所有线程可见，那么就会出现tail未变化但是tail的next已经不是NULL了，此时就会出现上面提到的tail的next不为NULL的情况了，现在我们再来看看上面是如何处理这种情况的，<code>casTail(t, s);</code>，从这句可以看出当一个线程看到tail的next不为NULL时就会直接将tail更新成s（tail的next所指向的节点），即将tail指向其next节点，当然这里的更新也是CAS保证的原子性更新。为什么敢这么大胆，正是因为如果当前线程（T1）看到tail的next不为NULL，那么必然是有一个线程（T2）处于入队操作中，且成功执行了<code>t.casNext(s, n)</code>（将新创建的节点赋到tail的next上），正准备执行<code>casTail(t, n);</code>（将tail执行其next指向的节点），那么T1直接将T2准备做的工作完成，然后再进入循环重新进行入队操作，而T2也不在乎自己这一步是否顺利完成，反正只要有人完成了就行，所以T2就直接返回入队成功，最终T1帮助T2顺利完成了入队操作，并且全程无锁，此设计真的是巧妙啊~~~</p>
<p>下面我们使用流程图形象的描绘下入队过程，整个入队方法被划分成7步（见上面的代码中的注释）。说明：虽然入队是在无锁模式下进行，但是由于使用CAS进行原子性更新，所以很多地方其实还是实现了线程安全的，除了⑥-&gt;⑦，下面的图描绘的也正是⑥-&gt;⑦这一步可能出现的冲突情况。</p>
<p><strong>图2：ConcurrentLinkedQueue入队流程图：</strong><br><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/ConcurrentLinkedQueue%E5%85%A5%E9%98%9F%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="ConcurrentLinkedQueue入队流程图"></p>
<p>上面介绍了ConcurrentLinkedQueue是如何实现无锁入队的，但是我们只说明了多个线程同时入队操作是线程安全的，但是如果多个线程同时进行入队和出队，以及删除操作呢？这个问题在下面分析另外两个方法时会提到，同时最后也会进行一个总结，下面我们先看看删除操作是如何实现的。</p>
<h5 id="删除——remove"><strong>删除——remove</strong></h5><p>先介绍删除，是因为出队操作有个地方需要在这里提前介绍下。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="keyword">null</span>; p = p.getNext()) &#123;<span class="comment">// ②</span></span><br><span class="line">        E item = p.getItem();<span class="comment">// ③</span></span><br><span class="line">        <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            o.equals(item) &amp;&amp;</span><br><span class="line">            p.casItem(item, <span class="keyword">null</span>))<span class="comment">// ④</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>源码中的注释申明了remove方法会使用equals()判断两个节点的值与待删除的值是否相同，同时如果队列有多个与待删除值相同的节点则只删除最前面的一个节点。</p>
<p>同样remove()方法也是无锁模式，①判断是否为NULL，②从队列头部开始查找，③获取每个节点的item值，用于跟o进行equals比较，前面三步都很平常，重点在④，<code>if (item != null &amp;&amp; o.equals(item) &amp;&amp; p.casItem(item, null))</code>这里首先判断item不为NULL，然后判断item与o相等，前面两个都满足的话，那说明已经查找到一个节点的值与待删除的值一样，后面就是删除该节点，这里删除其实并非真的删除，而只是原子性的将节点的item值设置为NULL。从上面的分析可以看出ConcurrentLinkedQueue的删除只是将队列中的某个节点值置为NULL，由于Node的item是volatile的，所以不存在线程安全问题，同时由于remove并未修改队列的结构，所以多个线程同时进行remove，或者同其他方法一起进行也不会发生线程安全性问题。</p>
<h5 id="出队——poll"><strong>出队——poll</strong></h5><p>出队从逻辑上来说就是从队列的头部往外取出数据并删除，下面看看ConcurrentLinkedQueue是如何实现无锁出队的。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">E</span> poll() &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">// ①</span></span><br><span class="line">        Node&lt;<span class="keyword">E</span>&gt; <span class="keyword">h</span> = head;<span class="comment">// ②</span></span><br><span class="line">        Node&lt;<span class="keyword">E</span>&gt; t = tail;<span class="comment">// ②</span></span><br><span class="line">        Node&lt;<span class="keyword">E</span>&gt; first = <span class="keyword">h</span>.getNext();<span class="comment">// ②</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">h</span> == head) &#123;<span class="comment">// ③</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">h</span> == t) &#123;<span class="comment">// ④</span></span><br><span class="line">                <span class="keyword">if</span> (first == null)<span class="comment">// ⑤</span></span><br><span class="line">                    <span class="keyword">return</span> null;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    casTail(t, first);<span class="comment">// ⑥</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(<span class="keyword">h</span>, first)) &#123;<span class="comment">// ⑦</span></span><br><span class="line">                <span class="keyword">E</span> item = first.getItem();<span class="comment">// ⑧</span></span><br><span class="line">                <span class="keyword">if</span> (item != null) &#123;<span class="comment">// ⑨</span></span><br><span class="line">                    first.setItem(null);<span class="comment">// ⑩</span></span><br><span class="line">                    <span class="keyword">return</span> item;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// else skip over deleted item, continue loop,</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>出队的步骤略多些，不过理解了也就很简单了。首先①是一个死循环；②的三步分别是获取head/tail/head.next三个节点；③判断h==head，避免操作过程中已有其他线程移动了head；④判断head是否等于tail，即队列是否为NULL，说到这里我们先来看看head和tail在队列中到底处于什么位置。我们用一个队列入队出队的时序图来描绘下在入队和出队过程中head和tail到底是如何变化的。</p>
<p><strong>图3：ConcurrentLinkedQueue队列时序图：</strong><br><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/ConcurrentLinkedQueue%E9%98%9F%E5%88%97%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="ConcurrentLinkedQueue队列"><br>从图中我们可以看出head的next指向的是队列的第一个元素，我们出队也是将head的next指向的元素出队，同时head==tail说明队列已经没有元素了。明白了这两点我们再接着④分析，如果④这里为真，说明队列已经为NULL，接着⑤判断f（head的next指向的节点）是否为NULL，不为NULL则执行⑥将tail指向f，到这里如果理解了上面入队操作，那么应该是可以理解这一步的用意的——帮助其他线程执行入队操作，跟入队时的⑤是一样的，因为head==tail，head的next不为NULL，则说明tail的next不为NULL，所以要将tail重新指向他的next，帮助正在执行入队的线程完成入队工作。理解了这一步那么出队操作就已经理解了一大半了，下面继续看⑦⑧⑨⑩。</p>
<p>如果head!=tail，则队列不为NULL，那么直接将head指向下一个节点，将当前节点踢出队列即可，当然需要CAS保证原子性更新，然后将踢出队列的节点的item取出返回，并置为NULL即完成了出队操作。这里需要注意的是如果被踢出队列的节点的item是NULL，说明该节点已经被删除了（因为remove()方法只是将节点的item设置为NULL，而不将节点踢出队列），那就只能再次循环了。再提一点，为什么⑦⑧⑨⑩能够被线程安全的执行，因为在⑦这一步是原子更新的，而且更新之后这个节点就立即不会被其他任何线程访问到了，所以后面⑧⑨⑩想怎么处理都是安全的。</p>
<p>到这里出队操作应该很清楚了，下面就来综合分析下为什么针对ConcurrentLinkedQueue的整个入队/出队/删除都是不需要锁的。</p>
<ol>
<li>上面已经分析了如果多个线程同时访问其中任一个方法（offer/poll/remove）都是无需加锁而且线程安全的</li>
<li>由于remove方法不修改ConcurrentLinkedQueue的结构，所以跟其他两个方法都不会有冲突</li>
<li>如果同时两个线程，一个入队，一个出队，在队列不为NULL的情况下是不是有任何问题的，因为一个操作tail，一个操作head，完全不相关。但是如果队列为NULL时还是会发生冲突的，因为tail==head。这里我们在分析出队时也提到了，如果出队线程发现tail的next不为NULL，那么就会感知到当前有一个线程在执行入队操作，所以出队线程就会帮助入队线程完成入队操作，而且每个操作都是通过CAS保证原子性更新，所以就算同时两个线程，一个入队，一个出队也不会发生冲突。</li>
</ol>
<p>综上，ConcurrentLinkedQueue最终实现了无锁队列。</p>
<h4 id="使用场景"><strong>使用场景</strong></h4><p>ConcurrentLinkedQueue适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的ConcurrentLinkedQueue来替代。下面我们来简单对比下ConcurrentLinkedQueue与我们常用的阻塞队列LinkedBlockingQueue的性能。<br><strong>表1：入队性能对比</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">线程数</th>
<th style="text-align:left">ConcurrentLinkedQueue耗时(ms)</th>
<th style="text-align:left">LinkedBlockingQueue耗时(ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">22</td>
<td style="text-align:left">29</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">50</td>
<td style="text-align:left">59</td>
</tr>
<tr>
<td style="text-align:left">20</td>
<td style="text-align:left">99</td>
<td style="text-align:left">112</td>
</tr>
<tr>
<td style="text-align:left">30</td>
<td style="text-align:left">139</td>
<td style="text-align:left">171</td>
</tr>
</tbody>
</table>
<p>测试数据：N个线程，每个线程入队10000个元素。</p>
<hr>
<h4 id="参考文章"><strong>参考文章</strong></h4><p><a href="http://www.infoq.com/cn/articles/ConcurrentLinkedQueue" target="_blank" rel="external">聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析</a><br><a href="http://www.ibm.com/developerworks/cn/java/j-lo-concurrent/index.html" target="_blank" rel="external">非阻塞算法在并发容器中的实现</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现，该算法在Michael &amp; Scott算法上进行了一些修改, Michael &amp; Scott算法的详细信息可以参见<a href="http://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf">参考资料一</a>。<br>]]>
    
    </summary>
    
      <category term="JDK" scheme="http://vickyqi.com/tags/JDK/"/>
    
      <category term="JUC" scheme="http://vickyqi.com/tags/JUC/"/>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="JDK源码" scheme="http://vickyqi.com/categories/Java/JDK%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JDK并发工具类源码学习系列——ConcurrentHashMap]]></title>
    <link href="http://vickyqi.com/2015/10/26/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentHashMap/"/>
    <id>http://vickyqi.com/2015/10/26/JDK并发工具类源码学习系列——ConcurrentHashMap/</id>
    <published>2015-10-26T10:19:11.000Z</published>
    <updated>2015-11-13T06:01:20.000Z</updated>
    <content type="html"><![CDATA[<p>ConcurrentHashMap类在我的开发过程中经常被使用，个人觉得如果在共享一个Map时，如果无法判断是否需要加锁，那么就干脆直接使用ConcurrentHashMap，即能保证并发安全，同时性能也不会有太多下降，因为ConcurrentHashMap可实现无锁读，不过内存会占用的多些，但是并不明显，基本可以忽略。<br><a id="more"></a></p>
<p>作为JDK并发工具类源码学习系列的第一个被分析的类，ConcurrentHashMap类在我的开发过程中经常被使用。个人觉得如果在共享一个Map时，如果无法判断是否需要加锁，那么就干脆直接使用ConcurrentHashMap，即能保证并发安全，同时性能也不会有太多下降，因为ConcurrentHashMap可实现无锁读，不过内存会占用的多些，但是并不明显，基本可以忽略。<br>下面我们就来看看ConcurrentHashMap类的内部构造。</p>
<h4 id="结构预览"><strong>结构预览</strong></h4><h5 id="类定义"><strong>类定义</strong></h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap&lt;K</span>, <span class="title">V&gt;</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractMap&lt;K</span>, <span class="title">V&gt;</span> <span class="title">implements</span> <span class="title">ConcurrentMap&lt;K</span>, <span class="title">V&gt;</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>上面是ConcurrentHashMap类的定义，从ConcurrentHashMap的定义可以看出ConcurrentHashMap是实现了ConcurrentMap接口，而非直接实现Map接口。同时ConcurrentMap的子接口还有一个ConcurrentNavigableMap，表示可支持导航的并发Map。可见ConcurrentMap接口定义可支持并发，NavigableMap接口定义可支持导航，SortedMap接口定义可支持排序，NavigableMap继承自SortedMap。从Map的API介绍可以看出Java Collections Framework家族中重要一员——Map的组织结构——通过接口定义Map的行为，或者说Map可支持的功能，多个接口之间可交叉，如ConcurrentNavigableMap即实现ConcurrentMap接口又实现NavigableMap接口。</p>
<h5 id="类结构"><strong>类结构</strong></h5><p><img src="http://img.blog.csdn.net/20151009213243833" alt="ConcurrentHashMap结构图"><br>从图中可以看出ConcurrentHashMap内部包含了多个内部类，其中最重要的也是我们最需要关心的是：<strong>Segment</strong>和<strong>HashEntry</strong>。<br><strong>Segment</strong>是ConcurrentHashMap非常重要的一个内部类，是ConcurrentHashMap实现高并发的关键点，Segment在ConcurrentHashMap中承担着所有的操作，即所有对ConcurrentHashMap的操作最终都会对Segment进行操作。因为Segment保存了最终的数据，而ConcurrentHashMap只是保存了一个Segment的数组。ConcurrentHashMap通过N个Segment将数据切分成N块，而每块之间是互不影响的，所以理论上可以同时并行的执行N个需要加锁的操作，这就是ConcurrentHashMap并发的基础。<br><strong>HashEntry</strong>同HashMap中的Entry，每个HashEntry是一个节点，保存key和value，以及下一个节点。HashEntry中的key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型，可见HashEntry类的value是可变的，其他的key和next都是不可变的。<br>EntryIterator，EntrySet，HashIterator，KeyIterator，KeySet，ValueIterator，Values是辅助ConcurrentHashMap实现遍历的内部类。<br>下面简单介绍下<strong>Segment</strong>和<strong>HashEntry</strong>类。<br><strong>HashEntry</strong><br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> HashEntry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">volatile</span> V value;</span><br><span class="line">        <span class="keyword">final</span> HashEntry&lt;K,V&gt; <span class="keyword">next</span>;</span><br><span class="line"></span><br><span class="line">        HashEntry(K key, <span class="keyword">int</span> hash, HashEntry&lt;K,V&gt; <span class="keyword">next</span>, V value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">next</span> = <span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		@SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; HashEntry&lt;K,V&gt;[] newArray(<span class="keyword">int</span> i) &#123;</span><br><span class="line">		    <span class="keyword">return</span> <span class="keyword">new</span> HashEntry[i];</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>HashEntry类的结构很简单，就是四个变量，一个构造函数，一个static方法。由于没有任何getter和setter方法，所以对其操作是直接访问变量。在 ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。所以链表中节点的顺序和插入的顺序相反。<br><strong>Segment</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ReentrantLock</span> <span class="title">implements</span> <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></p>
<p>Segment继承自ReentrantLock ，所以它可以作为一个锁使用，其在ConcurrentHashMap也正是作为一个锁来使用的。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> <span class="keyword">count</span>;<span class="comment">//Segment中保存的元素数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;<span class="comment">//记录Segment被修改的次数，用于在读取时判断读取期间改Segment是否有过修改，有的话则重试</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> threshold;<span class="comment">//阀值，元素数量达到该值则会进行自动扩展</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;<span class="comment">//桶，一个HashEntry的数组，按HashCode值散列保存，采用链表解决hash碰撞问题</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;<span class="comment">//负载因子</span></span><br></pre></td></tr></table></figure>
<p><strong>count </strong>变量是一个计数器，它表示每个 Segment 对象管理的 table 数组（若干个 HashEntry 组成的链表）包含的 HashEntry 对象的个数。每一个 Segment 对象都有一个 count 对象来表示本 Segment 中包含的 HashEntry 对象的总数。注意，之所以在每个 Segment 对象中包含一个计数器，而不是在 ConcurrentHashMap 中使用全局的计数器，是为了避免出现“热点域”而影响 ConcurrentHashMap 的并发性。<br><img src="http://img.blog.csdn.net/20151012120235225" alt="Segment结构"><br>从Segment拥有的方法可以看出，针对ConcurrentHashMap的操作基本上都会调用具体某个Segment的对应方法，如put会调用Segment的put方法。所以Segment是最终的操作类。</p>
<p>下图是依次插入 ABC 三个 HashEntry 节点后，Segment 的结构示意图。<br><img src="http://img.blog.csdn.net/20151012120621035" alt="插入三个节点后 Segment 的结构示意图"><br>Segment的方法会在介绍ConcurrentHashMap的方法时进行解释，这里先不介绍。</p>
<h4 id="构造器解读"><strong>构造器解读</strong></h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上的构造器都只是一个个重载函数，最终都会调用下面的构造器。其中使用到了三个常量：</p>
<ul>
<li>DEFAULT_INITIAL_CAPACITY：默认初始容量</li>
<li>DEFAULT_LOAD_FACTOR：默认加载因子</li>
<li>DEFAULT_CONCURRENCY_LEVEL：默认并发级别，该值决定一个包含多少个Segment，即将ConcurrentHashMap切分成多少块</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span><br><span class="line">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">        <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">            ++sshift;</span><br><span class="line">            ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">        segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.segments = Segment.newArray(ssize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">            ++c;</span><br><span class="line">        <span class="keyword">int</span> cap = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i)</span><br><span class="line">            <span class="keyword">this</span>.segments[i] = <span class="keyword">new</span> Segment&lt;K,V&gt;(cap, loadFactor);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该构造函数需要制定初始容量、加载因子以及并发级别，对应上面提到的三个常量（默认值）。代码前几句是对参数进行正确性校验。<strong>// Find power-of-two sizes best matching arguments</strong>这句注释的意思是寻找一个参数的最佳匹配值：最接近指定的参数的2的幂方值。下面我们对照着代码来说明这句话的含义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个ssize变量，该变量就是concurrencyLevel的最佳匹配值，可以看见首先是循环，直到ssize&gt;=concurrencyLevel，所以最佳匹配值是大于等于指定参数的，循环里面每次会将ssize右移一位，即*2，所以最终得到的值就是一个最接近且大于等于concurrencyLevel的2次幂方值。同时定义了一个sshift变量，该变量随着ssize的每次右移而+1，最终得到的即是ssize是2的多少次方，即sszie=2^sshift。继续往下看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">segmentShift = <span class="number">32</span> - sshift;<span class="comment">//偏移量</span></span><br><span class="line">segmentMask = ssize - <span class="number">1</span>;<span class="comment">//掩码值</span></span><br><span class="line"><span class="keyword">this</span>.segments = Segment.newArray(ssize);<span class="comment">//初始化segments数组</span></span><br></pre></td></tr></table></figure>
<p>segmentShift以及segmentMask在后面将一个hash映射到某一个segments时使用，目的是将hash均匀的分配到每个segments，具体为什么使用这两个来进行均匀分配我们这里不介绍。最后一句是初始化一个segments数组，大小是ssize，而非参数concurrencyLevel值。下面继续看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"><span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">    ++c;</span><br><span class="line"><span class="keyword">int</span> cap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">    cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i)</span><br><span class="line">    <span class="keyword">this</span>.segments[i] = <span class="keyword">new</span> Segment&lt;K,V&gt;(cap, loadFactor);</span><br></pre></td></tr></table></figure>
<p>initialCapacity是构造器指定的初始化容量，ssize是segments数组大小，所以c的值就是每个segments的容量。下面定义了一个cap，这里的cap和前面的ssize是一个含义，即选择一个最接近且大于等于c的2的幂方值，然后初始化segments数组，传入的参数有cap（segment容量）和loadFactor（负载因子）。这里选择cap作为segment容量，而非c，是出于方便后期对segment的容量进行扩充考虑，如果容量是2的幂方，那么想要将容量扩充一倍只需右移1位即可，同时保证依旧是2的幂方。<br>对于segment的初始化很简单，对loadFactor赋值，然后根据指定的初始容量创建一个HashEntry数组，并计算出threshold（阀值，当segment中的元素超过这个阈值则进行容量扩充）。</p>
<h4 id="常用方法解读"><strong>常用方法解读</strong></h4><p>ConcurrentHashMap实现了Map接口，那么他的核心方法包括我们常用的put(K, V)、get(Object)、remove(Object)、contains(Object)、size()，同时继承自ConcurrentMap让他包含了putIfAbsent(K, V)、remove(Object, Object)、replace(K, V, V)、replace(K, V)四个并发方法。后面的四个并发方法是ConcurrentMap为我们提供的在并发情景下使用的工具方法，都是基于CAS来实现的。<br>在看put(K, V)、get(Object)等方法实现之前，先来看下这两个方法：hash(int)和segmentFor(int)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* ---------------- Small Utilities -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Applies a supplemental hash function to a given hashCode, which</span><br><span class="line"> * defends against poor quality hash functions.  This is critical</span><br><span class="line"> * because ConcurrentHashMap uses power-of-two length hash tables,</span><br><span class="line"> * that otherwise encounter collisions for hashCodes that do not</span><br><span class="line"> * differ in lower or upper bits.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Spread bits to regularize both segment and index locations,</span></span><br><span class="line">    <span class="comment">// using variant of single-word Wang/Jenkins hash.</span></span><br><span class="line">    h += (h &lt;&lt;  <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt;   <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt;  <span class="number">6</span>);</span><br><span class="line">    h += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns the segment that should be used for key with given hash</span><br><span class="line"> * @param hash the hash code for the key</span><br><span class="line"> * @return the segment</span><br><span class="line"> */</span></span><br><span class="line">final Segment&lt;K,V&gt; segmentFor(<span class="keyword">int</span> hash) &#123;</span><br><span class="line">    <span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码中对这两个方法的注释是：Small Utilities，即小工具方法。源码中对于hash方法的注释的意思是：该方法是一个补充hash方法，ConcurrentHashMap的hash表的长度是2的幂方，使用该补充hash函数可降低一些质量差的hash函数发生的碰撞概率。具体如何实现的就不看了，就算看懂了代码也很难理解这样做的原因，所以不浪费时间。segmentFor是为一个hash值找到它应该去的segment，这里使用到了segmentShift以及segmentMask，还记得segmentShift是32-sshift，这里将hash值无符号左移segmentShift位，即取hash值的高sshift位，然后同segmentMask按位与运算。其实就是取hash值的高sshift位将值限制在0~ssize之间，然后与ssize-1取余得到segments数组的下标（取高位是因为更加均匀，低位的重复率比高位高，臆测~！！！）。<br>了解了上面两个方法，下面我们就来看看put(K, V)、get(Object)、remove(Object)这三个方法的具体实现。</p>
<h5 id="put(K,_V)"><strong>put(K, V)</strong></h5><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="keyword">return</span> segmentFor(hash).put(key, hash, <span class="keyword">value</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap的put方法内部只是根据key的hash值找到对应的Segement，然后调用Segement的put方法，注意Segement的put方法的第四个参数，这里穿的值是false。我们主要分析下Segement的put方法。Segement在这里的作用就是将元素均匀分成N等份，各个Segement之间互不干扰，读写也不会发生冲突，降低并发要求。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">put</span>(<span class="params">K key, <span class="keyword">int</span> hash, V <span class="keyword">value</span>, boolean onlyIfAbsent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> c = count;</span><br><span class="line">        <span class="keyword">if</span> (c++ &gt; threshold) <span class="comment">// ensure capacity</span></span><br><span class="line">            rehash();</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        HashEntry&lt;K,V&gt; first = tab[index];</span><br><span class="line">        HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key)))</span><br><span class="line">            e = e.next;</span><br><span class="line"></span><br><span class="line">        V oldValue;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldValue = e.<span class="keyword">value</span>;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                e.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            oldValue = <span class="keyword">null</span>;</span><br><span class="line">            ++modCount;</span><br><span class="line">            tab[index] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(key, hash, first, <span class="keyword">value</span>);</span><br><span class="line">            count = c; <span class="comment">// write-volatile</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先第一步就是lock，看来再NB的并发类在写时也需要lock啊。读取count值，从count的注释可以看出该值是记录Segment包含的元素数量，volatile修饰的（这里利用了volatile变量的内存可见性）。然后判断增加之后元素数量是否超过阈值，超过的话提前扩容。接着找到该hash对应的table（桶），简单的取余操作。找到该table的第一个元素——first，因为ConcurrentHashMap使用链表来解决hash冲突问题，所以这里的table是一个链表。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">e</span> != null &amp;&amp; (<span class="keyword">e</span>.hash != hash || !key.equals(<span class="keyword">e</span>.key)))</span><br><span class="line">      <span class="keyword">e</span> = <span class="keyword">e</span>.next;</span><br></pre></td></tr></table></figure>
<p>通过循环，并通过比较hash值以及equals()校验，寻找与key相同的已存在的元素。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">V oldValue;</span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">    oldValue = e.<span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">        e.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    oldValue = <span class="keyword">null</span>;</span><br><span class="line">    ++modCount;</span><br><span class="line">    tab[index] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(key, hash, first, <span class="keyword">value</span>);</span><br><span class="line">    count = c; <span class="comment">// write-volatile</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>e!=null说明找到与要插入的元素key相同的元素，那么onlyIfAbsent=false则直接将原元素的value值替换，返回原值，由于HashEntry的value是volatile的，所以修改之后会立即被后续线程可见；onlyIfAbsent=true则不做任何操作。e==null时，modCount自增（modCount记录了对该Segment的进行的结构性修改的次数，modCount值使得在进行批量读取时能够知道在读取期间Segment结构是否被修改来决定是否进行加锁读取）。<strong>tab[index] = new HashEntry(key, hash, first, value)</strong>这句就是将被插入的元素添加到链表中，但是插入的位置是头部，而非尾部。HashEntry的构造器传入一个HashEntry对象，该对象是链表原来的头部，被作为新创建的节点的next指针，所以新的链表的头部元素是新增加的，后面接着是原来的链表。<br>注意：此处的lock并非对整个Map进行加锁，而只是对该Segment进行加锁，所以如果一个线程进行put操作，其他的另外15个（ssize-1）Segment仍是可访问的。</p>
<h5 id="remove(Object)"><strong>remove(Object)</strong></h5><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public V remove(Object <span class="built_in">key</span>) &#123;</span><br><span class="line">	<span class="typename">int</span> hash = hash(<span class="built_in">key</span>.hashCode());</span><br><span class="line">    return segmentFor(hash).remove(<span class="built_in">key</span>, hash, <span class="built_in">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Remove; match on <span class="built_in">key</span> only if <span class="built_in">value</span> <span class="built_in">null</span>, else match both.</span><br><span class="line"> */</span><br><span class="line">V remove(Object <span class="built_in">key</span>, <span class="typename">int</span> hash, Object <span class="built_in">value</span>) &#123;</span><br><span class="line">	<span class="comment">//由于remove是结构性修改，所以第一步便是lock</span></span><br><span class="line">    lock();</span><br><span class="line">    try &#123;</span><br><span class="line">	    <span class="comment">//读取count值，此处是利用volatile变量的内存可见性来保证读线程能够及时的读取到最新值(后面会单独介绍)</span></span><br><span class="line">        <span class="typename">int</span> c = <span class="built_in">count</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//是根据key的hashCode找到该节点对应的桶</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="typename">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        HashEntry&lt;K,V&gt; <span class="built_in">first</span> = tab[index];</span><br><span class="line">        HashEntry&lt;K,V&gt; e = <span class="built_in">first</span>;</span><br><span class="line">        <span class="comment">//循环找到该节点</span></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="built_in">null</span> &amp;&amp; (e.hash != hash || !<span class="built_in">key</span>.equals(e.<span class="built_in">key</span>)))</span><br><span class="line">            e = e.<span class="built_in">next</span>;</span><br><span class="line"></span><br><span class="line">        V oldValue = <span class="built_in">null</span>;</span><br><span class="line">        if (e != <span class="built_in">null</span>) &#123;</span><br><span class="line">        <span class="comment">//找到待删除节点</span></span><br><span class="line">            V v = e.<span class="built_in">value</span>;</span><br><span class="line">            <span class="comment">//如果value==null，则无需关心节点的值是否与指定值相同，否则只有在两者相同情况才可删除</span></span><br><span class="line">            if (<span class="built_in">value</span> == <span class="built_in">null</span> || <span class="built_in">value</span>.equals(v)) &#123;</span><br><span class="line">                oldValue = v;</span><br><span class="line">                <span class="comment">// All entries following removed node can stay</span></span><br><span class="line">                <span class="comment">// in list, but all preceding ones need to be</span></span><br><span class="line">                <span class="comment">// cloned.</span></span><br><span class="line">                ++modCount;</span><br><span class="line">                HashEntry&lt;K,V&gt; newFirst = e.<span class="built_in">next</span>;</span><br><span class="line">                for (HashEntry&lt;K,V&gt; p = <span class="built_in">first</span>; p != e; p = p.<span class="built_in">next</span>)</span><br><span class="line">                    newFirst = new HashEntry&lt;K,V&gt;(p.<span class="built_in">key</span>, p.hash,</span><br><span class="line">                                                  newFirst, p.<span class="built_in">value</span>);</span><br><span class="line">                tab[index] = newFirst;</span><br><span class="line">                <span class="built_in">count</span> = c; <span class="comment">// write-volatile</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依旧调用的是对应的Segment的remove()方法。由于remove是结构性修改，所以需要进行加锁操作。在删除一个节点时，为了不影响正在遍历链表的线程，这里采用了复制方式，而非直接移除待删除节点。具体工作方式：将待删除节点之后的节点不动，而待删除节点之后的节点复制到另外一个链表，看代码：<code>HashEntry&lt;K,V&gt; newFirst = e.next;</code>这句将待删除节点的next节点赋值给newFirst <code>for (HashEntry&lt;K,V&gt; p = first; p != e; p = p.next)</code>此处的for循环从链表的头部开始一直循环到待删除节点为止，<code>newFirst = new HashEntry&lt;K,V&gt;(p.key, p.hash, newFirst, p.value);</code>for循环内部根据当前循环的节点新建了一个key和value、hash都相同的节点，不同的是next指向了前一个新建的节点（第一个newFirst是待删除节点的下一个节点），即构成了一个以待删除节点的前一个节点为头结点的新的链表，然后<code>tab[index] = newFirst;</code>将该链表赋到对应的桶上，便完成了整个删除操作，最终新的链表以待删除节点的前一个节点为头结点。<br>下面通过图例来说明 remove 操作。假设写线程执行 remove 操作，要删除链表的 C 节点，另一个读线程同时正在遍历这个链表。<br><strong>执行删除之前的原链表：</strong><br><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blogJDK并发工具类源码学习系列——ConcurrentHashMap_图4.jpg" alt="执行删除之前的原链表"><br><strong>执行删除之后的新链表：</strong><br><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blogJDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentHashMap_%E5%9B%BE5.jpg" alt="执行删除之后的新链表"><br>从图中可以看出被删除节点之后的节点原封不动保留在链表中，而之前的链表从后往前依次被复制到新的链表中，但是原链表在我们进行remove操作过程中始终是会发生任何变化的，所以写线程对某个链表进行remove操作不会影响其他的并发读线程对这个链表的遍历访问。</p>
<h5 id="get(Object)"><strong>get(Object)</strong></h5><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="variable">key</span>) &#123;</span><br><span class="line">    <span class="built_in">int</span> hash = hash(<span class="variable">key</span>.hashCode());</span><br><span class="line">    <span class="keyword">return</span> segmentFor(hash).<span class="built_in">get</span>(<span class="variable">key</span>, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap的get()方法同put()一样，也是依赖于Segment的get()方法。下面看看Segment的get()方法</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">V <span class="literal">get</span>(Object key, int hash) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">count</span> != 0) &#123; <span class="comment">// read-volatile</span></span><br><span class="line">        HashEntry&lt;K,V&gt; <span class="keyword">e</span> = getFirst(hash);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">e</span> != null) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">e</span>.hash == hash &amp;&amp; key.equals(<span class="keyword">e</span>.key)) &#123;</span><br><span class="line">                V v = <span class="keyword">e</span>.value;</span><br><span class="line">                <span class="keyword">if</span> (v != null)</span><br><span class="line">                    <span class="keyword">return</span> v;</span><br><span class="line">                <span class="keyword">return</span> readValueUnderLock(<span class="keyword">e</span>); <span class="comment">// recheck</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">e</span> = <span class="keyword">e</span>.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span><br><span class="line"> * Returns properly casted first entry of bin for given hash.</span><br><span class="line">  */</span></span><br><span class="line"> HashEntry&lt;K,V&gt; getFirst(int hash) &#123;</span><br><span class="line">     HashEntry&lt;K,V&gt;[] <span class="keyword">tab</span> = <span class="keyword">table</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">tab</span>[hash &amp; (<span class="keyword">tab</span>.length - 1)];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Reads value field of an entry under lock. Called if value</span><br><span class="line"> * field ever appears to be null. This is possible only if a</span><br><span class="line"> * compiler happens to reorder a HashEntry initialization with</span><br><span class="line"> * its table assignment, which is legal under memory model</span><br><span class="line"> * but is not known to ever occur.</span><br><span class="line"> */</span></span><br><span class="line">V readValueUnderLock(HashEntry&lt;K,V&gt; <span class="keyword">e</span>) &#123;</span><br><span class="line">    lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">e</span>.value;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码可以看到get()方法在读取时无需进行加锁操作，除非读取到的值为NULL。为什么读取一个节点的值为NULL的时候需要加锁呢？因为ConcurrentHashMap是不允许NULL作为key或者value的，所以是不应该出现读取一个节点的值为NULL的情况，如果出现这种情况，说明出现了并发问题，所以加上锁再次读取！(什么情况下会出现这种情况并不清楚)。</p>
<h5 id="总结"><strong>总结</strong></h5><p>ConcurrentHashMap在进行结构性修改，如put/remove/replace时都需要进行加锁，但是读取并未加锁，并发情况下，由于内存不同步问题，会导致一个线程的写操作并不会立即对另一个线程可见。这里ConcurrentHashMap通过volatile变量的内存可见性特性来保证一个线程的写操作立即被其他线程可见，每个方法在一开始都会读取count这个变量，该变量就是一个volatile变量，多个线程之间通过读写这个变量来保证内存可见性，具体可参考下方的关于JVM内存可见性的说明。<br>上面三个方法基本包含了整个ConcurrentHashMap的读写操作（replace(K, V)方法只是简单的更新节点的value值，由于value是volatile的，所以也不会影响读线程），从三个方法的分析来看ConcurrentHashMap首先通过Segment对整个数据集进行切分，并通过对各个部分的数据集进行加锁来提高整个数据集的并发性；通过读写分离的方式实现无锁读，加锁写，进一步提高ConcurrentHashMap的读写效率；并通过volatile变量的特性实现读写的可见性保证。</p>
<h4 id="使用场景"><strong>使用场景</strong></h4><p>ConcurrentHashMap由于其即使在同步的情况下依旧保证高效的读写性能，所以在很多需要使用HashMap的情况都适用，当然单线程情况并不需要使用同步的ConcurrentHashMap。如果无法保证你的HashMap只是在单线程情况下使用那么就使用ConcurrentHashMap，因为其在单线程情况下的效率也并不低。<br>下面是针对单线程环境下ConcurrentHashMap和HashMap的put性能的对比：<br>硬件PC：普通PC机，i5<br>JVM：内存1G<br>测试数据：执行10次，计算均值<br>结果：表格</p>
<table>
<thead>
<tr>
<th>Map</th>
<th style="text-align:center">PUT1W次</th>
<th style="text-align:right">PUT10W次</th>
<th style="text-align:right">PUT100W次</th>
</tr>
</thead>
<tbody>
<tr>
<td>ConcurrentHashMap</td>
<td style="text-align:center">2175317</td>
<td style="text-align:right">28068193</td>
<td style="text-align:right">1355076232</td>
</tr>
<tr>
<td>HashMap</td>
<td style="text-align:center">1201131</td>
<td style="text-align:right">28068193</td>
<td style="text-align:right">407341713</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="Java_内存模型"><strong>Java 内存模型</strong></h4><p>由于 ConcurrentHashMap 是建立在 Java 内存模型基础上的，为了更好的理解 ConcurrentHashMap，让我们首先来了解一下 Java 的内存模型。<br>Java 语言的内存模型由一些规则组成，这些规则确定线程对内存的访问如何排序以及何时可以确保它们对线程是可见的。下面我们将分别介绍 Java 内存模型的重排序，内存可见性和 happens-before 关系。</p>
<h5 id="重排序"><strong>重排序</strong></h5><p>内存模型描述了程序的可能行为。具体的编译器实现可以产生任意它喜欢的代码 – 只要所有执行这些代码产生的结果，能够和内存模型预测的结果保持一致。这为编译器实现者提供了很大的自由，包括操作的重排序。<br>编译器生成指令的次序，可以不同于源代码所暗示的“显然”版本。重排序后的指令，对于优化执行以及成熟的全局寄存器分配算法的使用，都是大有脾益的，它使得程序在计算性能上有了很大的提升。<br>重排序类型包括：</p>
<ul>
<li>编译器生成指令的次序，可以不同于源代码所暗示的“显然”版本。</li>
<li>处理器可以乱序或者并行的执行指令。</li>
<li>缓存会改变写入提交到主内存的变量的次序。<h5 id="内存可见性"><strong>内存可见性</strong></h5>由于现代可共享内存的多处理器架构可能导致一个线程无法马上（甚至永远）看到另一个线程操作产生的结果。所以 Java 内存模型规定了 JVM 的一种最小保证：什么时候写入一个变量对其他线程可见。<br>在现代可共享内存的多处理器体系结构中每个处理器都有自己的缓存，并周期性的与主内存协调一致。假设线程 A 写入一个变量值 V，随后另一个线程 B 读取变量 V 的值，在下列情况下，线程 B 读取的值可能不是线程 A 写入的最新值：</li>
<li>执行线程 A 的处理器把变量 V 缓存到寄存器中。</li>
<li>执行线程 A 的处理器把变量 V 缓存到自己的缓存中，但还没有同步刷新到主内存中去。</li>
<li>执行线程 B 的处理器的缓存中有变量 V 的旧值。<h5 id="Happens-before_关系"><strong>Happens-before 关系</strong></h5>happens-before 关系保证：如果线程 A 与线程 B 满足 happens-before 关系，则线程 A 执行动作的结果对于线程 B 是可见的。如果两个操作未按 happens-before 排序，JVM 将可以对他们任意重排序。<br>下面介绍几个与理解 ConcurrentHashMap 有关的 happens-before 关系法则：</li>
</ul>
<ol>
<li>程序次序法则：如果在程序中，所有动作 A 出现在动作 B 之前，则线程中的每动作 A 都 happens-before 于该线程中的每一个动作 B。</li>
<li>监视器锁法则：对一个监视器的解锁 happens-before 于每个后续对同一监视器的加锁。</li>
<li>Volatile 变量法则：对 Volatile 域的写入操作 happens-before 于每个后续对同一 Volatile 的读操作。</li>
<li>传递性：如果 A happens-before 于 B，且 B happens-before C，则 A happens-before C。</li>
</ol>
<p>以上摘自<a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/" target="_blank" rel="external">探索 ConcurrentHashMap 高并发性的实现机制</a></p>
<hr>
<h4 id="参考文章"><strong>参考文章</strong></h4><p>1.<a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/" target="_blank" rel="external">探索 ConcurrentHashMap 高并发性的实现机制</a><br>2.<a href="http://www.infoq.com/cn/articles/ConcurrentHashMap" target="_blank" rel="external">聊聊并发（四）——深入分析ConcurrentHashMap</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ConcurrentHashMap类在我的开发过程中经常被使用，个人觉得如果在共享一个Map时，如果无法判断是否需要加锁，那么就干脆直接使用ConcurrentHashMap，即能保证并发安全，同时性能也不会有太多下降，因为ConcurrentHashMap可实现无锁读，不过内存会占用的多些，但是并不明显，基本可以忽略。<br>]]>
    
    </summary>
    
      <category term="JDK" scheme="http://vickyqi.com/tags/JDK/"/>
    
      <category term="JUC" scheme="http://vickyqi.com/tags/JUC/"/>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="JDK源码" scheme="http://vickyqi.com/categories/Java/JDK%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JDK并发工具类源码学习系列——介绍]]></title>
    <link href="http://vickyqi.com/2015/10/24/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E4%BB%8B%E7%BB%8D/"/>
    <id>http://vickyqi.com/2015/10/24/JDK并发工具类源码学习系列——介绍/</id>
    <published>2015-10-24T12:32:11.000Z</published>
    <updated>2015-12-01T09:05:46.000Z</updated>
    <content type="html"><![CDATA[<p>JDK并发工具类是JDK1.5引入的一大重要的功能，集中在java.util.concurrent包下，java.util.concurrent包下还包括了java.util.concurrent.atomic以及java.util.concurrent.locks两个子包。java.util.concurrent包主要包含了并发集合类以及线程池和信号量三组重要工具类；java.util.concurrent.atomic包下是JDK提供的一组原子操作类；java.util.concurrent.locks包下是JDK提供的锁机制。本系列主要关注java.util.concurrent包下的并发集合类：</p>
<ul>
<li><a href="http://vickyqi.com/2015/10/26/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentHashMap/">ConcurrentHashMap</a></li>
<li><a href="http://vickyqi.com/2015/10/29/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentLinkedQueue/">ConcurrentLinkedQueue</a></li>
<li><a href="http://vickyqi.com/2015/11/13/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentSkipListMap/">ConcurrentSkipListMap</a></li>
<li><a href="http://vickyqi.com/2015/11/17/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94CopyOnWriteArrayList/">CopyOnWriteArrayList</a></li>
<li><a href="http://vickyqi.com/2015/11/23/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94LinkedBlockingQueue/">LinkedBlockingQueue</a></li>
<li><a href="http://vickyqi.com/2015/11/20/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94PriorityBlockingQueue/">PriorityBlockingQueue</a></li>
<li><a href="http://vickyqi.com/2015/11/30/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94SynchronousQueue/">SynchronousQueue</a></li>
</ul>
<p>以上暂定为本系列将要分析源码的类，每完成一篇会来更新一下链接，欢迎大家关注。</p>
<hr>
<p>2015.12.1更新：</p>
<p>今天以上所有的类的源码解析已全部完成，其中丢弃了一些简单的，以及冷门的集合类，但是常用的并发集合类应该都已经包含了。</p>
<p>后面会接着分析JDK的锁机制，欢迎大家继续关注~~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JDK并发工具类是JDK1.5引入的一大重要的功能，集中在java.util.concurrent包下，java.util.concurrent包下还包括了java.util.concurrent.atomic以及java.util.concurrent.locks两个子包]]>
    </summary>
    
      <category term="JDK" scheme="http://vickyqi.com/tags/JDK/"/>
    
      <category term="JUC" scheme="http://vickyqi.com/tags/JUC/"/>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="JDK源码" scheme="http://vickyqi.com/categories/Java/JDK%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[几种常用JSON库性能比较]]></title>
    <link href="http://vickyqi.com/2015/10/19/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8JSON%E5%BA%93%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"/>
    <id>http://vickyqi.com/2015/10/19/几种常用JSON库性能比较/</id>
    <published>2015-10-19T06:47:47.000Z</published>
    <updated>2015-11-01T08:11:06.000Z</updated>
    <content type="html"><![CDATA[<p>JSON不管是在Web开发还是服务器开发中是相当常见的数据传输格式，一般情况我们对于JSON解析构造的性能并不需要过于关心，除非是在性能要求比较高的系统。<br>目前对于Java开源的JSON类库有很多种，下面我们取三个常用的JSON库进行性能测试对比，同时根据测试结果分析如果根据实际应用场景选择最合适的JSON库。<br>四个JSON类库分别为：Gson，FastJson，Jackson，Json-lib。<br>简单介绍下四个类库的身份背景。</p>
<ul>
<li>Gson（项目地址：<a href="https://github.com/google/gson）" target="_blank" rel="external">https://github.com/google/gson）</a><ul>
<li>Gson是目前功能最全的Json解析神器，Gson当初是为因应Google公司内部需求而由Google自行研发而来，但自从在2008年五月公开发布第一版后已被许多公司或用户应用。Gson的应用主要为toJson与fromJson两个转换函数，无依赖，不需要例外额外的jar，能够直接跑在JDK上。而在使用这种对象转换之前需先创建好对象的类型以及其成员才能成功的将JSON字符串成功转换成相对应的对象。类里面只要有get和set方法，Gson完全可以将复杂类型的json到bean或bean到json的转换，是JSON解析的神器。</li>
</ul>
</li>
<li>FastJson（项目地址：<a href="https://github.com/alibaba/fastjson）" target="_blank" rel="external">https://github.com/alibaba/fastjson）</a><ul>
<li>Fastjson是一个Java语言编写的高性能的JSON处理器,由阿里巴巴公司开发。无依赖，不需要例外额外的jar，能够直接跑在JDK上。FastJson在复杂类型的Bean转换Json上会出现一些问题，可能会出现引用的类型，导致Json转换出错，需要制定引用。FastJson采用独创的算法，将parse的速度提升到极致，超过所有json库。</li>
</ul>
</li>
<li>Jackson（项目地址：<a href="https://github.com/FasterXML/jackson）" target="_blank" rel="external">https://github.com/FasterXML/jackson）</a><ul>
<li>相比json-lib框架，Jackson所依赖的jar包较少，简单易用并且性能也要相对高些。而且Jackson社区相对比较活跃，更新速度也比较快。Jackson对于复杂类型的json转换bean会出现问题，一些集合Map，List的转换出现问题。Jackson对于复杂类型的bean转换Json，转换的json格式不是标准的Json格式。</li>
</ul>
</li>
<li>Json-lib（项目地址：<a href="http://json-lib.sourceforge.net/index.html）" target="_blank" rel="external">http://json-lib.sourceforge.net/index.html）</a><ul>
<li>json-lib最开始的也是应用最广泛的json解析工具，json-lib 不好的地方确实是依赖于很多第三方包，包括commons-beanutils.jar，commons-collections-3.2.jar，commons-lang-2.6.jar，commons-logging-1.1.1.jar，ezmorph-1.0.6.jar，对于复杂类型的转换，json-lib对于json转换成bean还有缺陷，比如一个类里面会出现另一个类的list或者map集合，json-lib从json到bean的转换就会出现问题。json-lib在功能和性能上面都不能满足现在互联网化的需求。</li>
</ul>
</li>
</ul>
<p>选择一个合适的JSON库要从多个方面进行考虑：</p>
<ol>
<li>字符串解析成JSON性能</li>
<li>字符串解析成JavaBean性能</li>
<li>JavaBean构造JSON性能</li>
<li>集合构造JSON性能</li>
<li>易用性</li>
</ol>
<p>对于前四条其实都是从JSON的解析构造性能角度考虑，而最后一条则是考虑易用性，这点对于开发者来说其实也是需要考虑的一个问题，如果该库的API使用难度大，或者很复杂，那么不建议使用，毕竟JSON解析的性能差异并不大。下面的测试结果针对四个不同数量级的JSON字符串，以及分别测试上面提到的前四条性能，结果如下：<br><img src="http://img.blog.csdn.net/20150901164447842" alt="这里写图片描述"><br>Json-lib在数据量在10W时OOM了，内存开到1G都不行，所以直接Pass了。<br>从上面图表可以看到：</p>
<ol>
<li>字符串解析成JavaBean：当数据量较少时首选FastJson，数据量较大使用Jackson。但是Jackson无法堆一个对象集合进行解析，只能转成一个Map集合，这点Gson和FastJson处理的比较好。</li>
<li>字符串解析成JSON：当数据量较少时首选FastJson，数据量较大使用Jackson。</li>
<li>JavaBean构造JSON：当数据量较少时选择Gson，数据量较大可使用Jackson。</li>
<li>集合构造JSON：首先Jackson，其次Fastjson。</li>
</ol>
<p>上面是从性能角度分析四种JSON类库，从易用性角度来分析的话，FastJson的API设计的最简单，最方便使用，直接使用JSON的两个静态方法即可完成四种操作；而Gson和Jackson都需要new一个对象，虽然这个对象可以复用，但是在实际使用过程中还需要用一个全局变量来保存改变量，同时API设计的也不是很好理解，对于FastJson来说复杂的API是因为他支持流式解析，适合对JSON进行大量且复杂的操作，但是实际应用中对于JSON的操作都是简单的解析成JavaBean，然后JavaBean序列化成JSON字符串即可，复杂的操作很少。<br>下面从我自己实际的应用场景出发，考虑该如何选择合适的JSON类库。<br>应用场景：游戏服务器，基本是对客户端发送过来的JSON格式字符串解析成JavaBean，然后将封装好的指令转成JSON字符串返回给客户端，这里考虑到JavaBean转成JSON与集合转成JSON的性能差异，所以直接使用集合进行转成JSON，避免使用JavaBean。<br>考虑上述场景适合使用FastJson进行JSON字符串解析，Jackson将集合转成JSON格式字符串。<br>浅尝辄止，欢迎批评指出。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JSON不管是在Web开发还是服务器开发中是相当常见的数据传输格式，一般情况我们对于JSON解析构造的性能并不需要过于关心，除非是在性能要求比较高的系统。<br>目前对于Java开源的JSON类库有很多种，下面我们取三个常用的JSON库进行性能测试对比，同时根据测试结果分析]]>
    </summary>
    
      <category term="JSON" scheme="http://vickyqi.com/tags/JSON/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Apache Commons CLI开发命令行工具]]></title>
    <link href="http://vickyqi.com/2015/10/19/%E4%BD%BF%E7%94%A8Apache%20Commons%20CLI%E5%BC%80%E5%8F%91%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    <id>http://vickyqi.com/2015/10/19/使用Apache Commons CLI开发命令行工具/</id>
    <published>2015-10-19T06:47:47.000Z</published>
    <updated>2015-11-01T08:11:00.000Z</updated>
    <content type="html"><![CDATA[<p>工作两年多，从没遇到需要使用命令行那样的参数形式执行命令的需求，突然好奇想试试，于是找到了Apache Commons CLI，大致了解试用了下，挺简单的，总共也就那点东西。<br>Apache Commons CLI官网地址：(<a href="https://commons.apache.org/cli/download_cli.cgi" target="_blank" rel="external">https://commons.apache.org/cli/download_cli.cgi</a>)<br>使用Apache Commons CLI开发命令行工具分成三步：<br>1）定义CLI<br>2）解析CLI<br>3）处理CLI<br>首先我们参考官网给出的一个例子：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ant [options] [target [target2 [target3] ...]]</span><br><span class="line">  Options: </span><br><span class="line">  -<span class="operator"><span class="keyword">help</span>                  print this message</span><br><span class="line">  -projecthelp           print <span class="keyword">project</span> <span class="keyword">help</span> information</span><br><span class="line">  -<span class="keyword">version</span>               print the <span class="keyword">version</span> information <span class="keyword">and</span> <span class="keyword">exit</span></span><br><span class="line">  -quiet                 be extra quiet</span><br><span class="line">  -verbose               be extra verbose</span><br><span class="line">  -debug                 print debugging information</span><br><span class="line">  -emacs                 produce <span class="keyword">logging</span> information <span class="keyword">without</span> adornments</span><br><span class="line">  -<span class="keyword">logfile</span> &lt;<span class="keyword">file</span>&gt;        <span class="keyword">use</span> given <span class="keyword">file</span> <span class="keyword">for</span> <span class="keyword">log</span></span><br><span class="line">  -logger &lt;classname&gt;    the <span class="keyword">class</span> which <span class="keyword">is</span> <span class="keyword">to</span> perform <span class="keyword">logging</span></span><br><span class="line">  -listener &lt;classname&gt;  <span class="keyword">add</span> an <span class="keyword">instance</span> <span class="keyword">of</span> <span class="keyword">class</span> <span class="keyword">as</span> a <span class="keyword">project</span> listener</span><br><span class="line">  -buildfile &lt;<span class="keyword">file</span>&gt;      <span class="keyword">use</span> given buildfile</span><br><span class="line">  -<span class="keyword">D</span>&lt;property&gt;=&lt;<span class="keyword">value</span>&gt;   <span class="keyword">use</span> <span class="keyword">value</span> <span class="keyword">for</span> given property</span><br><span class="line">  -find &lt;<span class="keyword">file</span>&gt;           <span class="keyword">search</span> <span class="keyword">for</span> buildfile towards the root <span class="keyword">of</span> the</span><br><span class="line">                         filesystem <span class="keyword">and</span> <span class="keyword">use</span> it</span></span><br></pre></td></tr></table></figure></p>
<p>该例子是ant的命令，我们可以对照着进行开发（其实官网就有，英文好的可以直接移步<br>(<a href="https://commons.apache.org/proper/commons-cli/usage.html)）。" target="_blank" rel="external">https://commons.apache.org/proper/commons-cli/usage.html)）。</a></p>
<p>####定义CLI：<br>首先参照上面的三部曲，第一步定义CLI：<br>Apache Commons CLI使用Option表示每一个命令，使用Options封装多个Option，创建Option的方式有三种：</p>
<ol>
<li>Option op = new Option(…);//构造器</li>
<li>Options.addOption(…);//Options直接构造</li>
<li>Option.Builder辅助类<br>1.2适合简单的创建的命令，如上面logfile命令以上的命令。我们举几个例子：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Options ops = new Options();</span><br><span class="line">Option <span class="operator"><span class="keyword">help</span> = <span class="keyword">new</span> <span class="keyword">Option</span>( <span class="string">"help"</span>, <span class="string">"print this message"</span> );</span></span><br><span class="line">ops.addOption(<span class="operator"><span class="keyword">help</span>);</span></span><br><span class="line">ops.addOption("projecthelp", "print project <span class="operator"><span class="keyword">help</span> information<span class="string">");</span></span></span><br></pre></td></tr></table></figure>
<p>同时如果我们假设debug命令后可跟值true/false，那么我们可以这样定义命令：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ops.addOption(<span class="string">"debug"</span>, <span class="keyword">true</span>, <span class="string">"print debugging information"</span>); <span class="regexp">//</span>第二个参数<span class="keyword">true</span>表示该命令后可跟参数，其实就是命令后面跟上值</span><br></pre></td></tr></table></figure>
<p>下面我们看logfile以下除去<code>-D&lt;property&gt;=&lt;value&gt;</code> 之外的的命令如何创建，这里使用第三种方式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Option</span> logfile = <span class="built_in">Option</span>.builder(<span class="string">"logfile"</span>).argName(<span class="string">"file"</span>).hasArg().desc(<span class="string">"use given file for log"</span>).build();<span class="comment">// argName指定命令后跟的参数名称</span></span><br><span class="line">ops.addOption(logfile);</span><br></pre></td></tr></table></figure>
<p>最后我们看看如何定义<code>-D&lt;property&gt;=&lt;value&gt;</code>：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Option <span class="keyword">D</span> = Option.builder(<span class="string">"D"</span>).argName(<span class="string">"property=value"</span>).numberOfArgs(2).valueSeparator(<span class="string">"="</span>)</span><br><span class="line">				.<span class="keyword">desc</span>(<span class="string">"use value for given property"</span>).build();<span class="comment">// 这里numberOfArgs指定了后跟两个参数，且valueSeparator指定了连接符是=，这样CLI可以自动帮我们解析键值对</span></span><br><span class="line">ops.addOption(<span class="keyword">D</span>);</span><br></pre></td></tr></table></figure>
<h4 id="解析CLI：">解析CLI：</h4><p>以上全部定义好之后，就可以对传入的参数进行解析了。DefaultParser类是用来解析参数，得到每个命令以及对应的值，而且对于如上面的<code>-D&lt;property&gt;=&lt;value&gt;</code> 这种命令，由于我们制定了“=”为分隔符，DefaultParser可以自动为我们将参数解析成Properties，很方便。</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CommandLine comm = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	comm = <span class="keyword">new</span> DefaultParser().parse(ops, args);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">	<span class="built_in">log</span>.<span class="built_in">error</span>(<span class="string">"解析参数失败，参数：["</span> + Arrays.asList(args).toString() + <span class="string">"]"</span>);</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="处理CLI">处理CLI</h4><p>上面已经对传入的参数解析好了，剩下的就是获取到这些命令的值，以及进行相应的处理了，也就是我们的业务逻辑了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (comm.getOptions().length == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">log</span>.info(<span class="string">"No any param to specify."</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (comm.hasOption(<span class="string">"h"</span>)) &#123;<span class="comment">// help</span></span><br><span class="line">	HelpFormatter formatter = <span class="keyword">new</span> HelpFormatter();</span><br><span class="line">	formatter.printHelp(<span class="string">"options"</span>, ops);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (comm.hasOption(<span class="string">"s"</span>)) &#123;<span class="comment">// 执行命令</span></span><br><span class="line">	<span class="keyword">new</span> SystemCommand().execute(comm.getOptionValue(<span class="string">"s"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (comm.hasOption(<span class="string">"D"</span>)) &#123;<span class="comment">// 传递参数</span></span><br><span class="line">	Properties props = comm.getOptionProperties(<span class="string">"D"</span>);</span><br><span class="line">	<span class="keyword">new</span> ParamParser(props).parse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是一个简单的例子，这里有个getOptionProperties方法，这个方法是针对使用分隔符的命令方便获取键值对行为的属性值而设计的，很好用，免去了自己再做字符串切分的麻烦。<br>到这里整个使用Apache Commons CLI开发命令行工具的工作就完成了，很简单。</p>
<ul>
<li>Apache Commons CLI总共支持的几种命令模式：</li>
<li>POSIX like options (ie. tar -zxvf foo.tar.gz)</li>
<li>GNU like long options (ie. du –human-readable –max-depth=1)</li>
<li>Java like properties (ie. java -Djava.awt.headless=true -Djava.net.useSystemProxies=true Foo)</li>
<li>Short options with value attached (ie. gcc -O2 foo.c)</li>
<li>long options with single hyphen (ie. ant -projecthelp)</li>
</ul>
<p>对于GNU模式官网还有一个例子，可以自行参考下。<br>附上官网的一个Option的属性表：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th style="text-align:left">Type</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>opt</td>
<td style="text-align:left">java.lang.String</td>
<td style="text-align:left">the identification string of the Option.</td>
</tr>
<tr>
<td>longOpt</td>
<td style="text-align:left">java.lang.String</td>
<td style="text-align:left">an alias and more descriptive identification string.</td>
</tr>
<tr>
<td>description</td>
<td style="text-align:left">java.lang.String</td>
<td style="text-align:left">a description of the function of the option.</td>
</tr>
<tr>
<td>required</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">a flag to say whether the option must appear on the command line.</td>
</tr>
<tr>
<td>arg</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">a flag to say whether the option takes an argument.</td>
</tr>
<tr>
<td>args</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">a flag to say whether the option takes more than one argument.</td>
</tr>
<tr>
<td>optionalArg</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">a flag to say whether the option’s argument is optional.</td>
</tr>
<tr>
<td>argName</td>
<td style="text-align:left">java.lang.String</td>
<td style="text-align:left">the name of the argument value for the usage statement.</td>
</tr>
<tr>
<td>valueSeparator</td>
<td style="text-align:left">char</td>
<td style="text-align:left">the character value used to split the argument string, that is used in conjunction with multipleArgs e.g. if the separator is ‘,’ and the argument string is ‘a,b,c’ then there are three argument values, ‘a’, ‘b’ and ‘c’.</td>
</tr>
<tr>
<td>type</td>
<td style="text-align:left">java.lang.Object</td>
<td style="text-align:left">the type of the argument.</td>
</tr>
<tr>
<td>value</td>
<td style="text-align:left">java.lang.String</td>
<td style="text-align:left">the value of the option.</td>
</tr>
<tr>
<td>values</td>
<td style="text-align:left">java.lang.String[]</td>
<td style="text-align:left">the values of the option.</td>
</tr>
</tbody>
</table>
<p>参考文章：<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-commonscli/" target="_blank" rel="external">使用 Apache Commons CLI 开发命令行工具</a><br><a href="https://commons.apache.org/proper/commons-cli/project-info.html" target="_blank" rel="external">Apache Commons CLI</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>工作两年多，从没遇到需要使用命令行那样的参数形式执行命令的需求，突然好奇想试试，于是找到了Apache Commons CLI，大致了解试用了下，挺简单的，总共也就那点东西。<br>Apache Commons CLI官网地址：(<a href="https://commo]]>
    </summary>
    
      <category term="Cli" scheme="http://vickyqi.com/tags/Cli/"/>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="命令行" scheme="http://vickyqi.com/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解原码、反码、补码——深入理解补码]]></title>
    <link href="http://vickyqi.com/2015/10/19/%E8%AF%A6%E8%A7%A3%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%A1%A5%E7%A0%81/"/>
    <id>http://vickyqi.com/2015/10/19/详解原码、反码、补码——深入理解补码/</id>
    <published>2015-10-19T06:19:11.000Z</published>
    <updated>2015-10-20T03:39:34.000Z</updated>
    <content type="html"><![CDATA[<p>学过计算机原理的人都知道原码、反码、补码，但是有多少人知道为什么会有这三种码呢，这三种码又是用来干嘛的呢。<br>众所周知，在计算机的世界只有01，那么显然所有的数都得转成二进制，这样计算机才能够理解。如何将一个十进制的数转成二进制就不说了，说下原码，正数的原码就是十进制转成二进制得到的二进制值，而负数是对应的正数转成二进制得到的二进制值，然后将最高位（符号位）置为1表示这是一个负数，如-10:10001010。</p>
<h5 id="1-_原码"><strong>1. 原码</strong></h5><p>计算机进行算术运算时为了简单效率所以要求能够使用加法代替减法，如1-1==1+(-1)==0，那么我们先看看原码能不能实现这种需求。<br>示例：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">计算76-10==66</span><br><span class="line"><span class="code">   十进制     二进制</span></span><br><span class="line"><span class="code">   76        01001100</span></span><br><span class="line"><span class="header"> +  -10       10001010</span><br><span class="line">---------------------</span></span><br><span class="line"><span class="code">   66        11010110（-86）</span></span><br></pre></td></tr></table></figure></p>
<h5 id="2-_反码"><strong>2. 反码</strong></h5><p>从上面算出的结果可见原码是无法完成对减法的运算需求的，那么由于1-1==1+（-1），所以人类又找到了一个看似能够解决这个问题的解决方法——反码，即将负数的符号位不变其余位取反。下面我们再看看反码能不能解决问题。<br>示例1：计算15-125<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">计算<span class="number">15</span>-<span class="number">125</span>==-<span class="number">110</span></span><br><span class="line">   十进制     二进制原码    二进制反码</span><br><span class="line">   <span class="number">15</span>        <span class="number">00001111</span>    <span class="number">00001111</span></span><br><span class="line"> +  -<span class="number">125</span>      <span class="number">11111101</span>    <span class="number">10000010</span></span><br><span class="line">---------------------------------</span><br><span class="line">   -<span class="number">110</span>      <span class="number">11101110</span>    <span class="number">10010001</span></span><br><span class="line">得到<span class="number">10010001</span>(反码)==<span class="number">11101110</span>(原码)==-<span class="number">110</span>，正确。注意：使用反码计算得到的结果也是反码，需要再次转换成原码。</span><br></pre></td></tr></table></figure></p>
<p>示例2：计算76-10<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">计算<span class="number">76</span>-<span class="number">10</span>==<span class="number">66</span></span><br><span class="line">   十进制     二进制原码    二进制反码</span><br><span class="line">   <span class="number">76</span>        <span class="number">01001100</span>    <span class="number">01001100</span></span><br><span class="line"> + -<span class="number">10</span>       <span class="number">10001010</span>    <span class="number">11110101</span></span><br><span class="line">---------------------------------</span><br><span class="line">   <span class="number">66</span>        <span class="number">01000010</span>    <span class="number">101000001</span>==<span class="number">01000010</span>  </span><br><span class="line">这里得到的值超过<span class="number">8</span>bit，所以最高的<span class="number">1</span>需要丢弃，丢弃后需要在最低位+<span class="number">1</span>，得到<span class="number">01000010</span>(反码)==<span class="number">01000010</span>(原码)==<span class="number">66</span>，正确。</span><br></pre></td></tr></table></figure></p>
<p>示例3：计算1-1<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">计算<span class="number">1</span>-<span class="number">1</span>==<span class="number">0</span></span><br><span class="line">   十进制     二进制原码    二进制反码</span><br><span class="line">   <span class="number">1</span>         <span class="number">00000001</span>    <span class="number">00000001</span></span><br><span class="line"> + -<span class="number">1</span>        <span class="number">10000001</span>    <span class="number">11111110</span></span><br><span class="line">---------------------------------</span><br><span class="line">   <span class="number">0</span>         <span class="number">10000000</span>    <span class="number">11111111</span>  </span><br><span class="line">得到<span class="number">11111111</span>(反码)==<span class="number">10000000</span>(原码)==-<span class="number">0</span>，-<span class="number">0</span>？通过反码计算会出现+<span class="number">0</span>和-<span class="number">0</span>，一个<span class="number">0</span>对应了两个码，显然是不合理的。</span><br></pre></td></tr></table></figure></p>
<p>从上面三个例子可以看出使用反码进行减法运算时存在两个问题：</p>
<ol>
<li>当计算结果溢出时需要额外进行+1操作，使得运算多了一步，效率降低</li>
<li><p>0存在+0和-0两种存在方式，不方便理解</p>
<h5 id="3-_模与互补、同余"><strong>3. 模与互补、同余</strong></h5><p>在看补码之前，先介绍三个概念——模、补数、同余。我们从现实生活举例来看：</p>
<ul>
<li>我们将一个时钟的分针往前拨20分钟，和往后拨40分钟，得到的结果是一样的。</li>
<li>把你的属年(属猴)往后退5年，和往前进7年，一样都是属兔。</li>
<li>把数字 87，减去 25，和加上 75，在不考虑百位数的条件下，得到的结果都是62。</li>
</ul>
</li>
</ol>
<p>上述几组数字，有这样的关系：<br>　　20 + 40 = 60<br>　　5 + 7 = 12<br>　　25 + 75 = 100<br>式中的 60、12 和 100，就是“模”。<br>式中的 20和40、5和7，以及25和75，就是一对对“互补”的数字。<br>而且20，80，140在模是60的情况下就是互为“同余”的数字。<br>通俗解释下模、补数、同余的概念：</p>
<ul>
<li><strong>模</strong>：就是一个轮回，比如分针转一圈，十二生肖一轮等等。</li>
<li><strong>互补 </strong>：一个数值针对某个模的互补值就是这个数值加上或者减去多少能够等于模，或者等于模的同余值。</li>
<li><strong>同余 </strong>：一个数值加上或者减去模的整数倍得到的所有数值即为该数值的同余值<strong>(也就是除上模，余数是一样，所以叫同余)</strong>，0是模的同余，-模也是模的同余。</li>
</ul>
<p>理解了什么是模，什么是互补、什么是同余，那么如果给一个模，以及一个值a，如果计算a的补数(与a互补的值)呢，其实很简单，只需要拿模-a即可，计算同余值可以直接加上或者减去模的整数倍即可。</p>
<h5 id="4-_那么互补的值有什么用呢？"><strong>4. 那么互补的值有什么用呢？</strong></h5><p>如果我们在进行减法运算时，用与减数互补的值代替减数与被减数进行加法运算会发生什么呢？废话不多说，看示例。<br>示例1：在分钟刻度下，计算55分钟往后拨动34分钟，转化成数学计算就是：55-34<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">被减数	     <span class="number">55</span></span><br><span class="line">减数		  <span class="number">34</span></span><br><span class="line">减数补数   <span class="number">60</span>-<span class="number">34</span>==<span class="number">26</span></span><br><span class="line">最终结果     <span class="number">55</span>+<span class="number">26</span>==<span class="number">81</span></span><br><span class="line">---------------------</span><br><span class="line">用减数补数代替减数得到结果为<span class="number">81</span>,<span class="number">81</span>在分钟刻度盘上正好是<span class="number">21</span>，也就是<span class="number">81</span>是<span class="number">21</span>的同余值，和<span class="number">55</span>-<span class="number">34</span>是一样的。注意：这里涉及到类似上面的<span class="number">87</span>+<span class="number">75</span>的情况，即忽略了进位。</span><br></pre></td></tr></table></figure></p>
<p>示例2：在十二生肖中，计算猴年往后退11年，转化成数学计算就是：9-11<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">被减数	     <span class="number">9</span></span><br><span class="line">减数		  <span class="number">11</span></span><br><span class="line">减数补数   <span class="number">12</span>-<span class="number">11</span>==<span class="number">1</span></span><br><span class="line">最终结果     <span class="number">9</span>+<span class="number">1</span>==<span class="number">10</span></span><br><span class="line">-------------------</span><br><span class="line">用减数互补值代替减数得到结果为<span class="number">10</span>,<span class="number">10</span>对应到十二生肖正好是鸡，和猴年往后退<span class="number">11</span>年是一样的，所以得到的也是一个同余值。</span><br></pre></td></tr></table></figure></p>
<p>从上面的示例可以看出，使用互补值计算出的结果与实际值其实是<strong>同余</strong>的关系。</p>
<h5 id="5-_二进制的模"><strong>5. 二进制的模</strong></h5><p>上面看了分钟刻度盘的模，十二生肖的模，以及两位整数的模，那么对于一个8bit的字节的模是多少呢？<br>分钟刻度盘的模为什么是60？是因为他的值是从1-59，总共60个值，十二生肖以及两位整数也是一样的，所以我们只需要看看一个8bit的字节的所有取值一共是多少个就是他的模，显示8个bit可表示的最小值是00000000==0，最大值是11111111==255，那么从0到255一共是256个值，所以一个8bit的字节的模就是256了。但是其实在计算机中为了能够表示负数，所以讲8bit的字节的最高位设为符号位，0表示整数，1表示负数，所以能够表示数值的也就只有7bit，如果我们忽视符号位，那么剩下7bit的模就是128，而不是256了。<strong>下面在计算时我们会直接使用128而非256！</strong></p>
<h5 id="6-_使用互补值进行二进制的减法计算"><strong>6. 使用互补值进行二进制的减法计算</strong></h5><p>下面我们就来看看如果使用互补值来进行二进制的减法计算，我们先来看一个公式：假设模式M，我们计算X-Y，然后我们使用减数的补数来计算，看看下面的换算：</p>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">X</span>-<span class="keyword">Y</span> == <span class="keyword">X</span>+(M-<span class="keyword">Y</span>) == <span class="keyword">X</span>+((M-<span class="number">1</span>)-<span class="keyword">Y</span>+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>下面我们来看示例，这个公式在下面会用到的。</p>
<p>示例1：计算15-125<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">           十进制          二进制</span><br><span class="line">被减数	     <span class="number">15</span>             <span class="number">0001111</span></span><br><span class="line">减数		  <span class="number">125</span>            <span class="number">1111101</span></span><br><span class="line">减数补数   <span class="number">128</span>-<span class="number">125</span>==<span class="number">3</span>     <span class="number">0000011</span></span><br><span class="line">最终结果     <span class="number">18</span>             <span class="number">0010010</span></span><br><span class="line">------------------------------------</span><br><span class="line">得到<span class="number">0010010</span>==<span class="number">18</span>，在模式<span class="number">128</span>的情况下，<span class="number">18</span>正好是-<span class="number">110</span>的同余值，跟上面现实的例子是一样的！</span><br></pre></td></tr></table></figure></p>
<p>示例2：计算76-10<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">           十进制          二进制</span><br><span class="line">被减数	     <span class="number">76</span>             <span class="number">01001100</span></span><br><span class="line">减数		  <span class="number">10</span>            <span class="number">00001010</span></span><br><span class="line">减数补数   <span class="number">256</span>-<span class="number">10</span>==<span class="number">246</span>   <span class="number">11110110</span></span><br><span class="line">最终结果     <span class="number">322</span>    <span class="number">101000010</span></span><br><span class="line">------------------------------------</span><br><span class="line">得到<span class="number">101000010</span>==<span class="number">322</span>，在模式<span class="number">256</span>的情况下，<span class="number">322</span>正好是<span class="number">66</span>的同余值，结果还是一样！</span><br></pre></td></tr></table></figure></p>
<p>从上面两个例子我们应该可以看出，如果我们使用减数的补数进行加法运算，那么得到的结果就是一个与正确结果同余的值。在现实生活中，我们可以直接把两个同余的值看做是相同的，例如分钟20和分钟80完全就是一样的，那么在计算机里我们可以这么假设吗？答案是可以的，看下面。<br>试想当计算机使用一个7bit的空间保存一个数值时是如何保存的，比如18，我们可以这么推算，首先分配一个7bit的空间，每个bit上的值都是0，那么如何表示18呢？我们可以这样理解：往这个7bit的空间内进行18次加1操作，满2就进1，最终就会得到0010010。那么如何表示-110，我们可以理解为往这个7bit的空间内进行110次减1操作，一开始全是0，那么如何减1呢？很简单直接减成1111111即可，可以这样理解，分钟在0刻度，你往后拨一下就会指向59，这里也是这个道理，所以连续减110次，就会得到0010010，根18是一样的，所以在计算机看来18和-110是一样的。<br>也就是说<strong>15-125 == 15+(128-125) == 15+(127-125+1) </strong>(上面的公式)，也就是说-125被127-125+1代替了，那么<strong>127-125+1（M-）</strong>又是什么？</p>
<h5 id="7-_补码"><strong>7. 补码</strong></h5><p>上面一路走来终于证明了使用补数可以代替减法，下面我们要解决的问题是M-1-Y+1是啥。<br>我们直接看二进制如何计算M-1-Y+1。<br>示例：计算M=128，Y=110</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">     十进制   二进制</span><br><span class="line"> M-<span class="number">1</span>  <span class="number">127</span>   <span class="number">1111111</span></span><br><span class="line"> -Y   <span class="number">110</span>   <span class="number">1101110</span></span><br><span class="line">            <span class="number">0010001</span></span><br><span class="line">--------------------</span><br><span class="line">M-<span class="number">1</span>换算成二进制就是N位<span class="number">1</span>，那么N位<span class="number">1</span>减去任何一个N位的二进制是啥呢？其实就是按位取反！因为遇到<span class="number">0</span>,<span class="number">1</span>-<span class="number">0</span>==<span class="number">1</span>，取反，遇到<span class="number">1</span>,<span class="number">1</span>-<span class="number">1</span>==<span class="number">0</span>，取反，所以整体就是按位取反，也就是反码。</span><br><span class="line">            </span><br><span class="line"> +<span class="number">1</span>   <span class="number">1</span>     <span class="number">0000001</span></span><br><span class="line">            <span class="number">0010010</span></span><br><span class="line"> ------------------</span><br><span class="line">所以总体就是在<span class="number">110</span>的二进制基础上按位取反然后加<span class="number">1</span>,也就是<span class="number">110</span>的反码加<span class="number">1</span>。</span><br></pre></td></tr></table></figure>
<p>看了上面的示例，应该知道M=128，Y=110，M-1-Y+1就是Y的反码加1，也就是说，如果我们需要计算X-Y，只需要计算X+(Y的反码+1)，由于我们得出这个结论是使用<strong>补数替代减法</strong>得到的，所以<strong>Y的反码+1</strong>就被叫做Y的<strong>补码</strong>。<br>到这里我们知道了110的补码，上面我们介绍了计算机使用1字节的最高位表示符号位，1表示负数，所以-110的最高位是1，由于在使用补码进行减法运算过程中最高位并不参与运算，所以这个最高位应该是固定不动的，所以负数的反码补码最高位始终都是1。<strong>也就得到了-110的补码是：10010010</strong>。对于正数，符号位是0，那么反码补码最高位就始终是0，而且对于正数在计算时也无需使用其补码进行操作，但是为了统一都是用补码，所以定正数的反码补码都等于原码。<br>根据补码的计算过程有些文章会说一个负数X的补码对应的值==2^n-|X|，理解了上面的过程这个公式就自然懂了，不过这个公式没啥用，也没必要记。<br>到这里终于把<strong>补码</strong>的来历说清楚了，至少我自己是明白了，但愿读者也可以明白吧！</p>
<h5 id="一些补码的其他知识"><strong>一些补码的其他知识</strong></h5><p>上面我们看了7bit的模式128，也就说是能表示0-127共128个数值，加上最高位的符号位就成了-127-127共计255个数值，因为没有-0这个数字。但是实际对于计算机来说8bit的空间是可以表示256个数字的，那么还有一个数字是啥呢？正是：<strong>10000000</strong>(注意：这是补码，因为计算机都存的补码)。我们可以试着计算下10000000的原码，可以得到10000000的原码就是10000000，也就是-0，但是如果存在+0和-0两个计算机码对应一个值(+0和-0都是0)，那么显然是没必要的，而且还会造成混乱，所以人为的规定<strong>10000000表示-128</strong>。所以一个8bit的空间可以表示的数字就是从-128到127了，而不是-127-127！</p>
<h5 id="8-_参考文章"><strong>8. 参考文章</strong></h5><p>感谢下面这些文章帮助我理解补码：<br><a href="http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html" target="_blank" rel="external">原码, 反码, 补码 详解</a><br><a href="http://www.douban.com/note/223507364/" target="_blank" rel="external">原码、反码和补码</a></p>
<p>欢迎大家点评讨论！</p>
]]></content>
    <summary type="html">
    <![CDATA[介绍计算机中的原码、反码、补码]]>
    
    </summary>
    
      <category term="二进制" scheme="http://vickyqi.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="反码" scheme="http://vickyqi.com/tags/%E5%8F%8D%E7%A0%81/"/>
    
      <category term="补数" scheme="http://vickyqi.com/tags/%E8%A1%A5%E6%95%B0/"/>
    
      <category term="补码" scheme="http://vickyqi.com/tags/%E8%A1%A5%E7%A0%81/"/>
    
      <category term="计算机" scheme="http://vickyqi.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="计算机基础" scheme="http://vickyqi.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[正则学习二三事]]></title>
    <link href="http://vickyqi.com/2015/10/19/%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
    <id>http://vickyqi.com/2015/10/19/正则学习二三事/</id>
    <published>2015-10-19T06:19:11.000Z</published>
    <updated>2015-11-01T08:10:38.000Z</updated>
    <content type="html"><![CDATA[<p>正则一直是我一大痛点，一直都想解决这个问题，但是奈何每次看到那么多符号就发蒙，所以就一直拖下去了。直到最近总是被别人问到如何在hql中使用rlike查询符合特定规则的字段，然后各种不会，结果被鄙视的一塌糊涂，无奈，这才静下心来慢慢研究。<br>以前看正则就是一堆符号，代表各个意思，如\d表示数字，\d+表示一个或者多个连续数字，单看每个规则都可以理解，除了组合，但是实际使用时真的很难组织到一起。归根结底还是因为对这些符号的理解不够深入。所以正则还是得多写，推荐一个在线练习的网站<a href="http://regex.alf.nu/" target="_blank" rel="external">RegexGolf</a>。好了，下面写写自己学习正则的一些总结吧，希望能够帮助到别人，也帮助自己总结总结。</p>
<h4 id="正则的基础知识："><strong>正则的基础知识：</strong></h4><h5 id="字面值"><strong>字面值</strong></h5><p>正则表达式由只代表自身的字面值和代表特定含义的元字符组成。 只代表自身的字面值指的是普通的字符，如abcde，特殊含义的元字符包括：</p>
<table>
<thead>
<tr>
<th></th>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>\</td>
<td>反斜线字符</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\0n</td>
<td>带有八进制值 0 的字符 n (0 &lt;= n &lt;= 7)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\0nn</td>
<td>带有八进制值 0 的字符 nn (0 &lt;= n &lt;= 7)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\0mnn</td>
<td>带有八进制值 0 的字符 mnn（0 &lt;= m &lt;= 3、0 &lt;= n &lt;= 7）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\xhh</td>
<td>带有十六进制值 0x 的字符 hh</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\uhhhh</td>
<td>带有十六进制值 0x 的字符 hhhh</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\t</td>
<td>制表符 (‘\u0009’)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\n</td>
<td>新行（换行）符 (‘\u000A’)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\r</td>
<td>回车符 (‘\u000D’)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\f</td>
<td>换页符 (‘\u000C’)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\a</td>
<td>报警 (bell) 符 (‘\u0007’)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\e</td>
<td>转义符 (‘\u001B’)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\cx</td>
<td>对应于 x 的控制符</td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="字符类"><strong>字符类</strong></h5><p> 字符类是字符在方括号中的集合。表示“找到集合里任意一个字符“。例如：</p>
<table>
<thead>
<tr>
<th></th>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>[abc]</td>
<td>a、b 或 c（简单类）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>[^abc]</td>
<td>任何字符，除了 a、b 或 c（否定）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>[a-zA-Z]</td>
<td>a 到 z 或 A 到 Z，两头的字母包括在内（范围）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>[a-d[m-p]]</td>
<td>a 到 d 或 m 到 p：[a-dm-p]（并集）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>[a-z&amp;&amp;[def]]</td>
<td>d、e 或 f（交集）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>[a-z&amp;&amp;[^bc]]</td>
<td>a 到 z，除了 b 和 c：[ad-z]（减去）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>[a-z&amp;&amp;[^m-p]]</td>
<td>a 到 z，而非 m 到 p：[a-lq-z]（减去）</td>
<td></td>
</tr>
</tbody>
</table>
<p>从上表可以看出<strong>[]</strong>里面可进行并集/交集/差集操作。对于字符范围是根据ASCII值的大小来的，例如[A-z]也是可以的，甚至能够匹配[，但是完全不建议如此使用，推荐使用的字符范围：[0-9]/[a-z]/[A-Z]。<br>字符类还有一些预定义的字符类：</p>
<table>
<thead>
<tr>
<th></th>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>. 任何字符（与行结束符可能匹配也可能不匹配）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\d</td>
<td>数字：[0-9]</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\D</td>
<td>非数字： [^0-9]</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\s</td>
<td>空白字符：[ \t\n\x0B\f\r]</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\S</td>
<td>非空白字符：[^\s]</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\w</td>
<td>单词字符：[a-zA-Z_0-9]</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\W</td>
<td>非单词字符：[^\w]</td>
<td></td>
</tr>
</tbody>
</table>
<p>使用上面的预定义字符类能够更加方便的表示字符范围。需要牢记。<br><strong>注意</strong>： 区间是字符的区间，不是数字的区间。正则表达式[1-31]表示“找到一个1或一个2或一个3”，不是“找到一个从1到31的整数”。</p>
<h5 id="乘法器"><strong>乘法器</strong></h5><table>
<thead>
<tr>
<th></th>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>X?</td>
<td>X，一次或一次也没有</td>
<td></td>
</tr>
<tr>
<td></td>
<td>X*</td>
<td>X，零次或多次</td>
<td></td>
</tr>
<tr>
<td></td>
<td>X+</td>
<td>X，一次或多次</td>
<td></td>
</tr>
<tr>
<td></td>
<td>X{n}</td>
<td>X，恰好 n 次</td>
<td></td>
</tr>
<tr>
<td></td>
<td>X{n,}</td>
<td>X，至少 n 次</td>
<td></td>
</tr>
<tr>
<td></td>
<td>X{n,m}</td>
<td>X，至少 n 次，但是不超过 m 次</td>
<td></td>
</tr>
</tbody>
</table>
<p>X可以使一个普通字面值，如a+：一个或多个a，也可以是一个字符类，如[abc]{2}，表示a/b/c后跟a/b/c。<br>值得注意的是优先选择更长的匹配，因为乘法器是贪婪的。如果你输入的文本是I had an aaaaawful day，该正则表达式就会在aaaaawful中匹配到aaaaa。不会在第三个a后就停止匹配。<br>乘法器是贪婪的，但它不会忽略一个更好的匹配。如果你的输入文本为I had an aaawful daaaaay，之后这个正则表达式会在第一次的匹配中于aaawful找到aaa。只有在你说“给我找到另一个匹配”的时候，它才会继续搜索然后在daaaaay中找到aaaaa。<br>惰性：<br>正则表达式<em>“.</em>“<em>表示“找到一个双引号，接着找到尽可能多的字符，最后再找到一个双引号”。注意一下被.</em>匹配的内部字符，很可能包含多个双引号。这通常不是非常有用。乘法器可通过追加问号<strong>（?）</strong>来实现<strong>惰性</strong>。<em>“.</em>?”*表示“匹配一个双引号，跟着一个尽可能少的字符，再跟着一个双引号”。</p>
<h5 id="分支"><strong>分支</strong></h5><p>可以使用管道符号来实现匹配多种选择。</p>
<table>
<thead>
<tr>
<th></th>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>X!Y(用!代替竖线)</td>
<td>X或者Y</td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="组合"><strong>组合</strong></h5><p>可以使用圆括号来组合表达式。例：<br>在一周中找到一天，使用<strong>(Mon|Tues|Wednes|Thurs|Fri|Satur|Sun)day</strong>，这里如果把小括号或者中括号，结果是完全不一样的，因为中括号是字符类，即里面的Mon并不是完全匹配Mon，而是只要匹配M/o/n其中一个即可。<br>同时组合后面还可跟上乘法器，如：<strong>\w+(\s+\w+)*</strong>代表“找到一个或多个单词，它们以空格隔开”。</p>
<h5 id="边界"><strong>边界</strong></h5><p>边界分成：单词边界，行边界，文本边界</p>
<ol>
<li>单词边界<br>单词边界是一个单词字符和非单词字符之间的位置。记住，一个单词字符是\w，它是[0-9A-Za-z<em>]，一个非单词字符是\W，也就是[^0-9A-Za-z</em>]。<br>文本的开头和结尾总是当作单词边界。<br>输入的文本<strong>it’s a cat</strong>有八个单词边界，分别为：文本开头-i，t-‘，’-s，s-空格，空格-a，a-空格，空格-c，t-文本结尾。</li>
<li>行边界<br>每一块文本会分解成一个或多个行，用换行符分隔。<br>注意文本不是以换行符结束，而是以行结束。然而，任何行，包括最后一行，可以包含零个字符。<br>起始行位置是在一个换行符和下一行的第一个字符之间。与单词边界一样，在文本的开头也算作一个起始的行。结束行位置是在行的最后一个字符和换行符之间。与单词边界一样，文本结束也算作行结束。</li>
<li>文本边界<br>很多实现提供一个标记，通过改变它来改变^和$的含义。从“行开始”和“行结束”变成“文本开始”和“文本结束”。其它的一些实现提供单独的元字符\A和\z来达到这个目的。<br>一些表示边界的符号：</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>^</td>
<td>行的开头</td>
<td></td>
</tr>
<tr>
<td></td>
<td>$</td>
<td>行的结尾</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\b</td>
<td>单词边界</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\B</td>
<td>非单词边界</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\A</td>
<td>输入的开头</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\G</td>
<td>上一个匹配的结尾</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\Z</td>
<td>输入的结尾，仅用于最后的结束符（如果有的话）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\z</td>
<td>输入的结尾</td>
<td></td>
</tr>
</tbody>
</table>
<p>其中^$是最常用的两个边界分隔符。</p>
<h4 id="捕获和替换："><strong>捕获和替换：</strong></h4><ol>
<li><p>捕获组</p>
<p>()在正则中被用来表示组，同时也可以用来捕获匹配上的子串，可以拥有多个捕获组，它们甚至可以嵌套使用，捕获组从左到右进行编号，只要计算左圆括号。例如：<br>对于表达式：<strong>(\w+) had a ((\w+) \w+)</strong>，文本是I had a nice day，那么</p>
<ul>
<li>捕获组1是I。</li>
<li>捕获组2是nice day。</li>
<li>捕获组3是nice。</li>
<li>捕获组0是I had a nice day（根据具体实现不同）</li>
</ul>
<p>如果表达式使用了两个捕获组，但是只捕获到一组，那么组2是空字符串。引用捕获组使用+组序号，如\1表示引用第一个捕获组。</p>
</li>
<li>后向引用<br>可以在同样的表达式中引用同一个捕获组，这称为后向引用。<br>例：表达式[abc]{2}表示“匹配aa或ab或ac or ba或bb或bc或ca或cb或cc”，但是表达式([abc])\1表示“匹配aa或bb或cc”。</li>
</ol>
<p>以上就是正则的全部知识，其实了解正则的知识点很简单，但是真要应用到实际中还是需要通过大量的练习才能做到熟练使用。</p>
<h5 id="实际案例"><strong>实际案例</strong></h5><ol>
<li><p>压缩CSS文件，去掉CSS文件中的换行以及空格</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">工具：Notepad++  查找：([&#123;;])<span class="string">\s+</span>  替换：<span class="string">\1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>替换文件中连续出现的#，为其后面添加一个空格，例：####你好-&gt;#### 你好</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">工具：Notepad++  查找：([<span class="preprocessor">#]+)  替换：\<span class="number">1</span> (<span class="number">1</span>后面有个空格)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上案例会不断更新，已记录一些自己对正则使用的经历。</p>
<h4 id="参考文章"><strong>参考文章</strong></h4><p><a href="http://doslin.com/regular%20expressions/2014/03/11/learn-regular-expressions-in-about-55-minutes.html" target="_blank" rel="external">55分钟学会正则表达式(译)</a></p>
<p>JDK API文档</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>正则一直是我一大痛点，一直都想解决这个问题，但是奈何每次看到那么多符号就发蒙，所以就一直拖下去了。直到最近总是被别人问到如何在hql中使用rlike查询符合特定规则的字段，然后各种不会，结果被鄙视的一塌糊涂，无奈，这才静下心来慢慢研究。<br>以前看正则就是一堆符号，代表各]]>
    </summary>
    
      <category term="正则" scheme="http://vickyqi.com/tags/%E6%AD%A3%E5%88%99/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
  </entry>
  
</feed>
