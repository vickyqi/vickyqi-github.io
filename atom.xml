<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Vicky's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://vickyqi.com/"/>
  <updated>2015-11-13T06:13:02.000Z</updated>
  <id>http://vickyqi.com/</id>
  
  <author>
    <name><![CDATA[Vicky]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[JDK并发工具类源码学习系列——ConcurrentSkipListMap(续)]]></title>
    <link href="http://vickyqi.com/2015/11/13/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentSkipListMap(%E7%BB%AD)/"/>
    <id>http://vickyqi.com/2015/11/13/JDK并发工具类源码学习系列——ConcurrentSkipListMap(续)/</id>
    <published>2015-11-13T12:05:00.000Z</published>
    <updated>2015-11-13T06:13:02.000Z</updated>
    <content type="html"><![CDATA[<p>ConcurrentSkipListMap在JDK并发工具类使用范围不是很广，它是针对某一特殊需求而设计的——支持排序，同时支持搜索目标返回最接近匹配项的导航方法。一般情况下开发者很少会使用到该类，但是如果你有如上的特殊需求，那么ConcurrentSkipListMap将是一个很好地解决方案。 本文通过对JDK的ConcurrentSkipListMap的代码详细分析，深入分析其实现原理。<br><a id="more"></a><br><a href="http://vickyqi.com/2015/11/13/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentSkipListMap/">上一篇介绍了ConcurrentSkipListMap的原理以及对put()方法进行了解析</a>，本篇继续接着上一篇往下看。</p>
<h5 id="常用方法解读"><strong>常用方法解读</strong></h5><p>上一篇说到put()的最后一句：<code>insertIndex(z, level);</code>这一句是将一个新节点插入到跳表结构中，下面看看是如何实现的。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> insertIndex(Node&lt;K,V&gt; z, <span class="built_in">int</span> level) &#123;</span><br><span class="line"> HeadIndex&lt;K,V&gt; h = head;<span class="comment">// 读取跳表的头</span></span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">max</span> = h.level;<span class="comment">// 跳表的最高层级</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (level &lt;= <span class="built_in">max</span>) &#123;<span class="comment">// level &lt;= max则需要将自最底层到level层的每一层插入该节点</span></span><br><span class="line">    	<span class="comment">// 此处从最底层开始往上创建跳表节点，每个节点的down指向下一层的节点，</span></span><br><span class="line">    	<span class="comment">// 最后的idx为level层的节点，通过down形成一个链表结构</span></span><br><span class="line">        Index&lt;K,V&gt; idx = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">            idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 将该节点插入跳表</span></span><br><span class="line">        addIndex(idx, h, level);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// Add a new level(新增加一层)</span></span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * To reduce interference by other threads checking for</span><br><span class="line">         * empty levels in tryReduceLevel, new levels are added</span><br><span class="line">         * with initialized right pointers. Which in turn requires</span><br><span class="line">         * keeping levels in an array to access them while</span><br><span class="line">         * creating new head index nodes from the opposite</span><br><span class="line">         * direction.</span><br><span class="line">         */</span></span><br><span class="line">        level = <span class="built_in">max</span> + <span class="number">1</span>;<span class="comment">// 最大值+1</span></span><br><span class="line">Index&lt;K,V&gt;[] idxs = (Index&lt;K,V&gt;[])<span class="keyword">new</span> Index[level+<span class="number">1</span>];<span class="comment">//一个数组</span></span><br><span class="line">        Index&lt;K,V&gt; idx = <span class="keyword">null</span>;<span class="comment">// 一个新的跳表头结点</span></span><br><span class="line">        <span class="comment">// 该数组是一个从level层开始一直向下引用的垂直链表，用于方便获取某层的节点</span></span><br><span class="line">        <span class="comment">// 用处在下面if (level &lt;= oldLevel)出可以看出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">            idxs[i] = idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        HeadIndex&lt;K,V&gt; oldh;<span class="comment">//旧头结点</span></span><br><span class="line">        <span class="built_in">int</span> k;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            oldh = head;</span><br><span class="line">            <span class="built_in">int</span> oldLevel = oldh.level;</span><br><span class="line">            <span class="comment">// 此处如果发生level &lt;= oldLevel说明其他线程已经增加了这一层，那么当前线程要插入的层已经不&gt;跳表的最大层了</span></span><br><span class="line">            <span class="comment">// 那直接从数组中渠道level层的节点插入到跳表即可，插入方式同上面</span></span><br><span class="line">            <span class="keyword">if</span> (level &lt;= oldLevel) &#123; <span class="comment">// lost race to add level</span></span><br><span class="line">                k = level;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            HeadIndex&lt;K,V&gt; newh = oldh;</span><br><span class="line">            Node&lt;K,V&gt; oldbase = oldh.node;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = oldLevel+<span class="number">1</span>; j &lt;= level; ++j)</span><br><span class="line">            	<span class="comment">// 循环创建头结点，直到level层，其实从level = max + 1;这里可以看出也就最多增加一层</span></span><br><span class="line">            	<span class="comment">// 新的头结点node和下一层的node一样，down引用下一层，right是我们新建的节点(通过idxs数组直接访问第N层的节点)</span></span><br><span class="line">                newh = <span class="keyword">new</span> HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);</span><br><span class="line">            <span class="comment">// 用新的头结点取代旧的头结点，使用CAS避免并发安全问题</span></span><br><span class="line">            <span class="keyword">if</span> (casHead(oldh, newh)) &#123;</span><br><span class="line">            	<span class="comment">// 此处k = oldLevel，直接导致下面插入节点的时候从oldLevel开始插入，</span></span><br><span class="line">            	<span class="comment">// 因为oldLevel之上是新插入的层级，每层都是一个接节点，所以已经是OK的了</span></span><br><span class="line">                k = oldLevel;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入节点</span></span><br><span class="line">        addIndex(idxs[k], oldh, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> addIndex(Index&lt;K,V&gt; idx, HeadIndex&lt;K,V&gt; h, <span class="built_in">int</span> indexLevel) &#123;</span><br><span class="line"><span class="comment">// Track next level to insert in case of retries</span></span><br><span class="line">    <span class="built_in">int</span> insertionLevel = indexLevel;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; <span class="variable">key</span> = comparable(idx.node.<span class="variable">key</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">key</span> == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Similar to findPredecessor, but adding index nodes along</span></span><br><span class="line">    <span class="comment">// path to key.</span></span><br><span class="line">    <span class="comment">// 此处死循环是在发生不一致时进行重试</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">// 此处从跳表头部开始找到该插入该节点的位置，类似findPredecessor</span></span><br><span class="line">        <span class="built_in">int</span> j = h.level;</span><br><span class="line">        Index&lt;K,V&gt; q = h;</span><br><span class="line">        Index&lt;K,V&gt; r = q.right;</span><br><span class="line">        Index&lt;K,V&gt; t = idx;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        	<span class="comment">// 在当前层级查找适合插入节点的位置</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                <span class="comment">// compare before deletion check avoids needing recheck</span></span><br><span class="line">                <span class="built_in">int</span> c = <span class="variable">key</span>.compareTo(n.<span class="variable">key</span>);</span><br><span class="line">                <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;<span class="comment">// 如果r已被删除，则移除r</span></span><br><span class="line">                    <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    r = q.right;<span class="comment">//r指向下一层节点，继续</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;<span class="comment">//如果当前访问的节点key&lt;需插入节点的key，则继续右移</span></span><br><span class="line">                    q = r;</span><br><span class="line">                    r = r.right;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 到达此处有两种情况：</span></span><br><span class="line">            <span class="comment">//	1.已访问到该层链表的最右边</span></span><br><span class="line">            <span class="comment">//	2.当前访问的节点(r)的key&gt;=需插入节点的key，则继续右移</span></span><br><span class="line">            <span class="keyword">if</span> (j == insertionLevel) &#123;<span class="comment">// 如果找到的层级==要插入的层级，那么就在该层级插入该节点</span></span><br><span class="line">                <span class="comment">// Don't insert index if node already deleted</span></span><br><span class="line">                <span class="keyword">if</span> (t.indexesDeletedNode()) &#123;<span class="comment">// 判断要插入的节点是否已经被删除，此处考虑的是多线程情况下可能发生的并发问题</span></span><br><span class="line">                    findNode(<span class="variable">key</span>); <span class="comment">// cleans up</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将t插入到q的右边，替代之前的r，通过CAS确保并发安全</span></span><br><span class="line">                <span class="keyword">if</span> (!q.link(r, t))</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// restart</span></span><br><span class="line">                <span class="keyword">if</span> (--insertionLevel == <span class="number">0</span>) &#123;<span class="comment">// 插入下一层，直到0为止</span></span><br><span class="line">                    <span class="comment">// need final deletion check before return</span></span><br><span class="line">                    <span class="keyword">if</span> (t.indexesDeletedNode())</span><br><span class="line">                        findNode(<span class="variable">key</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将j-1有两个目的：</span></span><br><span class="line">            <span class="comment">// 	1.如果在-1之前j == insertionLevel，即查找已经定位到要插入节点的那一层，则insertionLevel会-1，所以j也要跟着-1</span></span><br><span class="line">            <span class="comment">//	2.在-1之前j != insertionLevel，说明还未查找到要插入的那一层，需要继续往下查找</span></span><br><span class="line">            <span class="comment">//此处需要同时满足两个条件才可向下一层查找：</span></span><br><span class="line">            <span class="comment">//	1.-1之后的j&gt;=insertionLevel(此处可能是还未找到要插入的层，也可能已经找到了)</span></span><br><span class="line">            <span class="comment">//	2.j &lt; indexLevel，针对第一点还未找到要插入的层，如果j&gt;=indeLevel说明该层不需要插入节点</span></span><br><span class="line">            <span class="keyword">if</span> (--j &gt;= insertionLevel &amp;&amp; j &lt; indexLevel)</span><br><span class="line">            	<span class="comment">// t=t.down即将t往下移动一层，此处的t是在每一层要插入的节点，其实也就是要插入节点的下一层</span></span><br><span class="line">                t = t.down;</span><br><span class="line">            <span class="comment">// 到这里存在两种情况：</span></span><br><span class="line">            <span class="comment">//	1.上层已经插入了</span></span><br><span class="line">            <span class="comment">//	2.还未找到要插入的层(第一个要插入的层，也就是新插入节点被分配到的层级)</span></span><br><span class="line">            <span class="comment">// 不管上面如何处理，到这里都需要往下遍历了</span></span><br><span class="line">            q = q.down;</span><br><span class="line">            r = q.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>真的挺复杂的逻辑，本身跳表的插入就有点复杂，现在还需要考虑并发问题，就更多复杂难懂了。代码中加入了大量的注释，希望能够说明白吧，其实自己看着也挺蒙，明白原理就行，哈哈。<br>put()总算说完了，下面看看get()吧。</p>
<h6 id="get(Object)"><strong>get(Object)</strong></h6><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> V doGet(<span class="keyword">Object</span> okey) &#123;</span><br><span class="line">Comparable&lt;? <span class="keyword">super</span> K&gt; <span class="variable">key</span> = comparable(okey);</span><br><span class="line">    Node&lt;K,V&gt; bound = <span class="keyword">null</span>;</span><br><span class="line">    Index&lt;K,V&gt; q = head;</span><br><span class="line">    Index&lt;K,V&gt; r = q.right;</span><br><span class="line">    Node&lt;K,V&gt; n;</span><br><span class="line">    K k;</span><br><span class="line">    <span class="built_in">int</span> c;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Index&lt;K,V&gt; d;</span><br><span class="line">        <span class="comment">// Traverse rights</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; (n = r.node) != bound &amp;&amp; (k = n.<span class="variable">key</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((c = <span class="variable">key</span>.compareTo(k)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                q = r;</span><br><span class="line">                r = r.right;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">Object</span> v = n.value;</span><br><span class="line">                <span class="keyword">return</span> (v != <span class="keyword">null</span>)? (V)v : getUsingFindNode(<span class="variable">key</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">            	<span class="comment">// 这里当前查找的节点(n)key&gt;指定key说明已经跑过头了，此时需要往下找了</span></span><br><span class="line">            	<span class="comment">// bound在这里的作用是在下一层进行查找时如果找到了这一层的bound节点则说明又需要往下找了</span></span><br><span class="line">            	<span class="comment">// 这里如果理解了跳表的结构就好理解了，因为有的节点并不是每层都有</span></span><br><span class="line">                bound = n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Traverse down</span></span><br><span class="line">        <span class="keyword">if</span> ((d = q.down) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            q = d;</span><br><span class="line">            r = d.right;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果执行到这里，说明已经找到最底层了，但是依旧没找到该节点，所以要找的节点如果存在那么就是在最底层的靠右端</span></span><br><span class="line">    <span class="comment">// 所以还需要往右查找</span></span><br><span class="line">    <span class="comment">// Traverse nexts</span></span><br><span class="line">    <span class="keyword">for</span> (n = q.node.next;  n != <span class="keyword">null</span>; n = n.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((k = n.<span class="variable">key</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((c = <span class="variable">key</span>.compareTo(k)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">Object</span> v = n.value;</span><br><span class="line">                <span class="keyword">return</span> (v != <span class="keyword">null</span>)? (V)v : getUsingFindNode(<span class="variable">key</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> V getUsingFindNode(Comparable&lt;? <span class="keyword">super</span> K&gt; <span class="variable">key</span>) &#123;</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">     * Loop needed here and elsewhere in case value field goes</span><br><span class="line">     * null just as it is about to be returned, in which case we</span><br><span class="line">     * lost a race with a deletion, so must retry.</span><br><span class="line">     */</span></span><br><span class="line">	<span class="comment">// 该方法循环查找key的节点，如果找不到key对应的节点，则直接返回null</span></span><br><span class="line">	<span class="comment">// 如果找到对应的节点，但是value==null，则重试(原因尚不清楚，注释也不是太明白)</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">// findNode返回的n如果不为null，那么就已经判断过n的value是否为null了，</span></span><br><span class="line">    	<span class="comment">// 下面再次判断可能是为了避免其他线程在这段时间内删掉了这个节点</span></span><br><span class="line">    	<span class="comment">// 不过既然被其他线程删掉了为什么还要去找呢，直接返回null不就好了，是在不明白，难道是为了再去删掉这个节点？</span></span><br><span class="line">        Node&lt;K,V&gt; n = findNode(<span class="variable">key</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">Object</span> v = n.value;</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (V)v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* @By Vicky:此方法用于根据key查找对应的节点</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;K,V&gt; findNode(Comparable&lt;? <span class="keyword">super</span> K&gt; <span class="variable">key</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">// findPredecessor找到key的左边的节点，之前有介绍</span></span><br><span class="line">        Node&lt;K,V&gt; b = findPredecessor(<span class="variable">key</span>);</span><br><span class="line">        <span class="comment">// n是b的next节点，正确情况下n的key==key</span></span><br><span class="line">        Node&lt;K,V&gt; n = b.next;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)	<span class="comment">// n==null说明b是最右边的节点，所以其实未找到key对应的节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">Object</span> v = n.value;</span><br><span class="line">            <span class="comment">// n被删除了，helpDelete掉</span></span><br><span class="line">            <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;                <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// b被打上了delete标记，等待其他线程将其删除</span></span><br><span class="line">            <span class="keyword">if</span> (v == n || b.value == <span class="keyword">null</span>)  <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">int</span> c = <span class="variable">key</span>.compareTo(n.<span class="variable">key</span>);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)<span class="comment">// 即n就是要查找的节点</span></span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)<span class="comment">// b的key小于指定key，但是b的下一个节点的key大于指定key，说明没指定key对应的节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            b = n;<span class="comment">// 继续往右走</span></span><br><span class="line">            n = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get()过程涉及三个方法，都是查找，相对put()来说，get简单多了，就是按跳表的结构查找，只是需要判断节点是否被删除，同时还需要帮忙将被删除的节点移除跳表结构。代码中的注释应该比较清楚了，就不再细述了，下面看remove()方法。</p>
<h6 id="remove(Object)"><strong>remove(Object)</strong></h6><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V remove(<span class="keyword">Object</span> <span class="variable">key</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> doRemove(<span class="variable">key</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* @By Vicky:删除的逻辑和查找类似，将找到的节点的value置为null，同时将其打上删除标记 </span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">final</span> V doRemove(<span class="keyword">Object</span> okey, <span class="keyword">Object</span> value) &#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; <span class="variable">key</span> = comparable(okey);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">// findPredecessor找到最底层的前一个节点(这里的节点是链表的节点，而非跳表的节点)</span></span><br><span class="line">        Node&lt;K,V&gt; b = findPredecessor(<span class="variable">key</span>);</span><br><span class="line">        Node&lt;K,V&gt; n = b.next;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        	<span class="comment">// b.next==null说明未找到响应的节点，直接返回null</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                    <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">Object</span> v = n.value;</span><br><span class="line">            <span class="comment">// 下面分别判断n和b是否已被删除</span></span><br><span class="line">            <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;                    <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v == n || b.value == <span class="keyword">null</span>)      <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">int</span> c = <span class="variable">key</span>.compareTo(n.<span class="variable">key</span>);</span><br><span class="line">            <span class="comment">// c&lt;0说明findPredecessor找到的节点的下一个节点的key&lt;要删除的key</span></span><br><span class="line">            <span class="comment">// 正确情况下(无并发情况下)c应该是&gt;=0才对</span></span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// c&gt;0继续查找</span></span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                b = n;</span><br><span class="line">                n = f;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// value!=null则说明需要待删除的节点的值和指定的值一样才可删除</span></span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !value.equals(v))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 将节点的value置为null即表示删除</span></span><br><span class="line">            <span class="keyword">if</span> (!n.casValue(v, <span class="keyword">null</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 同时为n添加删除标记</span></span><br><span class="line">            <span class="keyword">if</span> (!n.appendMarker(f) || !b.casNext(n, f))</span><br><span class="line">            	<span class="comment">// 这一步其实就是为了触发删除节点</span></span><br><span class="line">                findNode(<span class="variable">key</span>);                  <span class="comment">// Retry via findNode</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">// 触发删除节点，同时如果最高层的节点被删完了则降一层</span></span><br><span class="line">                findPredecessor(<span class="variable">key</span>);           <span class="comment">// Clean index</span></span><br><span class="line">                <span class="keyword">if</span> (head.right == <span class="keyword">null</span>)</span><br><span class="line">                    tryReduceLevel();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (V)v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>remove()和get()差不多，毕竟删除节点的第一步就是找到这个节点，代码中添加了注释，这里不再细述。</p>
<p>看完了三个重要方法，说实话虽然每个方法中的每行代码都可以理解，但是想要理解为什么这么做还是很难的，毕竟代码是死的。就比如说remove和get，remove中也要查找节点，但是remove是调用findPredecessor()来直接查找最底层链表的前继节点，而get是自己按照跳表的结构进行查找，为什么呢？还有一点，所有的跳表节点中引用的node(链表节点)都是一样的，即如果第2层跳表引用一个node(key=4)和第1层引用的node(key=4)其实是同一个引用，而且同最底层的链表的node也是同一个，所以如果找到最上层的那个节点，不就是相当于找到最底层的那个节点了吗？为什么非得找最底层呢？<br>这里可以给出一个答案，那就是findPredecessor()会将已经被删除的跳表的节点从跳表结构中移除，因为删除节点只是将value置为null，顺便加个删除标记，但是这些节点还挂在跳表中，所以需要人为的触发findPredecessor()去一个个删除，也许这就是目的吧。</p>
<p>这三个方法都没有加锁，使用了CAS进行更新，同时修改结构的时候都是控制在一个CAS操作中完成，例如put()方法在将一个节点插入到链表时，是先创建一个新的节点，这个节点的next指向要插入的位置的下一个节点，这步操作不会影响整体的结构，所以是安全的，然后将要插入位置的前一个节点的next原子性的更新成新的节点，所以也不会影响到其他线程，而remove则只是将节点的value值修改为null，以及原子的更新节点的next，所以CAS+volatile就是JDKconcurrent包下的并发控制的实现原理。</p>
<h5 id="使用场景"><strong>使用场景</strong></h5><p>ConcurrentSkipListMap使用跳表结构来保存链表的顺序，解决了在有序链表中快速查找的问题，所以ConcurrentSkipListMap适合在需要链表的高效更新效率(删除/插入)以及还要保证一定的随机访问效率(查找/更新)的场景下使用。</p>
<h5 id="参考文章"><strong>参考文章</strong></h5><p><a href="http://kenby.iteye.com/blog/1187303" target="_blank" rel="external">SkipList 跳表</a><br><a href="http://blog.csdn.net/guangcigeyun/article/details/8278349" target="_blank" rel="external">Java多线程（四）之ConcurrentSkipListMap深入分析</a><br><a href="http://www.cnblogs.com/skywang12345/p/3498556.html" target="_blank" rel="external">Java多线程系列–“JUC集合”05之 ConcurrentSkipListMap</a></p>
<hr>
<p>以上就是本篇的全部内容，如有错误之处，还望大家指出，谢谢~~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ConcurrentSkipListMap在JDK并发工具类使用范围不是很广，它是针对某一特殊需求而设计的——支持排序，同时支持搜索目标返回最接近匹配项的导航方法。一般情况下开发者很少会使用到该类，但是如果你有如上的特殊需求，那么ConcurrentSkipListMap将是一个很好地解决方案。 本文通过对JDK的ConcurrentSkipListMap的代码详细分析，深入分析其实现原理。<br>]]>
    
    </summary>
    
      <category term="JDK" scheme="http://vickyqi.com/tags/JDK/"/>
    
      <category term="JUC" scheme="http://vickyqi.com/tags/JUC/"/>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="JDK源码" scheme="http://vickyqi.com/categories/Java/JDK%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为Hexo博客文章添加关键字]]></title>
    <link href="http://vickyqi.com/2015/11/10/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://vickyqi.com/2015/11/10/为Hexo博客文章添加关键字/</id>
    <published>2015-11-10T09:12:00.000Z</published>
    <updated>2015-11-10T09:14:08.000Z</updated>
    <content type="html"><![CDATA[<p>本文章是为Hexo博客的next主题的文章增加关键字的设定，默认next主题的文章关键字取文章的标签，所以如果想要设置很全的关键字，肯定会造成自己的标签页的标签过多，看着过于杂乱，所以就想将文章的关键字与标签分开，下面做简单的修改即可达到此目的。<br><a id="more"></a></p>
<p>本文章是为Hexo博客的next主题的文章增加关键字的设定，默认next主题的文章关键字取文章的标签，所以如果想要设置很全的关键字，肯定会造成自己的标签页的标签过多，看着过于杂乱，所以就想将文章的关键字与标签分开，下面做简单的修改即可达到此目的。</p>
<p>修改文件：themes\next\layout_partials\head.swig<br>修改内容：35行左右，将原来的设置ketwords的代码覆盖即可</p>
<figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template_tag">&#123;% <span class="keyword">if</span> page.keywords and page.keywords.length %&#125;</span><span class="xml"></span><br><span class="line">  <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"keywords"</span> <span class="attribute">content</span>=<span class="value">"</span></span></span><span class="template_tag">&#123;% <span class="keyword">for</span> key <span class="keyword">in</span> page.keywords %&#125;</span><span class="xml"><span class="tag"><span class="value"></span></span></span><span class="variable">&#123;&#123; key &#125;&#125;</span><span class="xml"><span class="tag"><span class="value">,</span></span></span><span class="template_tag">&#123;% <span class="keyword">endfor</span> %&#125;</span><span class="xml"><span class="tag"><span class="value">"</span> /&gt;</span></span><br><span class="line"></span><span class="template_tag">&#123;% <span class="keyword">elif</span> page.tags and page.tags.length %&#125;</span><span class="xml"></span><br><span class="line">  <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"keywords"</span> <span class="attribute">content</span>=<span class="value">"</span></span></span><span class="template_tag">&#123;% <span class="keyword">for</span> tag <span class="keyword">in</span> page.tags %&#125;</span><span class="xml"><span class="tag"><span class="value"></span></span></span><span class="variable">&#123;&#123; tag.name &#125;&#125;</span><span class="xml"><span class="tag"><span class="value">,</span></span></span><span class="template_tag">&#123;% <span class="keyword">endfor</span> %&#125;</span><span class="xml"><span class="tag"><span class="value">"</span> /&gt;</span></span><br><span class="line"></span><span class="template_tag">&#123;% <span class="keyword">elif</span> theme.keywords %&#125;</span><span class="xml"></span><br><span class="line">  <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"keywords"</span> <span class="attribute">content</span>=<span class="value">"</span></span></span><span class="variable">&#123;&#123; theme.keywords &#125;&#125;</span><span class="xml"><span class="tag"><span class="value">"</span> /&gt;</span></span><br><span class="line"></span><span class="template_tag">&#123;% <span class="keyword">endif</span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure>
<hr>
<p>原创文章，转载请注明出处，多谢~~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文章是为Hexo博客的next主题的文章增加关键字的设定，默认next主题的文章关键字取文章的标签，所以如果想要设置很全的关键字，肯定会造成自己的标签页的标签过多，看着过于杂乱，所以就想将文章的关键字与标签分开，下面做简单的修改即可达到此目的。<br>]]>
    
    </summary>
    
      <category term="hexo" scheme="http://vickyqi.com/tags/hexo/"/>
    
      <category term="博客" scheme="http://vickyqi.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="博客" scheme="http://vickyqi.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[坑爹的Spring数据源——自动提交事务]]></title>
    <link href="http://vickyqi.com/2015/11/10/%E5%9D%91%E7%88%B9%E7%9A%84Spring%E6%95%B0%E6%8D%AE%E6%BA%90%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1/"/>
    <id>http://vickyqi.com/2015/11/10/坑爹的Spring数据源——自动提交事务/</id>
    <published>2015-11-10T07:56:00.000Z</published>
    <updated>2015-11-10T08:18:22.000Z</updated>
    <content type="html"><![CDATA[<p>记一次数据源的自动提交事务带来的烦恼，并通过分析找到JBoss JNDI数据源默认自动提交事务的解决方案<br><a id="more"></a></p>
<h4 id="问题描述"><strong>问题描述</strong></h4><p>项目中涉及充值、扣费逻辑，由于习惯，所以所有的业务逻辑都是通过Mysql存储过程来控制的，所以很自然的将Mysql设置为手动提交(全局的)，然后存储过程中根据返回码决定是提交还是回滚。但是今天出现一个存储过程返回错误码，但是部分事务提交了，研究了半天，发现并没有任务问题，手动调用存储过程是返回错误码，但是不会部分提交事务。于是决定找下问题，不找不知道，一找吓一跳。</p>
<p><strong>（先说明下，项目未使用Spring的事务管理，而是通过存储过程手动控制事务，所以此处与Spring的事务管理无任何关系。）</strong></p>
<p>由于经过测试排除了数据库层面的问题，那么问题只能出现在程序层了。</p>
<h4 id="问题发现"><strong>问题发现</strong></h4><p>项目使用的Spring配置的JBoss的JNDI数据源，JBoss也比较老（是很老），通过使用Spring执行select @@autocommit;发现autocommit竟然是1（自动提交事务），但是明明已经在数据库层将autocommit设置为0（手动提交事务）了，很显然Connection中主动设置了当前会话的autocommit。</p>
<h4 id="问题深究"><strong>问题深究</strong></h4><p>由于Connection来自DataSource，而Spring中对Connection并未做任何的封装，同时通过Debug发现Spring获得的Connection是org.jboss.resource.adapter.jdbc.WrappedConnection类，看来是JBoss的JNDI数据源的Connection没错了。没找到源码，所以只好用jd反编辑查看了，发现里面有个jdbcAutoCommit，默认是true，WrappedConnection是实现java.sql.Connection的，所以提供了setAutoCommit()，但是由于能力有限无法找到JBoss初始化JNDI数据源的代码，也没找到任何可配置该参数的地方，所以没整了。</p>
<h4 id="问题解决"><strong>问题解决</strong></h4><p>既然写这篇文章，总归有个解决方案，不管好还是不好，总不能留着打自己脸呀。</p>
<p>解决方案就是发现JBoss配置数据源时有一个参数：new-connection-sql，通过注释发现该参数是在每次创建一个新的Connection时调用的，目的可能是用来测试或者其他的，有了这个参数我们就可以在所有通过该Connection的请求之前设置当前Connection的autoCommit=0，所以这个参数的值设置为set autocommit=0就可以解决啦。</p>
<p>同时发现有些数据源页不提供自动提交事务配置，默认还都是true（不知道是自己没找对还是真的没有，如C3P0）。</p>
<hr>
<p>原创文章，转载请注明出处，多谢~~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>记一次数据源的自动提交事务带来的烦恼，并通过分析找到JBoss JNDI数据源默认自动提交事务的解决方案<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="事务" scheme="http://vickyqi.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="数据源" scheme="http://vickyqi.com/tags/%E6%95%B0%E6%8D%AE%E6%BA%90/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JDK并发工具类源码学习系列——ConcurrentSkipListMap]]></title>
    <link href="http://vickyqi.com/2015/11/08/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentSkipListMap/"/>
    <id>http://vickyqi.com/2015/11/08/JDK并发工具类源码学习系列——ConcurrentSkipListMap/</id>
    <published>2015-11-08T12:05:00.000Z</published>
    <updated>2015-11-13T06:12:26.000Z</updated>
    <content type="html"><![CDATA[<p>ConcurrentSkipListMap在JDK并发工具类使用范围不是很广，它是针对某一特殊需求而设计的——支持排序，同时支持搜索目标返回最接近匹配项的导航方法。一般情况下开发者很少会使用到该类，但是如果你有如上的特殊需求，那么ConcurrentSkipListMap将是一个很好地解决方案。 本文通过对JDK的ConcurrentSkipListMap的代码详细分析，深入分析其实现原理。<br><a id="more"></a><br>更多文章请阅读：<a href="http://vickyqi.com/2015/10/24/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E4%BB%8B%E7%BB%8D/">JDK并发工具类源码学习系列目录</a>。<br>ConcurrentSkipListMap在JDK并发工具类使用范围不是很广，它是针对某一特殊需求而设计的——支持排序，同时支持搜索目标返回最接近匹配项的导航方法。一般情况下开发者很少会使用到该类，但是如果你有如上的特殊需求，那么ConcurrentSkipListMap将是一个很好地解决方案。<br>Java Collections Framework中另一个支持排序的Map是TreeMap，两者都是有序的哈希表，但是TreeMap是非线程安全的，当然可以使用Collections.synchronizedSortedMap将TreeMap进行包装，但是性能方面就显得捉急了，毕竟多个线程一起读都需要加锁是不太合理的，至少做到读写分离呀。但是从JDK1.6开始我们就多了一个选择：ConcurrentSkipListMap。这是一个支持高并发度的有序哈希表，并且是无锁的，可在多线程环境下替代TreeMap。<br>下面我们从几个方面来分析ConcurrentSkipListMap的实现，主要分析ConcurrentSkipListMap的数据结构以及如何实现高并发且无锁读写的。</p>
<ul>
<li>实现原理</li>
<li>数据结构</li>
<li>常用方法解读</li>
<li>使用场景</li>
</ul>
<h5 id="实现原理"><strong>实现原理</strong></h5><p>ConcurrentSkipListMap不同于TreeMap，前者使用SkipList(跳表)实现排序，而后者使用红黑树。相比红黑树，跳表的原理比较容易理解，简单点说就是在有序的链表上使用多级索引来定位元素。下面是简单看看SkipList的原理：</p>
<p>现在假设我们拥有一个有序的列表，如果我们想要在这个列表中查找一个元素，最优的查找算法应该是二分    查找了，但是链表不想数组，链表的元素是非连续的，所以无法使用二分查找来进行高效查找，那么抛开其他查找算法不说，最低效的算法就是从链表头部开始遍历，直至找到要查找的元素，虽说低效但是确是最大化使用了链表的优势——遍历。那么我们有没有可能同时提高查找效率，而且还使用链表的优势呢？跳表就是我们想要的查找算法。其实说白了跳表就是一种多级索引，通过索引链表中的部分值来确定被查找的值所处的范围。</p>
<p>跳表分为多层，层数越高，最高层元素越少，查找时也会越快，但是所占空间也就越多，所以跳表是用空间换时间（可见如果大量数据不是太适用，毕竟内存是有限的）。</p>
<p><strong>跳表结构示意图：</strong></p>
<p><img src="http://img.blog.csdn.net/20151106120258045" alt="跳表"></p>
<p>可以看见每一层都是一个有序的链表，而且是原始链表的子集，最底层（level1）是完整的链表结构，越往上链表的元素越少，同时查找也就越快。当我们需要查找一个元素时，会从跳表的最上层链表开始查询，定位元素的大致位置，然后通过向下指针再在下层查找。</p>
<p><strong>跳表查找示意图：</strong></p>
<p><img src="http://img.blog.csdn.net/20151106120618501" alt="跳表查找示意图"></p>
<p>上图是从跳表中查找32的过程。<br>跳表的查找时间复杂度是：O(log(n))，更多详细关于跳表的介绍可参考：<a href="http://kenby.iteye.com/blog/1187303" target="_blank" rel="external">http://kenby.iteye.com/blog/1187303</a></p>
<h5 id="数据结构"><strong>数据结构</strong></h5><p>ConcurrentSkipListMap在原始链表的基础上增加了跳表的结构，所以需要两个额外的内部类来封装链表的节点，以及跳表的节点——<strong>Node</strong>和<strong>Index</strong>。</p>
<h6 id="Node：链表的节点"><strong>Node：链表的节点</strong></h6><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static final class <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; &#123;</span><br><span class="line">	final K key;</span><br><span class="line">	volatile Object value;</span><br><span class="line">	volatile <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同ConcurrentHashMap的Node节点一样，key为final，是不可变的，value和next通过volatile修饰保证内存可见性。</p>
<h6 id="Index：跳表的节点"><strong>Index：跳表的节点</strong></h6><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static class Index<span class="tag">&lt;K,V&gt;</span> &#123;</span><br><span class="line">	final <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; <span class="keyword">node</span><span class="identifier"></span><span class="title">;</span><br><span class="line">	final</span> Index<span class="tag">&lt;K,V&gt;</span> down;</span><br><span class="line">	volatile Index<span class="tag">&lt;K,V&gt;</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Index封装了跳表需要的结构，首先node包装了链表的节点，down指向下一层的节点（不是Node，而是Index），right指向同层右边的节点。node和down都是final的，说明跳表的节点一旦创建，其中的值以及所处的层就不会发生变化（因为down不会变化，所以其下层的down都不会变化，那他的层显然不会变化）。<br>Node和Index内部都提供了用于CAS原子更新的AtomicReferenceFieldUpdater对象，至于该对象的原理下面是不会深入研究的。</p>
<h5 id="常用方法解读"><strong>常用方法解读</strong></h5><p>从API文档可以看到ConcurrentHashMap的方法很多，很多都是一些为了方便开发者的提供的，例如subMap(K, boolean, K, boolean)、headMap(K, boolean)、tailMap(K, boolean)等都是用来返回一个子视图的方法。这里我们主要看看能够表达ConcurrentHashMap实现原理的三个方法：put(K, V)、get(Object)、remove(Object, Object)。<br>在介绍这三个方法之前，我们先看一个辅助工具方法：comparable(Object)。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * If using comparator, return a ComparableUsingComparator, else</span><br><span class="line"> * cast key as Comparable, which may cause ClassCastException,</span><br><span class="line"> * which is propagated back to caller.</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">// @By Vicky:将key封装成一个Comparable对象</span></span><br><span class="line"><span class="keyword">private</span> Comparable&lt;? <span class="keyword">super</span> K&gt; comparable(<span class="keyword">Object</span> <span class="variable">key</span>) <span class="keyword">throws</span> ClassCastException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">key</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// @By Vicky:有两种封装方法，如果在构造时指定了comparator，则使用comparator封装key</span></span><br><span class="line">    <span class="comment">// 如果没有指定comparator，则key必须是一个继承自Comparable接口的类，否则会抛出ClassCastException</span></span><br><span class="line">    <span class="comment">// 所以ConcurrentSkipListMap的key要么是继承自Comparable接口的类，如果不是的话需要显示提供comparator进行比较</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ComparableUsingComparator&lt;K&gt;((K)<span class="variable">key</span>, comparator);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (Comparable&lt;? <span class="keyword">super</span> K&gt;)<span class="variable">key</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面那个辅助方法可以看到ConcurrentSkipListMap的key必须要能够进行比较，可以有两种方式提供比较方法，代码注释中已提到。</p>
<h6 id="put(K,_V)"><strong>put(K, V)</strong></h6><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">   <span class="comment">// @By Vicky:实际调用内部的doPut方法</span></span><br><span class="line">   <span class="keyword">return</span> doPut(key, <span class="keyword">value</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* @By Vicky:</span><br><span class="line"> * 三个参数，其中onlyIfAbsent表示是否只在Map中不包含该key的情况下才插入value，默认是false</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doPut</span>(<span class="params">K kkey, V <span class="keyword">value</span>, boolean onlyIfAbsent</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 将key封装成一个Comparable对象，便于直接与其他key进行比较</span></span><br><span class="line">    Comparable&lt;? super K&gt; key = comparable(kkey);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">// 从跳表中查找最接近指定key的节点：该节点的key小于等于指定key，且处于最底层</span></span><br><span class="line">        Node&lt;K,V&gt; b = findPredecessor(key);</span><br><span class="line">        Node&lt;K,V&gt; n = b.next;<span class="comment">// b的下一个节点，新节点即将插入到b与n之间</span></span><br><span class="line">        <span class="comment">// 准备插入</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;<span class="comment">// n==null则说明b是链表的最后一个节点，则新节点直接插入到链表尾部即可</span></span><br><span class="line">                Node&lt;K,V&gt; f = n.next;<span class="comment">// n的下一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (n != b.next)               <span class="comment">// inconsistent read 此处增加判断，避免链表结构已被修改(针对节点b)</span></span><br><span class="line">                    <span class="keyword">break</span>;;</span><br><span class="line">                Object v = n.<span class="keyword">value</span>;</span><br><span class="line">                <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;               <span class="comment">// n is deleted</span></span><br><span class="line">                    n.helpDelete(b, f);<span class="comment">// 将n从链表移除，b和f分别为n的前继节点与后继节点</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里如果v==n说明n是一个删除标记，用来标记其前继节点已被删除，即b已被删除</span></span><br><span class="line">                <span class="comment">// 查看helpDelete()的注释</span></span><br><span class="line">                <span class="keyword">if</span> (v == n || b.<span class="keyword">value</span> == <span class="keyword">null</span>) <span class="comment">// b is deleted</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 比较key，此处进行二次比较是避免链表已发生改变，比如b后面已被插入一个新的节点</span></span><br><span class="line">                <span class="comment">// (findPredecessor时已经比较过b的next节点(n)的key与指定key的大小，因为n的key&gt;指定key才会返回b)</span></span><br><span class="line">                <span class="keyword">int</span> c = key.compareTo(n.key);</span><br><span class="line">                <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果指定key&gt;n的key，则判断下一个节点，直到n==null，或者指定key&lt;n的key</span></span><br><span class="line">                    b = n;</span><br><span class="line">                    n = f;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">// 相等，则更新value即可，更新失败，就再来一次，一直到成功为止</span></span><br><span class="line">                    <span class="keyword">if</span> (onlyIfAbsent || n.casValue(v, <span class="keyword">value</span>))</span><br><span class="line">                        <span class="keyword">return</span> (V)v;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// restart if lost race to replace value</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// else c &lt; 0; fall through</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建一个节点，next指向n</span></span><br><span class="line">            Node&lt;K,V&gt; z = <span class="keyword">new</span> Node&lt;K,V&gt;(kkey, <span class="keyword">value</span>, n);</span><br><span class="line">            <span class="comment">// 将b的next指向新创建的节点，则新的链表为：b--&gt;new--&gt;n，即将新节点插入到b和n之间</span></span><br><span class="line">            <span class="keyword">if</span> (!b.casNext(n, z))</span><br><span class="line">                <span class="keyword">break</span>;         <span class="comment">// restart if lost race to append to b</span></span><br><span class="line">            <span class="comment">// 随机计算一个层级</span></span><br><span class="line">            <span class="keyword">int</span> level = randomLevel();</span><br><span class="line">            <span class="comment">// 将z插入到该层级</span></span><br><span class="line">            <span class="keyword">if</span> (level &gt; <span class="number">0</span>)</span><br><span class="line">                insertIndex(z, level);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中已经附上了大量的注释，这里再简单的梳理下流程。首先put()方法是调用内部的doPut()方法。<code>Comparable&lt; ? super K&amp;&gt; key = comparable(kkey);</code>这一句将key封装成一个Comparable对象，上面已经介绍了comparable这个方法。接着进入到死循环，循环第一步是调用<strong>findPredecessor(key)</strong>方法，该方法返回一个key最接近指定key的节点(最接近指的是小于等于)，该节点是处于最底层的，下面介绍下这个方法的逻辑。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span><br><span class="line">* @By Vicky:</span><br><span class="line"> * 在跳表中查找节点的key小于指定key，且处于最底层的节点，即找到指定key的前继节点</span><br><span class="line"> * 基本逻辑是从head(跳表的最高层链表的头结点)开始自右开始查找，当找到该层链表的最接近且小于指定key的节点时，往下开始查找，</span><br><span class="line"> * 最终找到最底层的那个节点</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;K,V&gt; findPredecessor(Comparable&lt;? <span class="keyword">super</span> K&gt; <span class="variable">key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">key</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don't postpone errors</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Index&lt;K,V&gt; q = head;<span class="comment">// head是跳表的最高层链表的头结点</span></span><br><span class="line">        Index&lt;K,V&gt; r = q.right;<span class="comment">// head的右边节点</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;<span class="comment">// 循环</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;<span class="comment">// r==null说明该层链表已经查找到头，且未找到符合条件的节点，需开始往下查找</span></span><br><span class="line">                Node&lt;K,V&gt; n = r.node;<span class="comment">// r的数据节点</span></span><br><span class="line">                K k = n.<span class="variable">key</span>;<span class="comment">// r的key，用于跟指定key进行比较</span></span><br><span class="line">                <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123; <span class="comment">// n的value为null，说明该节点已被删除</span></span><br><span class="line">                    <span class="keyword">if</span> (!q.unlink(r))<span class="comment">// 将该节点从链表移除，通过将其(n)前置节点的right指向其(n)的后置节点</span></span><br><span class="line">                        <span class="keyword">break</span>;           <span class="comment">// restart</span></span><br><span class="line">                    r = q.right;         <span class="comment">// reread r 移除value==null的n节点之后，继续从n的下一个节点查找</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">key</span>.compareTo(k) &gt; <span class="number">0</span>) &#123;<span class="comment">// 比较当前查找的节点的key与指定key，如果小于指定key，则继续查找，</span></span><br><span class="line">                						   <span class="comment">// 大于等于key则q即为该层链表最接近指定key的</span></span><br><span class="line">                    q = r;</span><br><span class="line">                    r = r.right;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 到这里有两种情况：1)该层链表已经查找完，仍未找到符号条件的节点 2)找到一个符合条件的节点</span></span><br><span class="line">            <span class="comment">// 开始往下一层链表进行查找</span></span><br><span class="line">            Index&lt;K,V&gt; d = q.down;</span><br><span class="line">            <span class="keyword">if</span> (d != <span class="keyword">null</span>) &#123;<span class="comment">// 从下层对应位置继续查找</span></span><br><span class="line">                q = d;</span><br><span class="line">                r = d.right;</span><br><span class="line">            &#125; <span class="keyword">else</span><span class="comment">// 如果无下层链表则直接返回当前节点的node</span></span><br><span class="line">                <span class="keyword">return</span> q.node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @By Vicky:将当前节点的right指向succ的right指向的节点，即将succ从链表移除</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">boolean</span> unlink(Index&lt;K,V&gt; succ) &#123;</span><br><span class="line">    <span class="keyword">return</span> !indexesDeletedNode() &amp;&amp; casRight(succ, succ.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的查找逻辑是：从head(跳表的最高层链表的头结点)开始自右开始查找，当找到该层链表的最接近且小于指定key的节点时，往下开始查找，最终找到最底层的那个节点。具体的代码可以看注释，应该说的挺明白的了，针对PUT方法，这个方法返回的节点就是将要插入的节点的前继节点，即新节点将插到该节点后面。下面是查找的示意图。</p>
<p><strong>findPredecessor查找示意图:</strong></p>
<p><img src="http://img.blog.csdn.net/20151106144215941" alt="findPredecessor查找示意图"></p>
<p>findPredecessor()介绍完，我们返回doPut()继续往下走。通过findPredecessor()返回节点b，获取b的next节点赋值n，接着进入死循环。判断n是否为null，n==null则说明b是链表的最后一个节点，则新节点直接插入到链表尾部即可，下面我们来看看n!=null的情况。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; f = <span class="keyword">n</span>.next;<span class="comment">// n的下一个节点</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">n</span> != b.next)     <span class="comment">// inconsistent read 此处增加判断，避免链表结构已被修改(针对节点b)</span></span><br><span class="line">   <span class="keyword">break</span>;;</span><br><span class="line">Object v = <span class="keyword">n</span>.value;</span><br><span class="line"><span class="keyword">if</span> (v == null) &#123;               <span class="comment">// n is deleted</span></span><br><span class="line">    <span class="keyword">n</span>.helpDelete(b, f);<span class="comment">// 将n从链表移除，b和f分别为n的前继节点与后继节点</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里如果v==n说明n是一个删除标记，用来标记其前继节点已被删除，即b已被删除</span></span><br><span class="line"><span class="comment">// 查看helpDelete()的注释</span></span><br><span class="line"><span class="keyword">if</span> (v == <span class="keyword">n</span> || b.value == null) <span class="comment">// b is deleted</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>这里首先判断在这段时间内b的next是否被修改，如果被修改则重新获取。再接着判断n和b是否被删除。这里说下helpDelete()方法，这个方法比较绕。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void helpDelete(<span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; b, <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; f) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * Rechecking links <span class="operator">and</span> then doing only one of the</span><br><span class="line">     * help-out stages per call tends to minimize CAS</span><br><span class="line">     * interference among helping threads.</span><br><span class="line">     */</span><br><span class="line">    if (f == next &amp;&amp; this == b.next) &#123;</span><br><span class="line">    	// 判断当前节点是否已添加删除标记，未添加则添加删除标记</span><br><span class="line">        if (f == null || f.value != f) // not already marked</span><br><span class="line">            appendMarker(f);</span><br><span class="line">        else</span><br><span class="line">        // 如果已添加删除标记，则将b的next指向f的next</span><br><span class="line">      	// 因为当前节点已添加了删除标记，所以这里的f只是一个标记：<span class="variable">value=</span>=本事的节点，其next才是链表的下一个节点</span><br><span class="line">        // 这里应该是remove方法相关，涉及到ConcurrentSkipListMap的删除方式</span><br><span class="line">            b.casNext(this, f.next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* @By Vicky:为当前节点增加一个删除标记 </span><br><span class="line"> * 将当前节点的next指向一个新节点，该新节点的next指向f，所以从结构是：当前--&gt;new--&gt;f</span><br><span class="line"> * 新节点的value就是他自己，参见<span class="keyword">Node</span><span class="identifier"></span><span class="title">(Node</span><span class="tag">&lt;K,V&gt;</span> next)构造函数</span><br><span class="line"> * 即删除标记就是将一个节点与其next节点之间插入一个value就是本事的节点</span><br><span class="line"> */</span><br><span class="line">boolean appendMarker(<span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt; f) &#123;</span><br><span class="line">    return casNext(f, new <span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt;(f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>介绍helpDelete()之前，先简单介绍ConcurrentSkipListMap是如何删除一个节点的，其实ConcurrentSkipListMap删除一个节点现将该节点的value值为NULL，然后再为这个节点添加一个删除标记，但是这个操作有可能失败，所以如果一个节点的value为NULL，或者节点有一个删除标记都被认为该节点已被删除。appendMarker()就是用来添加删除标记，helpDelete()是用来将添加了删除标记的节点清除。添加标记和如何清除在代码中的注释已经说的很清楚了，就不多说了。继续看doPut()。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较key，此处进行二次比较是避免链表已发生改变，比如b后面已被插入一个新的节点</span></span><br><span class="line"><span class="comment">// (findPredecessor时已经比较过b的next节点(n)的key与指定key的大小，因为n的key&gt;指定key才会返回b)</span></span><br><span class="line">int c = key.compareTo(<span class="keyword">n</span>.key);</span><br><span class="line"><span class="keyword">if</span> (c &gt; 0) &#123;<span class="comment">// 如果指定key&gt;n的key，则判断下一个节点，直到n==null，或者指定key&lt;n的key</span></span><br><span class="line">    b = <span class="keyword">n</span>;</span><br><span class="line">    <span class="keyword">n</span> = f;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c == 0) &#123;<span class="comment">// 相等，则更新value即可，更新失败，就再来一次，一直到成功为止</span></span><br><span class="line">    <span class="keyword">if</span> (onlyIfAbsent || <span class="keyword">n</span>.casValue(v, value))</span><br><span class="line">        <span class="keyword">return</span> (V)v;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// restart if lost race to replace value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// else c &lt; 0; fall through</span></span><br></pre></td></tr></table></figure>
<p>这几句是考虑当我们找到一个最接近指定key的节点之后有可能链表被修改，所以还需要进行二次校验，从b开始往右边查找，直至找到一个key大于指定key的节点，那么新的节点就插入到该节点前面。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个节点，next指向n</span></span><br><span class="line">Node&lt;K,V&gt; z = <span class="keyword">new</span> Node&lt;K,V&gt;(kkey, <span class="keyword">value</span>, n);</span><br><span class="line"><span class="comment">// 将b的next指向新创建的节点，则新的链表为：b--&gt;new--&gt;n，即将新节点插入到b和n之间</span></span><br><span class="line"><span class="keyword">if</span> (!b.casNext(n, z))</span><br><span class="line">    <span class="keyword">break</span>;         <span class="comment">// restart if lost race to append to b</span></span><br><span class="line"><span class="comment">// 随机计算一个层级</span></span><br><span class="line"><span class="keyword">int</span> level = randomLevel();</span><br><span class="line"><span class="comment">// 将z插入到该层级</span></span><br><span class="line"><span class="keyword">if</span> (level &gt; <span class="number">0</span>)</span><br><span class="line">    insertIndex(z, level);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>这几句就是创建一个新的节点，并插入到原链表中，所有的修改操作都是使用CAS，只要失败就会重试，直至成功，所以就算多线程并发操作也不会出现错误，而且通过CAS避免了使用锁，性能比用锁好很多。</p>
<hr>
<p><a href="http://vickyqi.com/2015/11/13/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentSkipListMap(%E7%BB%AD">请继续阅读后续部分~~~</a>/)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ConcurrentSkipListMap在JDK并发工具类使用范围不是很广，它是针对某一特殊需求而设计的——支持排序，同时支持搜索目标返回最接近匹配项的导航方法。一般情况下开发者很少会使用到该类，但是如果你有如上的特殊需求，那么ConcurrentSkipListMap将是一个很好地解决方案。 本文通过对JDK的ConcurrentSkipListMap的代码详细分析，深入分析其实现原理。<br>]]>
    
    </summary>
    
      <category term="JDK" scheme="http://vickyqi.com/tags/JDK/"/>
    
      <category term="JUC" scheme="http://vickyqi.com/tags/JUC/"/>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="JDK源码" scheme="http://vickyqi.com/categories/Java/JDK%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JDK并发工具类源码学习系列——ConcurrentLinkedQueue]]></title>
    <link href="http://vickyqi.com/2015/10/29/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentLinkedQueue/"/>
    <id>http://vickyqi.com/2015/10/29/JDK并发工具类源码学习系列——ConcurrentLinkedQueue/</id>
    <published>2015-10-29T13:51:00.000Z</published>
    <updated>2015-11-13T06:08:10.000Z</updated>
    <content type="html"><![CDATA[<p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现，该算法在Michael &amp; Scott算法上进行了一些修改, Michael &amp; Scott算法的详细信息可以参见<a href="http://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf" target="_blank" rel="external">参考资料一</a>。<br><a id="more"></a><br>上一篇文章介绍了JDK java.util.concurrent包下很重要的一个类：<a href="http://vickyqi.com/2015/10/26/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentHashMap/">ConcurrentHashMap</a>，今天来看下另一个重要的类——ConcurrentLinkedQueue。<br>在多线程编程环境下并发安全队列是不可或缺的一个重要工具类，为了实现并发安全可以有两种方式：一种是阻塞式的，例如：LinkedBlockingQueue；另一种即是我们将要探讨的非阻塞式，例如：ConcurrentLinkedQueue。相比较于阻塞式，非阻塞的最显著的优点就是性能，非阻塞式算法使用CAS来原子性的更新数据，避免了加锁的时间，同时也保证了数据的一致性。</p>
<h4 id="简单介绍"><strong>简单介绍</strong></h4><p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现，该算法在Michael &amp; Scott算法上进行了一些修改, Michael &amp; Scott算法的详细信息可以参见<a href="http://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf" target="_blank" rel="external">参考资料一</a>。</p>
<h4 id="结构预览"><strong>结构预览</strong></h4><p>首先看看结构图：</p>
<p><strong>图1：ConcurrentLinkedQueue结构图：</strong><br><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blogConcurrentLinkedQueue%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="ConcurrentLinkedQueue结构图"><br>从图中可以看到ConcurrentLinkedQueue中包含两个内部类：Node&lt;E&gt;和Itr。Node&lt;E&gt;用来表示ConcurrentLinkedQueue链表中的一个节点，通过Node&lt;E&gt;的next字段指向下一个节点，从而形成一个链表结构；Itr实现Iterator&lt;E&gt;接口，用来遍历ConcurrentLinkedQueue。ConcurrentLinkedQueue中的方法不多，其中最主要的两个方法是：offer(E)和poll()，分别实现队列的两个重要的操作：入队和出队。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>offer(E)</td>
<td>插入一个元素到队列尾部</td>
</tr>
<tr>
<td>poll()</td>
<td>从队列头部取出一个元素</td>
</tr>
<tr>
<td>add(E)</td>
<td>同offer(E)</td>
</tr>
<tr>
<td>peek()</td>
<td>获取头部元素，但不删除</td>
</tr>
<tr>
<td>isEmpty()</td>
<td>判断队列是否为空</td>
</tr>
<tr>
<td>size()</td>
<td>获取队列长度(元素个数)</td>
</tr>
<tr>
<td>contains(Object)</td>
<td>判断队列是否包含指定元素</td>
</tr>
<tr>
<td>remove(Object)</td>
<td>删除队列中指定元素</td>
</tr>
<tr>
<td>toArray(T[])</td>
<td>将队列的元素复制到一个数组</td>
</tr>
<tr>
<td>iterator()</td>
<td>返回一个可遍历该队列的迭代器</td>
</tr>
</tbody>
</table>
<p>下面会着重分析offer(E)和poll()两个方法，同时会讲解remove(Object)和iterator()方法。</p>
<h4 id="常用方法解读"><strong>常用方法解读</strong></h4><h5 id="入队——offer"><strong>入队——offer</strong></h5><p>首先看看入队操作，由于是无阻塞的队列，所以整个入队操作是在无锁模式下进行的，下面来分析下JDK到底是如何实现无锁并保证安全性的。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Inserts the specified element at the tail of this queue.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Queue#offer&#125;)</span><br><span class="line"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//①</span></span><br><span class="line">        Node&lt;E&gt; t = tail;<span class="comment">//②</span></span><br><span class="line">        Node&lt;E&gt; s = t.getNext();<span class="comment">//②</span></span><br><span class="line">        <span class="keyword">if</span> (t == tail) &#123;<span class="comment">//③</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;<span class="comment">//④</span></span><br><span class="line">                <span class="keyword">if</span> (t.casNext(s, n)) &#123;<span class="comment">//⑥</span></span><br><span class="line">                    casTail(t, n);<span class="comment">//⑦</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                casTail(t, s);<span class="comment">//⑤</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码不长，但是思路还是很巧妙的，下面我们逐句深入分析每一行代码。<code>if (e == null) throw new NullPointerException(); Node<e> n = new Node<e>(e, null);</e></e></code>检查NULL，避免NullPointerException，然后创建一个Node，该Node的item为传入的参数e，next为NULL。<code>for (;;) {}</code>接着是一个死循环，死循环保证该入队操作能够一直重试直至入队成功。<code>Node<e> t = tail; Node<e> s = t.getNext();</e></e></code>使用局部变量t引用tail节点，同时获取tail节点的next节点，赋予变量s。<code>if (t == tail) {}</code>只有在t==tail的情况下才会执行入队操作，否则进行下一轮循环，直到t==tail，因为是无锁模式，所以如果同时有多个线程在执行入队操作，那么在一个线程读取了tail之后，很可能会有其他线程已经修改了tail（<strong>此处的修改是指将tail指向另一个节点，所以t还引用着原来的节点，导致t!=tail，而并非是修改了tail所指向的节点的值</strong>），此处的判断避免了一开始的错误，但是并不能保证后续的执行过程中不会插入其他线程的操作，其实ConcurrentLinkedQueue的设计使得if内的代码即使在有其他线程插入的情况下依旧能够很好地执行，下面我们接着分析。</p>
<p><code>if (s == null) {} else { casTail(t, s); }</code>这里判断s（tail的next是否为NULL），如果不为NULL，则直接将tail指向s。这里需要说明一下：由于tail指向的是队列的尾部，所以tail的next应该始终是NULL，那么当发生tail的next不为NULL，则说明当前队列处于不一致状态，这时当前线程需要帮助队列进入一致性状态，这就是ConcurrentLinkedQueue设计的巧妙之处！那么如果帮助队列进入一致性状态呢？这个问题我们先留着，继续看什么情况下会导致队列进入不一致状态！<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t.casNext(s, <span class="keyword">n</span>)) &#123;</span><br><span class="line">	casTail(t, <span class="keyword">n</span>);</span><br><span class="line">    <span class="keyword">return</span> true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这几句代码完成了入队的操作，第一步CAS的设置t（指向tail）的next为n（新创建的节点），该更新操作能够完成的前提是t的next值==s，即tail的next值在该线程首次读取期间并未发生变化。此处的CAS操作保证了tail的next值更新的原子性，所以不会出现不一致情况。当成功更新了tail的next节点之后，接下来就是原子性的更新tail为n，此处如果更新成功，则入队顺利完成完成，但是奇怪的是如果此处更新失败，入队依旧是成功的！为什么呢？看下文。</p>
<p>我们试想如果一个线程成功的原子性更新了tail的next值为新创建的节点，由于Node的next是volatile修饰的，所以会立即被之后的所有线程可见，那么就会出现tail未变化但是tail的next已经不是NULL了，此时就会出现上面提到的tail的next不为NULL的情况了，现在我们再来看看上面是如何处理这种情况的，<code>casTail(t, s);</code>，从这句可以看出当一个线程看到tail的next不为NULL时就会直接将tail更新成s（tail的next所指向的节点），即将tail指向其next节点，当然这里的更新也是CAS保证的原子性更新。为什么敢这么大胆，正是因为如果当前线程（T1）看到tail的next不为NULL，那么必然是有一个线程（T2）处于入队操作中，且成功执行了<code>t.casNext(s, n)</code>（将新创建的节点赋到tail的next上），正准备执行<code>casTail(t, n);</code>（将tail执行其next指向的节点），那么T1直接将T2准备做的工作完成，然后再进入循环重新进行入队操作，而T2也不在乎自己这一步是否顺利完成，反正只要有人完成了就行，所以T2就直接返回入队成功，最终T1帮助T2顺利完成了入队操作，并且全程无锁，此设计真的是巧妙啊~~~</p>
<p>下面我们使用流程图形象的描绘下入队过程，整个入队方法被划分成7步（见上面的代码中的注释）。说明：虽然入队是在无锁模式下进行，但是由于使用CAS进行原子性更新，所以很多地方其实还是实现了线程安全的，除了⑥-&gt;⑦，下面的图描绘的也正是⑥-&gt;⑦这一步可能出现的冲突情况。</p>
<p><strong>图2：ConcurrentLinkedQueue入队流程图：</strong><br><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/ConcurrentLinkedQueue%E5%85%A5%E9%98%9F%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="ConcurrentLinkedQueue入队流程图"></p>
<p>上面介绍了ConcurrentLinkedQueue是如何实现无锁入队的，但是我们只说明了多个线程同时入队操作是线程安全的，但是如果多个线程同时进行入队和出队，以及删除操作呢？这个问题在下面分析另外两个方法时会提到，同时最后也会进行一个总结，下面我们先看看删除操作是如何实现的。</p>
<h5 id="删除——remove"><strong>删除——remove</strong></h5><p>先介绍删除，是因为出队操作有个地方需要在这里提前介绍下。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="keyword">null</span>; p = p.getNext()) &#123;<span class="comment">// ②</span></span><br><span class="line">        E item = p.getItem();<span class="comment">// ③</span></span><br><span class="line">        <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            o.equals(item) &amp;&amp;</span><br><span class="line">            p.casItem(item, <span class="keyword">null</span>))<span class="comment">// ④</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>源码中的注释申明了remove方法会使用equals()判断两个节点的值与待删除的值是否相同，同时如果队列有多个与待删除值相同的节点则只删除最前面的一个节点。</p>
<p>同样remove()方法也是无锁模式，①判断是否为NULL，②从队列头部开始查找，③获取每个节点的item值，用于跟o进行equals比较，前面三步都很平常，重点在④，<code>if (item != null &amp;&amp; o.equals(item) &amp;&amp; p.casItem(item, null))</code>这里首先判断item不为NULL，然后判断item与o相等，前面两个都满足的话，那说明已经查找到一个节点的值与待删除的值一样，后面就是删除该节点，这里删除其实并非真的删除，而只是原子性的将节点的item值设置为NULL。从上面的分析可以看出ConcurrentLinkedQueue的删除只是将队列中的某个节点值置为NULL，由于Node的item是volatile的，所以不存在线程安全问题，同时由于remove并未修改队列的结构，所以多个线程同时进行remove，或者同其他方法一起进行也不会发生线程安全性问题。</p>
<h5 id="出队——poll"><strong>出队——poll</strong></h5><p>出队从逻辑上来说就是从队列的头部往外取出数据并删除，下面看看ConcurrentLinkedQueue是如何实现无锁出队的。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">E</span> poll() &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">// ①</span></span><br><span class="line">        Node&lt;<span class="keyword">E</span>&gt; <span class="keyword">h</span> = head;<span class="comment">// ②</span></span><br><span class="line">        Node&lt;<span class="keyword">E</span>&gt; t = tail;<span class="comment">// ②</span></span><br><span class="line">        Node&lt;<span class="keyword">E</span>&gt; first = <span class="keyword">h</span>.getNext();<span class="comment">// ②</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">h</span> == head) &#123;<span class="comment">// ③</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">h</span> == t) &#123;<span class="comment">// ④</span></span><br><span class="line">                <span class="keyword">if</span> (first == null)<span class="comment">// ⑤</span></span><br><span class="line">                    <span class="keyword">return</span> null;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    casTail(t, first);<span class="comment">// ⑥</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(<span class="keyword">h</span>, first)) &#123;<span class="comment">// ⑦</span></span><br><span class="line">                <span class="keyword">E</span> item = first.getItem();<span class="comment">// ⑧</span></span><br><span class="line">                <span class="keyword">if</span> (item != null) &#123;<span class="comment">// ⑨</span></span><br><span class="line">                    first.setItem(null);<span class="comment">// ⑩</span></span><br><span class="line">                    <span class="keyword">return</span> item;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// else skip over deleted item, continue loop,</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>出队的步骤略多些，不过理解了也就很简单了。首先①是一个死循环；②的三步分别是获取head/tail/head.next三个节点；③判断h==head，避免操作过程中已有其他线程移动了head；④判断head是否等于tail，即队列是否为NULL，说到这里我们先来看看head和tail在队列中到底处于什么位置。我们用一个队列入队出队的时序图来描绘下在入队和出队过程中head和tail到底是如何变化的。</p>
<p><strong>图3：ConcurrentLinkedQueue队列时序图：</strong><br><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blog/ConcurrentLinkedQueue%E9%98%9F%E5%88%97%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="ConcurrentLinkedQueue队列"><br>从图中我们可以看出head的next指向的是队列的第一个元素，我们出队也是将head的next指向的元素出队，同时head==tail说明队列已经没有元素了。明白了这两点我们再接着④分析，如果④这里为真，说明队列已经为NULL，接着⑤判断f（head的next指向的节点）是否为NULL，不为NULL则执行⑥将tail指向f，到这里如果理解了上面入队操作，那么应该是可以理解这一步的用意的——帮助其他线程执行入队操作，跟入队时的⑤是一样的，因为head==tail，head的next不为NULL，则说明tail的next不为NULL，所以要将tail重新指向他的next，帮助正在执行入队的线程完成入队工作。理解了这一步那么出队操作就已经理解了一大半了，下面继续看⑦⑧⑨⑩。</p>
<p>如果head!=tail，则队列不为NULL，那么直接将head指向下一个节点，将当前节点踢出队列即可，当然需要CAS保证原子性更新，然后将踢出队列的节点的item取出返回，并置为NULL即完成了出队操作。这里需要注意的是如果被踢出队列的节点的item是NULL，说明该节点已经被删除了（因为remove()方法只是将节点的item设置为NULL，而不将节点踢出队列），那就只能再次循环了。再提一点，为什么⑦⑧⑨⑩能够被线程安全的执行，因为在⑦这一步是原子更新的，而且更新之后这个节点就立即不会被其他任何线程访问到了，所以后面⑧⑨⑩想怎么处理都是安全的。</p>
<p>到这里出队操作应该很清楚了，下面就来综合分析下为什么针对ConcurrentLinkedQueue的整个入队/出队/删除都是不需要锁的。</p>
<ol>
<li>上面已经分析了如果多个线程同时访问其中任一个方法（offer/poll/remove）都是无需加锁而且线程安全的</li>
<li>由于remove方法不修改ConcurrentLinkedQueue的结构，所以跟其他两个方法都不会有冲突</li>
<li>如果同时两个线程，一个入队，一个出队，在队列不为NULL的情况下是不是有任何问题的，因为一个操作tail，一个操作head，完全不相关。但是如果队列为NULL时还是会发生冲突的，因为tail==head。这里我们在分析出队时也提到了，如果出队线程发现tail的next不为NULL，那么就会感知到当前有一个线程在执行入队操作，所以出队线程就会帮助入队线程完成入队操作，而且每个操作都是通过CAS保证原子性更新，所以就算同时两个线程，一个入队，一个出队也不会发生冲突。</li>
</ol>
<p>综上，ConcurrentLinkedQueue最终实现了无锁队列。</p>
<h4 id="使用场景"><strong>使用场景</strong></h4><p>ConcurrentLinkedQueue适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的ConcurrentLinkedQueue来替代。下面我们来简单对比下ConcurrentLinkedQueue与我们常用的阻塞队列LinkedBlockingQueue的性能。<br><strong>表1：入队性能对比</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">线程数</th>
<th style="text-align:left">ConcurrentLinkedQueue耗时(ms)</th>
<th style="text-align:left">LinkedBlockingQueue耗时(ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">22</td>
<td style="text-align:left">29</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">50</td>
<td style="text-align:left">59</td>
</tr>
<tr>
<td style="text-align:left">20</td>
<td style="text-align:left">99</td>
<td style="text-align:left">112</td>
</tr>
<tr>
<td style="text-align:left">30</td>
<td style="text-align:left">139</td>
<td style="text-align:left">171</td>
</tr>
</tbody>
</table>
<p>测试数据：N个线程，每个线程入队10000个元素。</p>
<hr>
<h4 id="参考文章"><strong>参考文章</strong></h4><p><a href="http://www.infoq.com/cn/articles/ConcurrentLinkedQueue" target="_blank" rel="external">聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析</a><br><a href="http://www.ibm.com/developerworks/cn/java/j-lo-concurrent/index.html" target="_blank" rel="external">非阻塞算法在并发容器中的实现</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现，该算法在Michael &amp; Scott算法上进行了一些修改, Michael &amp; Scott算法的详细信息可以参见<a href="http://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf">参考资料一</a>。<br>]]>
    
    </summary>
    
      <category term="JDK" scheme="http://vickyqi.com/tags/JDK/"/>
    
      <category term="JUC" scheme="http://vickyqi.com/tags/JUC/"/>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="JDK源码" scheme="http://vickyqi.com/categories/Java/JDK%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JDK并发工具类源码学习系列——ConcurrentHashMap]]></title>
    <link href="http://vickyqi.com/2015/10/26/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentHashMap/"/>
    <id>http://vickyqi.com/2015/10/26/JDK并发工具类源码学习系列——ConcurrentHashMap/</id>
    <published>2015-10-26T10:19:11.000Z</published>
    <updated>2015-11-13T06:01:20.000Z</updated>
    <content type="html"><![CDATA[<p>ConcurrentHashMap类在我的开发过程中经常被使用，个人觉得如果在共享一个Map时，如果无法判断是否需要加锁，那么就干脆直接使用ConcurrentHashMap，即能保证并发安全，同时性能也不会有太多下降，因为ConcurrentHashMap可实现无锁读，不过内存会占用的多些，但是并不明显，基本可以忽略。<br><a id="more"></a></p>
<p>作为JDK并发工具类源码学习系列的第一个被分析的类，ConcurrentHashMap类在我的开发过程中经常被使用。个人觉得如果在共享一个Map时，如果无法判断是否需要加锁，那么就干脆直接使用ConcurrentHashMap，即能保证并发安全，同时性能也不会有太多下降，因为ConcurrentHashMap可实现无锁读，不过内存会占用的多些，但是并不明显，基本可以忽略。<br>下面我们就来看看ConcurrentHashMap类的内部构造。</p>
<h4 id="结构预览"><strong>结构预览</strong></h4><h5 id="类定义"><strong>类定义</strong></h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap&lt;K</span>, <span class="title">V&gt;</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractMap&lt;K</span>, <span class="title">V&gt;</span> <span class="title">implements</span> <span class="title">ConcurrentMap&lt;K</span>, <span class="title">V&gt;</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>上面是ConcurrentHashMap类的定义，从ConcurrentHashMap的定义可以看出ConcurrentHashMap是实现了ConcurrentMap接口，而非直接实现Map接口。同时ConcurrentMap的子接口还有一个ConcurrentNavigableMap，表示可支持导航的并发Map。可见ConcurrentMap接口定义可支持并发，NavigableMap接口定义可支持导航，SortedMap接口定义可支持排序，NavigableMap继承自SortedMap。从Map的API介绍可以看出Java Collections Framework家族中重要一员——Map的组织结构——通过接口定义Map的行为，或者说Map可支持的功能，多个接口之间可交叉，如ConcurrentNavigableMap即实现ConcurrentMap接口又实现NavigableMap接口。</p>
<h5 id="类结构"><strong>类结构</strong></h5><p><img src="http://img.blog.csdn.net/20151009213243833" alt="ConcurrentHashMap结构图"><br>从图中可以看出ConcurrentHashMap内部包含了多个内部类，其中最重要的也是我们最需要关心的是：<strong>Segment</strong>和<strong>HashEntry</strong>。<br><strong>Segment</strong>是ConcurrentHashMap非常重要的一个内部类，是ConcurrentHashMap实现高并发的关键点，Segment在ConcurrentHashMap中承担着所有的操作，即所有对ConcurrentHashMap的操作最终都会对Segment进行操作。因为Segment保存了最终的数据，而ConcurrentHashMap只是保存了一个Segment的数组。ConcurrentHashMap通过N个Segment将数据切分成N块，而每块之间是互不影响的，所以理论上可以同时并行的执行N个需要加锁的操作，这就是ConcurrentHashMap并发的基础。<br><strong>HashEntry</strong>同HashMap中的Entry，每个HashEntry是一个节点，保存key和value，以及下一个节点。HashEntry中的key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型，可见HashEntry类的value是可变的，其他的key和next都是不可变的。<br>EntryIterator，EntrySet，HashIterator，KeyIterator，KeySet，ValueIterator，Values是辅助ConcurrentHashMap实现遍历的内部类。<br>下面简单介绍下<strong>Segment</strong>和<strong>HashEntry</strong>类。<br><strong>HashEntry</strong><br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> HashEntry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">volatile</span> V value;</span><br><span class="line">        <span class="keyword">final</span> HashEntry&lt;K,V&gt; <span class="keyword">next</span>;</span><br><span class="line"></span><br><span class="line">        HashEntry(K key, <span class="keyword">int</span> hash, HashEntry&lt;K,V&gt; <span class="keyword">next</span>, V value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">next</span> = <span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		@SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; HashEntry&lt;K,V&gt;[] newArray(<span class="keyword">int</span> i) &#123;</span><br><span class="line">		    <span class="keyword">return</span> <span class="keyword">new</span> HashEntry[i];</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>HashEntry类的结构很简单，就是四个变量，一个构造函数，一个static方法。由于没有任何getter和setter方法，所以对其操作是直接访问变量。在 ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。所以链表中节点的顺序和插入的顺序相反。<br><strong>Segment</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ReentrantLock</span> <span class="title">implements</span> <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></p>
<p>Segment继承自ReentrantLock ，所以它可以作为一个锁使用，其在ConcurrentHashMap也正是作为一个锁来使用的。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> <span class="keyword">count</span>;<span class="comment">//Segment中保存的元素数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;<span class="comment">//记录Segment被修改的次数，用于在读取时判断读取期间改Segment是否有过修改，有的话则重试</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> threshold;<span class="comment">//阀值，元素数量达到该值则会进行自动扩展</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;<span class="comment">//桶，一个HashEntry的数组，按HashCode值散列保存，采用链表解决hash碰撞问题</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;<span class="comment">//负载因子</span></span><br></pre></td></tr></table></figure>
<p><strong>count </strong>变量是一个计数器，它表示每个 Segment 对象管理的 table 数组（若干个 HashEntry 组成的链表）包含的 HashEntry 对象的个数。每一个 Segment 对象都有一个 count 对象来表示本 Segment 中包含的 HashEntry 对象的总数。注意，之所以在每个 Segment 对象中包含一个计数器，而不是在 ConcurrentHashMap 中使用全局的计数器，是为了避免出现“热点域”而影响 ConcurrentHashMap 的并发性。<br><img src="http://img.blog.csdn.net/20151012120235225" alt="Segment结构"><br>从Segment拥有的方法可以看出，针对ConcurrentHashMap的操作基本上都会调用具体某个Segment的对应方法，如put会调用Segment的put方法。所以Segment是最终的操作类。</p>
<p>下图是依次插入 ABC 三个 HashEntry 节点后，Segment 的结构示意图。<br><img src="http://img.blog.csdn.net/20151012120621035" alt="插入三个节点后 Segment 的结构示意图"><br>Segment的方法会在介绍ConcurrentHashMap的方法时进行解释，这里先不介绍。</p>
<h4 id="构造器解读"><strong>构造器解读</strong></h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上的构造器都只是一个个重载函数，最终都会调用下面的构造器。其中使用到了三个常量：</p>
<ul>
<li>DEFAULT_INITIAL_CAPACITY：默认初始容量</li>
<li>DEFAULT_LOAD_FACTOR：默认加载因子</li>
<li>DEFAULT_CONCURRENCY_LEVEL：默认并发级别，该值决定一个包含多少个Segment，即将ConcurrentHashMap切分成多少块</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span><br><span class="line">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">        <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">            ++sshift;</span><br><span class="line">            ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">        segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.segments = Segment.newArray(ssize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">            ++c;</span><br><span class="line">        <span class="keyword">int</span> cap = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i)</span><br><span class="line">            <span class="keyword">this</span>.segments[i] = <span class="keyword">new</span> Segment&lt;K,V&gt;(cap, loadFactor);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该构造函数需要制定初始容量、加载因子以及并发级别，对应上面提到的三个常量（默认值）。代码前几句是对参数进行正确性校验。<strong>// Find power-of-two sizes best matching arguments</strong>这句注释的意思是寻找一个参数的最佳匹配值：最接近指定的参数的2的幂方值。下面我们对照着代码来说明这句话的含义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个ssize变量，该变量就是concurrencyLevel的最佳匹配值，可以看见首先是循环，直到ssize&gt;=concurrencyLevel，所以最佳匹配值是大于等于指定参数的，循环里面每次会将ssize右移一位，即*2，所以最终得到的值就是一个最接近且大于等于concurrencyLevel的2次幂方值。同时定义了一个sshift变量，该变量随着ssize的每次右移而+1，最终得到的即是ssize是2的多少次方，即sszie=2^sshift。继续往下看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">segmentShift = <span class="number">32</span> - sshift;<span class="comment">//偏移量</span></span><br><span class="line">segmentMask = ssize - <span class="number">1</span>;<span class="comment">//掩码值</span></span><br><span class="line"><span class="keyword">this</span>.segments = Segment.newArray(ssize);<span class="comment">//初始化segments数组</span></span><br></pre></td></tr></table></figure>
<p>segmentShift以及segmentMask在后面将一个hash映射到某一个segments时使用，目的是将hash均匀的分配到每个segments，具体为什么使用这两个来进行均匀分配我们这里不介绍。最后一句是初始化一个segments数组，大小是ssize，而非参数concurrencyLevel值。下面继续看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"><span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">    ++c;</span><br><span class="line"><span class="keyword">int</span> cap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">    cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i)</span><br><span class="line">    <span class="keyword">this</span>.segments[i] = <span class="keyword">new</span> Segment&lt;K,V&gt;(cap, loadFactor);</span><br></pre></td></tr></table></figure>
<p>initialCapacity是构造器指定的初始化容量，ssize是segments数组大小，所以c的值就是每个segments的容量。下面定义了一个cap，这里的cap和前面的ssize是一个含义，即选择一个最接近且大于等于c的2的幂方值，然后初始化segments数组，传入的参数有cap（segment容量）和loadFactor（负载因子）。这里选择cap作为segment容量，而非c，是出于方便后期对segment的容量进行扩充考虑，如果容量是2的幂方，那么想要将容量扩充一倍只需右移1位即可，同时保证依旧是2的幂方。<br>对于segment的初始化很简单，对loadFactor赋值，然后根据指定的初始容量创建一个HashEntry数组，并计算出threshold（阀值，当segment中的元素超过这个阈值则进行容量扩充）。</p>
<h4 id="常用方法解读"><strong>常用方法解读</strong></h4><p>ConcurrentHashMap实现了Map接口，那么他的核心方法包括我们常用的put(K, V)、get(Object)、remove(Object)、contains(Object)、size()，同时继承自ConcurrentMap让他包含了putIfAbsent(K, V)、remove(Object, Object)、replace(K, V, V)、replace(K, V)四个并发方法。后面的四个并发方法是ConcurrentMap为我们提供的在并发情景下使用的工具方法，都是基于CAS来实现的。<br>在看put(K, V)、get(Object)等方法实现之前，先来看下这两个方法：hash(int)和segmentFor(int)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* ---------------- Small Utilities -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Applies a supplemental hash function to a given hashCode, which</span><br><span class="line"> * defends against poor quality hash functions.  This is critical</span><br><span class="line"> * because ConcurrentHashMap uses power-of-two length hash tables,</span><br><span class="line"> * that otherwise encounter collisions for hashCodes that do not</span><br><span class="line"> * differ in lower or upper bits.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Spread bits to regularize both segment and index locations,</span></span><br><span class="line">    <span class="comment">// using variant of single-word Wang/Jenkins hash.</span></span><br><span class="line">    h += (h &lt;&lt;  <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt;   <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt;  <span class="number">6</span>);</span><br><span class="line">    h += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns the segment that should be used for key with given hash</span><br><span class="line"> * @param hash the hash code for the key</span><br><span class="line"> * @return the segment</span><br><span class="line"> */</span></span><br><span class="line">final Segment&lt;K,V&gt; segmentFor(<span class="keyword">int</span> hash) &#123;</span><br><span class="line">    <span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码中对这两个方法的注释是：Small Utilities，即小工具方法。源码中对于hash方法的注释的意思是：该方法是一个补充hash方法，ConcurrentHashMap的hash表的长度是2的幂方，使用该补充hash函数可降低一些质量差的hash函数发生的碰撞概率。具体如何实现的就不看了，就算看懂了代码也很难理解这样做的原因，所以不浪费时间。segmentFor是为一个hash值找到它应该去的segment，这里使用到了segmentShift以及segmentMask，还记得segmentShift是32-sshift，这里将hash值无符号左移segmentShift位，即取hash值的高sshift位，然后同segmentMask按位与运算。其实就是取hash值的高sshift位将值限制在0~ssize之间，然后与ssize-1取余得到segments数组的下标（取高位是因为更加均匀，低位的重复率比高位高，臆测~！！！）。<br>了解了上面两个方法，下面我们就来看看put(K, V)、get(Object)、remove(Object)这三个方法的具体实现。</p>
<h5 id="put(K,_V)"><strong>put(K, V)</strong></h5><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="keyword">return</span> segmentFor(hash).put(key, hash, <span class="keyword">value</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap的put方法内部只是根据key的hash值找到对应的Segement，然后调用Segement的put方法，注意Segement的put方法的第四个参数，这里穿的值是false。我们主要分析下Segement的put方法。Segement在这里的作用就是将元素均匀分成N等份，各个Segement之间互不干扰，读写也不会发生冲突，降低并发要求。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">put</span>(<span class="params">K key, <span class="keyword">int</span> hash, V <span class="keyword">value</span>, boolean onlyIfAbsent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> c = count;</span><br><span class="line">        <span class="keyword">if</span> (c++ &gt; threshold) <span class="comment">// ensure capacity</span></span><br><span class="line">            rehash();</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        HashEntry&lt;K,V&gt; first = tab[index];</span><br><span class="line">        HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key)))</span><br><span class="line">            e = e.next;</span><br><span class="line"></span><br><span class="line">        V oldValue;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldValue = e.<span class="keyword">value</span>;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                e.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            oldValue = <span class="keyword">null</span>;</span><br><span class="line">            ++modCount;</span><br><span class="line">            tab[index] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(key, hash, first, <span class="keyword">value</span>);</span><br><span class="line">            count = c; <span class="comment">// write-volatile</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先第一步就是lock，看来再NB的并发类在写时也需要lock啊。读取count值，从count的注释可以看出该值是记录Segment包含的元素数量，volatile修饰的（这里利用了volatile变量的内存可见性）。然后判断增加之后元素数量是否超过阈值，超过的话提前扩容。接着找到该hash对应的table（桶），简单的取余操作。找到该table的第一个元素——first，因为ConcurrentHashMap使用链表来解决hash冲突问题，所以这里的table是一个链表。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">e</span> != null &amp;&amp; (<span class="keyword">e</span>.hash != hash || !key.equals(<span class="keyword">e</span>.key)))</span><br><span class="line">      <span class="keyword">e</span> = <span class="keyword">e</span>.next;</span><br></pre></td></tr></table></figure>
<p>通过循环，并通过比较hash值以及equals()校验，寻找与key相同的已存在的元素。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">V oldValue;</span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">    oldValue = e.<span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">        e.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    oldValue = <span class="keyword">null</span>;</span><br><span class="line">    ++modCount;</span><br><span class="line">    tab[index] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(key, hash, first, <span class="keyword">value</span>);</span><br><span class="line">    count = c; <span class="comment">// write-volatile</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>e!=null说明找到与要插入的元素key相同的元素，那么onlyIfAbsent=false则直接将原元素的value值替换，返回原值，由于HashEntry的value是volatile的，所以修改之后会立即被后续线程可见；onlyIfAbsent=true则不做任何操作。e==null时，modCount自增（modCount记录了对该Segment的进行的结构性修改的次数，modCount值使得在进行批量读取时能够知道在读取期间Segment结构是否被修改来决定是否进行加锁读取）。<strong>tab[index] = new HashEntry(key, hash, first, value)</strong>这句就是将被插入的元素添加到链表中，但是插入的位置是头部，而非尾部。HashEntry的构造器传入一个HashEntry对象，该对象是链表原来的头部，被作为新创建的节点的next指针，所以新的链表的头部元素是新增加的，后面接着是原来的链表。<br>注意：此处的lock并非对整个Map进行加锁，而只是对该Segment进行加锁，所以如果一个线程进行put操作，其他的另外15个（ssize-1）Segment仍是可访问的。</p>
<h5 id="remove(Object)"><strong>remove(Object)</strong></h5><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public V remove(Object <span class="built_in">key</span>) &#123;</span><br><span class="line">	<span class="typename">int</span> hash = hash(<span class="built_in">key</span>.hashCode());</span><br><span class="line">    return segmentFor(hash).remove(<span class="built_in">key</span>, hash, <span class="built_in">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Remove; match on <span class="built_in">key</span> only if <span class="built_in">value</span> <span class="built_in">null</span>, else match both.</span><br><span class="line"> */</span><br><span class="line">V remove(Object <span class="built_in">key</span>, <span class="typename">int</span> hash, Object <span class="built_in">value</span>) &#123;</span><br><span class="line">	<span class="comment">//由于remove是结构性修改，所以第一步便是lock</span></span><br><span class="line">    lock();</span><br><span class="line">    try &#123;</span><br><span class="line">	    <span class="comment">//读取count值，此处是利用volatile变量的内存可见性来保证读线程能够及时的读取到最新值(后面会单独介绍)</span></span><br><span class="line">        <span class="typename">int</span> c = <span class="built_in">count</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//是根据key的hashCode找到该节点对应的桶</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="typename">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        HashEntry&lt;K,V&gt; <span class="built_in">first</span> = tab[index];</span><br><span class="line">        HashEntry&lt;K,V&gt; e = <span class="built_in">first</span>;</span><br><span class="line">        <span class="comment">//循环找到该节点</span></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="built_in">null</span> &amp;&amp; (e.hash != hash || !<span class="built_in">key</span>.equals(e.<span class="built_in">key</span>)))</span><br><span class="line">            e = e.<span class="built_in">next</span>;</span><br><span class="line"></span><br><span class="line">        V oldValue = <span class="built_in">null</span>;</span><br><span class="line">        if (e != <span class="built_in">null</span>) &#123;</span><br><span class="line">        <span class="comment">//找到待删除节点</span></span><br><span class="line">            V v = e.<span class="built_in">value</span>;</span><br><span class="line">            <span class="comment">//如果value==null，则无需关心节点的值是否与指定值相同，否则只有在两者相同情况才可删除</span></span><br><span class="line">            if (<span class="built_in">value</span> == <span class="built_in">null</span> || <span class="built_in">value</span>.equals(v)) &#123;</span><br><span class="line">                oldValue = v;</span><br><span class="line">                <span class="comment">// All entries following removed node can stay</span></span><br><span class="line">                <span class="comment">// in list, but all preceding ones need to be</span></span><br><span class="line">                <span class="comment">// cloned.</span></span><br><span class="line">                ++modCount;</span><br><span class="line">                HashEntry&lt;K,V&gt; newFirst = e.<span class="built_in">next</span>;</span><br><span class="line">                for (HashEntry&lt;K,V&gt; p = <span class="built_in">first</span>; p != e; p = p.<span class="built_in">next</span>)</span><br><span class="line">                    newFirst = new HashEntry&lt;K,V&gt;(p.<span class="built_in">key</span>, p.hash,</span><br><span class="line">                                                  newFirst, p.<span class="built_in">value</span>);</span><br><span class="line">                tab[index] = newFirst;</span><br><span class="line">                <span class="built_in">count</span> = c; <span class="comment">// write-volatile</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依旧调用的是对应的Segment的remove()方法。由于remove是结构性修改，所以需要进行加锁操作。在删除一个节点时，为了不影响正在遍历链表的线程，这里采用了复制方式，而非直接移除待删除节点。具体工作方式：将待删除节点之后的节点不动，而待删除节点之后的节点复制到另外一个链表，看代码：<code>HashEntry&lt;K,V&gt; newFirst = e.next;</code>这句将待删除节点的next节点赋值给newFirst <code>for (HashEntry&lt;K,V&gt; p = first; p != e; p = p.next)</code>此处的for循环从链表的头部开始一直循环到待删除节点为止，<code>newFirst = new HashEntry&lt;K,V&gt;(p.key, p.hash, newFirst, p.value);</code>for循环内部根据当前循环的节点新建了一个key和value、hash都相同的节点，不同的是next指向了前一个新建的节点（第一个newFirst是待删除节点的下一个节点），即构成了一个以待删除节点的前一个节点为头结点的新的链表，然后<code>tab[index] = newFirst;</code>将该链表赋到对应的桶上，便完成了整个删除操作，最终新的链表以待删除节点的前一个节点为头结点。<br>下面通过图例来说明 remove 操作。假设写线程执行 remove 操作，要删除链表的 C 节点，另一个读线程同时正在遍历这个链表。<br><strong>执行删除之前的原链表：</strong><br><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blogJDK并发工具类源码学习系列——ConcurrentHashMap_图4.jpg" alt="执行删除之前的原链表"><br><strong>执行删除之后的新链表：</strong><br><img src="http://7xnnj7.com1.z0.glb.clouddn.com/blogJDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentHashMap_%E5%9B%BE5.jpg" alt="执行删除之后的新链表"><br>从图中可以看出被删除节点之后的节点原封不动保留在链表中，而之前的链表从后往前依次被复制到新的链表中，但是原链表在我们进行remove操作过程中始终是会发生任何变化的，所以写线程对某个链表进行remove操作不会影响其他的并发读线程对这个链表的遍历访问。</p>
<h5 id="get(Object)"><strong>get(Object)</strong></h5><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="variable">key</span>) &#123;</span><br><span class="line">    <span class="built_in">int</span> hash = hash(<span class="variable">key</span>.hashCode());</span><br><span class="line">    <span class="keyword">return</span> segmentFor(hash).<span class="built_in">get</span>(<span class="variable">key</span>, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap的get()方法同put()一样，也是依赖于Segment的get()方法。下面看看Segment的get()方法</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">V <span class="literal">get</span>(Object key, int hash) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">count</span> != 0) &#123; <span class="comment">// read-volatile</span></span><br><span class="line">        HashEntry&lt;K,V&gt; <span class="keyword">e</span> = getFirst(hash);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">e</span> != null) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">e</span>.hash == hash &amp;&amp; key.equals(<span class="keyword">e</span>.key)) &#123;</span><br><span class="line">                V v = <span class="keyword">e</span>.value;</span><br><span class="line">                <span class="keyword">if</span> (v != null)</span><br><span class="line">                    <span class="keyword">return</span> v;</span><br><span class="line">                <span class="keyword">return</span> readValueUnderLock(<span class="keyword">e</span>); <span class="comment">// recheck</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">e</span> = <span class="keyword">e</span>.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span><br><span class="line"> * Returns properly casted first entry of bin for given hash.</span><br><span class="line">  */</span></span><br><span class="line"> HashEntry&lt;K,V&gt; getFirst(int hash) &#123;</span><br><span class="line">     HashEntry&lt;K,V&gt;[] <span class="keyword">tab</span> = <span class="keyword">table</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">tab</span>[hash &amp; (<span class="keyword">tab</span>.length - 1)];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Reads value field of an entry under lock. Called if value</span><br><span class="line"> * field ever appears to be null. This is possible only if a</span><br><span class="line"> * compiler happens to reorder a HashEntry initialization with</span><br><span class="line"> * its table assignment, which is legal under memory model</span><br><span class="line"> * but is not known to ever occur.</span><br><span class="line"> */</span></span><br><span class="line">V readValueUnderLock(HashEntry&lt;K,V&gt; <span class="keyword">e</span>) &#123;</span><br><span class="line">    lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">e</span>.value;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码可以看到get()方法在读取时无需进行加锁操作，除非读取到的值为NULL。为什么读取一个节点的值为NULL的时候需要加锁呢？因为ConcurrentHashMap是不允许NULL作为key或者value的，所以是不应该出现读取一个节点的值为NULL的情况，如果出现这种情况，说明出现了并发问题，所以加上锁再次读取！(什么情况下会出现这种情况并不清楚)。</p>
<h5 id="总结"><strong>总结</strong></h5><p>ConcurrentHashMap在进行结构性修改，如put/remove/replace时都需要进行加锁，但是读取并未加锁，并发情况下，由于内存不同步问题，会导致一个线程的写操作并不会立即对另一个线程可见。这里ConcurrentHashMap通过volatile变量的内存可见性特性来保证一个线程的写操作立即被其他线程可见，每个方法在一开始都会读取count这个变量，该变量就是一个volatile变量，多个线程之间通过读写这个变量来保证内存可见性，具体可参考下方的关于JVM内存可见性的说明。<br>上面三个方法基本包含了整个ConcurrentHashMap的读写操作（replace(K, V)方法只是简单的更新节点的value值，由于value是volatile的，所以也不会影响读线程），从三个方法的分析来看ConcurrentHashMap首先通过Segment对整个数据集进行切分，并通过对各个部分的数据集进行加锁来提高整个数据集的并发性；通过读写分离的方式实现无锁读，加锁写，进一步提高ConcurrentHashMap的读写效率；并通过volatile变量的特性实现读写的可见性保证。</p>
<h4 id="使用场景"><strong>使用场景</strong></h4><p>ConcurrentHashMap由于其即使在同步的情况下依旧保证高效的读写性能，所以在很多需要使用HashMap的情况都适用，当然单线程情况并不需要使用同步的ConcurrentHashMap。如果无法保证你的HashMap只是在单线程情况下使用那么就使用ConcurrentHashMap，因为其在单线程情况下的效率也并不低。<br>下面是针对单线程环境下ConcurrentHashMap和HashMap的put性能的对比：<br>硬件PC：普通PC机，i5<br>JVM：内存1G<br>测试数据：执行10次，计算均值<br>结果：表格</p>
<table>
<thead>
<tr>
<th>Map</th>
<th style="text-align:center">PUT1W次</th>
<th style="text-align:right">PUT10W次</th>
<th style="text-align:right">PUT100W次</th>
</tr>
</thead>
<tbody>
<tr>
<td>ConcurrentHashMap</td>
<td style="text-align:center">2175317</td>
<td style="text-align:right">28068193</td>
<td style="text-align:right">1355076232</td>
</tr>
<tr>
<td>HashMap</td>
<td style="text-align:center">1201131</td>
<td style="text-align:right">28068193</td>
<td style="text-align:right">407341713</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="Java_内存模型"><strong>Java 内存模型</strong></h4><p>由于 ConcurrentHashMap 是建立在 Java 内存模型基础上的，为了更好的理解 ConcurrentHashMap，让我们首先来了解一下 Java 的内存模型。<br>Java 语言的内存模型由一些规则组成，这些规则确定线程对内存的访问如何排序以及何时可以确保它们对线程是可见的。下面我们将分别介绍 Java 内存模型的重排序，内存可见性和 happens-before 关系。</p>
<h5 id="重排序"><strong>重排序</strong></h5><p>内存模型描述了程序的可能行为。具体的编译器实现可以产生任意它喜欢的代码 – 只要所有执行这些代码产生的结果，能够和内存模型预测的结果保持一致。这为编译器实现者提供了很大的自由，包括操作的重排序。<br>编译器生成指令的次序，可以不同于源代码所暗示的“显然”版本。重排序后的指令，对于优化执行以及成熟的全局寄存器分配算法的使用，都是大有脾益的，它使得程序在计算性能上有了很大的提升。<br>重排序类型包括：</p>
<ul>
<li>编译器生成指令的次序，可以不同于源代码所暗示的“显然”版本。</li>
<li>处理器可以乱序或者并行的执行指令。</li>
<li>缓存会改变写入提交到主内存的变量的次序。<h5 id="内存可见性"><strong>内存可见性</strong></h5>由于现代可共享内存的多处理器架构可能导致一个线程无法马上（甚至永远）看到另一个线程操作产生的结果。所以 Java 内存模型规定了 JVM 的一种最小保证：什么时候写入一个变量对其他线程可见。<br>在现代可共享内存的多处理器体系结构中每个处理器都有自己的缓存，并周期性的与主内存协调一致。假设线程 A 写入一个变量值 V，随后另一个线程 B 读取变量 V 的值，在下列情况下，线程 B 读取的值可能不是线程 A 写入的最新值：</li>
<li>执行线程 A 的处理器把变量 V 缓存到寄存器中。</li>
<li>执行线程 A 的处理器把变量 V 缓存到自己的缓存中，但还没有同步刷新到主内存中去。</li>
<li>执行线程 B 的处理器的缓存中有变量 V 的旧值。<h5 id="Happens-before_关系"><strong>Happens-before 关系</strong></h5>happens-before 关系保证：如果线程 A 与线程 B 满足 happens-before 关系，则线程 A 执行动作的结果对于线程 B 是可见的。如果两个操作未按 happens-before 排序，JVM 将可以对他们任意重排序。<br>下面介绍几个与理解 ConcurrentHashMap 有关的 happens-before 关系法则：</li>
</ul>
<ol>
<li>程序次序法则：如果在程序中，所有动作 A 出现在动作 B 之前，则线程中的每动作 A 都 happens-before 于该线程中的每一个动作 B。</li>
<li>监视器锁法则：对一个监视器的解锁 happens-before 于每个后续对同一监视器的加锁。</li>
<li>Volatile 变量法则：对 Volatile 域的写入操作 happens-before 于每个后续对同一 Volatile 的读操作。</li>
<li>传递性：如果 A happens-before 于 B，且 B happens-before C，则 A happens-before C。</li>
</ol>
<p>以上摘自<a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/" target="_blank" rel="external">探索 ConcurrentHashMap 高并发性的实现机制</a></p>
<hr>
<h4 id="参考文章"><strong>参考文章</strong></h4><p>1.<a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/" target="_blank" rel="external">探索 ConcurrentHashMap 高并发性的实现机制</a><br>2.<a href="http://www.infoq.com/cn/articles/ConcurrentHashMap" target="_blank" rel="external">聊聊并发（四）——深入分析ConcurrentHashMap</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ConcurrentHashMap类在我的开发过程中经常被使用，个人觉得如果在共享一个Map时，如果无法判断是否需要加锁，那么就干脆直接使用ConcurrentHashMap，即能保证并发安全，同时性能也不会有太多下降，因为ConcurrentHashMap可实现无锁读，不过内存会占用的多些，但是并不明显，基本可以忽略。<br>]]>
    
    </summary>
    
      <category term="JDK" scheme="http://vickyqi.com/tags/JDK/"/>
    
      <category term="JUC" scheme="http://vickyqi.com/tags/JUC/"/>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="JDK源码" scheme="http://vickyqi.com/categories/Java/JDK%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JDK并发工具类源码学习系列——介绍]]></title>
    <link href="http://vickyqi.com/2015/10/24/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E4%BB%8B%E7%BB%8D/"/>
    <id>http://vickyqi.com/2015/10/24/JDK并发工具类源码学习系列——介绍/</id>
    <published>2015-10-24T12:32:11.000Z</published>
    <updated>2015-11-13T06:02:04.000Z</updated>
    <content type="html"><![CDATA[<p>JDK并发工具类是JDK1.5引入的一大重要的功能，集中在java.util.concurrent包下，java.util.concurrent包下还包括了java.util.concurrent.atomic以及java.util.concurrent.locks两个子包。java.util.concurrent包主要包含了并发集合类以及线程池和信号量三组重要工具类；java.util.concurrent.atomic包下是JDK提供的一组原子操作类；java.util.concurrent.locks包下是JDK提供的锁机制。本系列主要关注java.util.concurrent包下的并发集合类：</p>
<ul>
<li><a href="http://vickyqi.com/2015/10/26/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentHashMap/">ConcurrentHashMap</a></li>
<li><a href="http://vickyqi.com/2015/10/29/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentLinkedQueue/">ConcurrentLinkedQueue</a></li>
<li><a href="http://vickyqi.com/2015/11/13/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentSkipListMap/">ConcurrentSkipListMap</a></li>
<li>CopyOnWriteArrayList</li>
<li>LinkedBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue</li>
<li>ArrayBlockingQueue</li>
</ul>
<p>以上暂定为本系列将要分析源码的类，每完成一篇会来更新一下链接，欢迎大家关注。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JDK并发工具类是JDK1.5引入的一大重要的功能，集中在java.util.concurrent包下，java.util.concurrent包下还包括了java.util.concurrent.atomic以及java.util.concurrent.locks两个子包]]>
    </summary>
    
      <category term="JDK" scheme="http://vickyqi.com/tags/JDK/"/>
    
      <category term="JUC" scheme="http://vickyqi.com/tags/JUC/"/>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="JDK源码" scheme="http://vickyqi.com/categories/Java/JDK%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Apache Commons CLI开发命令行工具]]></title>
    <link href="http://vickyqi.com/2015/10/19/%E4%BD%BF%E7%94%A8Apache%20Commons%20CLI%E5%BC%80%E5%8F%91%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    <id>http://vickyqi.com/2015/10/19/使用Apache Commons CLI开发命令行工具/</id>
    <published>2015-10-19T06:47:47.000Z</published>
    <updated>2015-11-01T08:11:00.000Z</updated>
    <content type="html"><![CDATA[<p>工作两年多，从没遇到需要使用命令行那样的参数形式执行命令的需求，突然好奇想试试，于是找到了Apache Commons CLI，大致了解试用了下，挺简单的，总共也就那点东西。<br>Apache Commons CLI官网地址：(<a href="https://commons.apache.org/cli/download_cli.cgi" target="_blank" rel="external">https://commons.apache.org/cli/download_cli.cgi</a>)<br>使用Apache Commons CLI开发命令行工具分成三步：<br>1）定义CLI<br>2）解析CLI<br>3）处理CLI<br>首先我们参考官网给出的一个例子：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ant [options] [target [target2 [target3] ...]]</span><br><span class="line">  Options: </span><br><span class="line">  -<span class="operator"><span class="keyword">help</span>                  print this message</span><br><span class="line">  -projecthelp           print <span class="keyword">project</span> <span class="keyword">help</span> information</span><br><span class="line">  -<span class="keyword">version</span>               print the <span class="keyword">version</span> information <span class="keyword">and</span> <span class="keyword">exit</span></span><br><span class="line">  -quiet                 be extra quiet</span><br><span class="line">  -verbose               be extra verbose</span><br><span class="line">  -debug                 print debugging information</span><br><span class="line">  -emacs                 produce <span class="keyword">logging</span> information <span class="keyword">without</span> adornments</span><br><span class="line">  -<span class="keyword">logfile</span> &lt;<span class="keyword">file</span>&gt;        <span class="keyword">use</span> given <span class="keyword">file</span> <span class="keyword">for</span> <span class="keyword">log</span></span><br><span class="line">  -logger &lt;classname&gt;    the <span class="keyword">class</span> which <span class="keyword">is</span> <span class="keyword">to</span> perform <span class="keyword">logging</span></span><br><span class="line">  -listener &lt;classname&gt;  <span class="keyword">add</span> an <span class="keyword">instance</span> <span class="keyword">of</span> <span class="keyword">class</span> <span class="keyword">as</span> a <span class="keyword">project</span> listener</span><br><span class="line">  -buildfile &lt;<span class="keyword">file</span>&gt;      <span class="keyword">use</span> given buildfile</span><br><span class="line">  -<span class="keyword">D</span>&lt;property&gt;=&lt;<span class="keyword">value</span>&gt;   <span class="keyword">use</span> <span class="keyword">value</span> <span class="keyword">for</span> given property</span><br><span class="line">  -find &lt;<span class="keyword">file</span>&gt;           <span class="keyword">search</span> <span class="keyword">for</span> buildfile towards the root <span class="keyword">of</span> the</span><br><span class="line">                         filesystem <span class="keyword">and</span> <span class="keyword">use</span> it</span></span><br></pre></td></tr></table></figure></p>
<p>该例子是ant的命令，我们可以对照着进行开发（其实官网就有，英文好的可以直接移步<br>(<a href="https://commons.apache.org/proper/commons-cli/usage.html)）。" target="_blank" rel="external">https://commons.apache.org/proper/commons-cli/usage.html)）。</a></p>
<p>####定义CLI：<br>首先参照上面的三部曲，第一步定义CLI：<br>Apache Commons CLI使用Option表示每一个命令，使用Options封装多个Option，创建Option的方式有三种：</p>
<ol>
<li>Option op = new Option(…);//构造器</li>
<li>Options.addOption(…);//Options直接构造</li>
<li>Option.Builder辅助类<br>1.2适合简单的创建的命令，如上面logfile命令以上的命令。我们举几个例子：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Options ops = new Options();</span><br><span class="line">Option <span class="operator"><span class="keyword">help</span> = <span class="keyword">new</span> <span class="keyword">Option</span>( <span class="string">"help"</span>, <span class="string">"print this message"</span> );</span></span><br><span class="line">ops.addOption(<span class="operator"><span class="keyword">help</span>);</span></span><br><span class="line">ops.addOption("projecthelp", "print project <span class="operator"><span class="keyword">help</span> information<span class="string">");</span></span></span><br></pre></td></tr></table></figure>
<p>同时如果我们假设debug命令后可跟值true/false，那么我们可以这样定义命令：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ops.addOption(<span class="string">"debug"</span>, <span class="keyword">true</span>, <span class="string">"print debugging information"</span>); <span class="regexp">//</span>第二个参数<span class="keyword">true</span>表示该命令后可跟参数，其实就是命令后面跟上值</span><br></pre></td></tr></table></figure>
<p>下面我们看logfile以下除去<code>-D&lt;property&gt;=&lt;value&gt;</code> 之外的的命令如何创建，这里使用第三种方式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Option</span> logfile = <span class="built_in">Option</span>.builder(<span class="string">"logfile"</span>).argName(<span class="string">"file"</span>).hasArg().desc(<span class="string">"use given file for log"</span>).build();<span class="comment">// argName指定命令后跟的参数名称</span></span><br><span class="line">ops.addOption(logfile);</span><br></pre></td></tr></table></figure>
<p>最后我们看看如何定义<code>-D&lt;property&gt;=&lt;value&gt;</code>：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Option <span class="keyword">D</span> = Option.builder(<span class="string">"D"</span>).argName(<span class="string">"property=value"</span>).numberOfArgs(2).valueSeparator(<span class="string">"="</span>)</span><br><span class="line">				.<span class="keyword">desc</span>(<span class="string">"use value for given property"</span>).build();<span class="comment">// 这里numberOfArgs指定了后跟两个参数，且valueSeparator指定了连接符是=，这样CLI可以自动帮我们解析键值对</span></span><br><span class="line">ops.addOption(<span class="keyword">D</span>);</span><br></pre></td></tr></table></figure>
<h4 id="解析CLI：">解析CLI：</h4><p>以上全部定义好之后，就可以对传入的参数进行解析了。DefaultParser类是用来解析参数，得到每个命令以及对应的值，而且对于如上面的<code>-D&lt;property&gt;=&lt;value&gt;</code> 这种命令，由于我们制定了“=”为分隔符，DefaultParser可以自动为我们将参数解析成Properties，很方便。</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CommandLine comm = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	comm = <span class="keyword">new</span> DefaultParser().parse(ops, args);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">	<span class="built_in">log</span>.<span class="built_in">error</span>(<span class="string">"解析参数失败，参数：["</span> + Arrays.asList(args).toString() + <span class="string">"]"</span>);</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="处理CLI">处理CLI</h4><p>上面已经对传入的参数解析好了，剩下的就是获取到这些命令的值，以及进行相应的处理了，也就是我们的业务逻辑了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (comm.getOptions().length == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">log</span>.info(<span class="string">"No any param to specify."</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (comm.hasOption(<span class="string">"h"</span>)) &#123;<span class="comment">// help</span></span><br><span class="line">	HelpFormatter formatter = <span class="keyword">new</span> HelpFormatter();</span><br><span class="line">	formatter.printHelp(<span class="string">"options"</span>, ops);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (comm.hasOption(<span class="string">"s"</span>)) &#123;<span class="comment">// 执行命令</span></span><br><span class="line">	<span class="keyword">new</span> SystemCommand().execute(comm.getOptionValue(<span class="string">"s"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (comm.hasOption(<span class="string">"D"</span>)) &#123;<span class="comment">// 传递参数</span></span><br><span class="line">	Properties props = comm.getOptionProperties(<span class="string">"D"</span>);</span><br><span class="line">	<span class="keyword">new</span> ParamParser(props).parse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是一个简单的例子，这里有个getOptionProperties方法，这个方法是针对使用分隔符的命令方便获取键值对行为的属性值而设计的，很好用，免去了自己再做字符串切分的麻烦。<br>到这里整个使用Apache Commons CLI开发命令行工具的工作就完成了，很简单。</p>
<ul>
<li>Apache Commons CLI总共支持的几种命令模式：</li>
<li>POSIX like options (ie. tar -zxvf foo.tar.gz)</li>
<li>GNU like long options (ie. du –human-readable –max-depth=1)</li>
<li>Java like properties (ie. java -Djava.awt.headless=true -Djava.net.useSystemProxies=true Foo)</li>
<li>Short options with value attached (ie. gcc -O2 foo.c)</li>
<li>long options with single hyphen (ie. ant -projecthelp)</li>
</ul>
<p>对于GNU模式官网还有一个例子，可以自行参考下。<br>附上官网的一个Option的属性表：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th style="text-align:left">Type</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>opt</td>
<td style="text-align:left">java.lang.String</td>
<td style="text-align:left">the identification string of the Option.</td>
</tr>
<tr>
<td>longOpt</td>
<td style="text-align:left">java.lang.String</td>
<td style="text-align:left">an alias and more descriptive identification string.</td>
</tr>
<tr>
<td>description</td>
<td style="text-align:left">java.lang.String</td>
<td style="text-align:left">a description of the function of the option.</td>
</tr>
<tr>
<td>required</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">a flag to say whether the option must appear on the command line.</td>
</tr>
<tr>
<td>arg</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">a flag to say whether the option takes an argument.</td>
</tr>
<tr>
<td>args</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">a flag to say whether the option takes more than one argument.</td>
</tr>
<tr>
<td>optionalArg</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">a flag to say whether the option’s argument is optional.</td>
</tr>
<tr>
<td>argName</td>
<td style="text-align:left">java.lang.String</td>
<td style="text-align:left">the name of the argument value for the usage statement.</td>
</tr>
<tr>
<td>valueSeparator</td>
<td style="text-align:left">char</td>
<td style="text-align:left">the character value used to split the argument string, that is used in conjunction with multipleArgs e.g. if the separator is ‘,’ and the argument string is ‘a,b,c’ then there are three argument values, ‘a’, ‘b’ and ‘c’.</td>
</tr>
<tr>
<td>type</td>
<td style="text-align:left">java.lang.Object</td>
<td style="text-align:left">the type of the argument.</td>
</tr>
<tr>
<td>value</td>
<td style="text-align:left">java.lang.String</td>
<td style="text-align:left">the value of the option.</td>
</tr>
<tr>
<td>values</td>
<td style="text-align:left">java.lang.String[]</td>
<td style="text-align:left">the values of the option.</td>
</tr>
</tbody>
</table>
<p>参考文章：<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-commonscli/" target="_blank" rel="external">使用 Apache Commons CLI 开发命令行工具</a><br><a href="https://commons.apache.org/proper/commons-cli/project-info.html" target="_blank" rel="external">Apache Commons CLI</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>工作两年多，从没遇到需要使用命令行那样的参数形式执行命令的需求，突然好奇想试试，于是找到了Apache Commons CLI，大致了解试用了下，挺简单的，总共也就那点东西。<br>Apache Commons CLI官网地址：(<a href="https://commo]]>
    </summary>
    
      <category term="Cli" scheme="http://vickyqi.com/tags/Cli/"/>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="命令行" scheme="http://vickyqi.com/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[几种常用JSON库性能比较]]></title>
    <link href="http://vickyqi.com/2015/10/19/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8JSON%E5%BA%93%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"/>
    <id>http://vickyqi.com/2015/10/19/几种常用JSON库性能比较/</id>
    <published>2015-10-19T06:47:47.000Z</published>
    <updated>2015-11-01T08:11:06.000Z</updated>
    <content type="html"><![CDATA[<p>JSON不管是在Web开发还是服务器开发中是相当常见的数据传输格式，一般情况我们对于JSON解析构造的性能并不需要过于关心，除非是在性能要求比较高的系统。<br>目前对于Java开源的JSON类库有很多种，下面我们取三个常用的JSON库进行性能测试对比，同时根据测试结果分析如果根据实际应用场景选择最合适的JSON库。<br>四个JSON类库分别为：Gson，FastJson，Jackson，Json-lib。<br>简单介绍下四个类库的身份背景。</p>
<ul>
<li>Gson（项目地址：<a href="https://github.com/google/gson）" target="_blank" rel="external">https://github.com/google/gson）</a><ul>
<li>Gson是目前功能最全的Json解析神器，Gson当初是为因应Google公司内部需求而由Google自行研发而来，但自从在2008年五月公开发布第一版后已被许多公司或用户应用。Gson的应用主要为toJson与fromJson两个转换函数，无依赖，不需要例外额外的jar，能够直接跑在JDK上。而在使用这种对象转换之前需先创建好对象的类型以及其成员才能成功的将JSON字符串成功转换成相对应的对象。类里面只要有get和set方法，Gson完全可以将复杂类型的json到bean或bean到json的转换，是JSON解析的神器。</li>
</ul>
</li>
<li>FastJson（项目地址：<a href="https://github.com/alibaba/fastjson）" target="_blank" rel="external">https://github.com/alibaba/fastjson）</a><ul>
<li>Fastjson是一个Java语言编写的高性能的JSON处理器,由阿里巴巴公司开发。无依赖，不需要例外额外的jar，能够直接跑在JDK上。FastJson在复杂类型的Bean转换Json上会出现一些问题，可能会出现引用的类型，导致Json转换出错，需要制定引用。FastJson采用独创的算法，将parse的速度提升到极致，超过所有json库。</li>
</ul>
</li>
<li>Jackson（项目地址：<a href="https://github.com/FasterXML/jackson）" target="_blank" rel="external">https://github.com/FasterXML/jackson）</a><ul>
<li>相比json-lib框架，Jackson所依赖的jar包较少，简单易用并且性能也要相对高些。而且Jackson社区相对比较活跃，更新速度也比较快。Jackson对于复杂类型的json转换bean会出现问题，一些集合Map，List的转换出现问题。Jackson对于复杂类型的bean转换Json，转换的json格式不是标准的Json格式。</li>
</ul>
</li>
<li>Json-lib（项目地址：<a href="http://json-lib.sourceforge.net/index.html）" target="_blank" rel="external">http://json-lib.sourceforge.net/index.html）</a><ul>
<li>json-lib最开始的也是应用最广泛的json解析工具，json-lib 不好的地方确实是依赖于很多第三方包，包括commons-beanutils.jar，commons-collections-3.2.jar，commons-lang-2.6.jar，commons-logging-1.1.1.jar，ezmorph-1.0.6.jar，对于复杂类型的转换，json-lib对于json转换成bean还有缺陷，比如一个类里面会出现另一个类的list或者map集合，json-lib从json到bean的转换就会出现问题。json-lib在功能和性能上面都不能满足现在互联网化的需求。</li>
</ul>
</li>
</ul>
<p>选择一个合适的JSON库要从多个方面进行考虑：</p>
<ol>
<li>字符串解析成JSON性能</li>
<li>字符串解析成JavaBean性能</li>
<li>JavaBean构造JSON性能</li>
<li>集合构造JSON性能</li>
<li>易用性</li>
</ol>
<p>对于前四条其实都是从JSON的解析构造性能角度考虑，而最后一条则是考虑易用性，这点对于开发者来说其实也是需要考虑的一个问题，如果该库的API使用难度大，或者很复杂，那么不建议使用，毕竟JSON解析的性能差异并不大。下面的测试结果针对四个不同数量级的JSON字符串，以及分别测试上面提到的前四条性能，结果如下：<br><img src="http://img.blog.csdn.net/20150901164447842" alt="这里写图片描述"><br>Json-lib在数据量在10W时OOM了，内存开到1G都不行，所以直接Pass了。<br>从上面图表可以看到：</p>
<ol>
<li>字符串解析成JavaBean：当数据量较少时首选FastJson，数据量较大使用Jackson。但是Jackson无法堆一个对象集合进行解析，只能转成一个Map集合，这点Gson和FastJson处理的比较好。</li>
<li>字符串解析成JSON：当数据量较少时首选FastJson，数据量较大使用Jackson。</li>
<li>JavaBean构造JSON：当数据量较少时选择Gson，数据量较大可使用Jackson。</li>
<li>集合构造JSON：首先Jackson，其次Fastjson。</li>
</ol>
<p>上面是从性能角度分析四种JSON类库，从易用性角度来分析的话，FastJson的API设计的最简单，最方便使用，直接使用JSON的两个静态方法即可完成四种操作；而Gson和Jackson都需要new一个对象，虽然这个对象可以复用，但是在实际使用过程中还需要用一个全局变量来保存改变量，同时API设计的也不是很好理解，对于FastJson来说复杂的API是因为他支持流式解析，适合对JSON进行大量且复杂的操作，但是实际应用中对于JSON的操作都是简单的解析成JavaBean，然后JavaBean序列化成JSON字符串即可，复杂的操作很少。<br>下面从我自己实际的应用场景出发，考虑该如何选择合适的JSON类库。<br>应用场景：游戏服务器，基本是对客户端发送过来的JSON格式字符串解析成JavaBean，然后将封装好的指令转成JSON字符串返回给客户端，这里考虑到JavaBean转成JSON与集合转成JSON的性能差异，所以直接使用集合进行转成JSON，避免使用JavaBean。<br>考虑上述场景适合使用FastJson进行JSON字符串解析，Jackson将集合转成JSON格式字符串。<br>浅尝辄止，欢迎批评指出。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JSON不管是在Web开发还是服务器开发中是相当常见的数据传输格式，一般情况我们对于JSON解析构造的性能并不需要过于关心，除非是在性能要求比较高的系统。<br>目前对于Java开源的JSON类库有很多种，下面我们取三个常用的JSON库进行性能测试对比，同时根据测试结果分析]]>
    </summary>
    
      <category term="JSON" scheme="http://vickyqi.com/tags/JSON/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解原码、反码、补码——深入理解补码]]></title>
    <link href="http://vickyqi.com/2015/10/19/%E8%AF%A6%E8%A7%A3%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%A1%A5%E7%A0%81/"/>
    <id>http://vickyqi.com/2015/10/19/详解原码、反码、补码——深入理解补码/</id>
    <published>2015-10-19T06:19:11.000Z</published>
    <updated>2015-10-20T03:39:34.000Z</updated>
    <content type="html"><![CDATA[<p>学过计算机原理的人都知道原码、反码、补码，但是有多少人知道为什么会有这三种码呢，这三种码又是用来干嘛的呢。<br>众所周知，在计算机的世界只有01，那么显然所有的数都得转成二进制，这样计算机才能够理解。如何将一个十进制的数转成二进制就不说了，说下原码，正数的原码就是十进制转成二进制得到的二进制值，而负数是对应的正数转成二进制得到的二进制值，然后将最高位（符号位）置为1表示这是一个负数，如-10:10001010。</p>
<h5 id="1-_原码"><strong>1. 原码</strong></h5><p>计算机进行算术运算时为了简单效率所以要求能够使用加法代替减法，如1-1==1+(-1)==0，那么我们先看看原码能不能实现这种需求。<br>示例：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">计算76-10==66</span><br><span class="line"><span class="code">   十进制     二进制</span></span><br><span class="line"><span class="code">   76        01001100</span></span><br><span class="line"><span class="header"> +  -10       10001010</span><br><span class="line">---------------------</span></span><br><span class="line"><span class="code">   66        11010110（-86）</span></span><br></pre></td></tr></table></figure></p>
<h5 id="2-_反码"><strong>2. 反码</strong></h5><p>从上面算出的结果可见原码是无法完成对减法的运算需求的，那么由于1-1==1+（-1），所以人类又找到了一个看似能够解决这个问题的解决方法——反码，即将负数的符号位不变其余位取反。下面我们再看看反码能不能解决问题。<br>示例1：计算15-125<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">计算<span class="number">15</span>-<span class="number">125</span>==-<span class="number">110</span></span><br><span class="line">   十进制     二进制原码    二进制反码</span><br><span class="line">   <span class="number">15</span>        <span class="number">00001111</span>    <span class="number">00001111</span></span><br><span class="line"> +  -<span class="number">125</span>      <span class="number">11111101</span>    <span class="number">10000010</span></span><br><span class="line">---------------------------------</span><br><span class="line">   -<span class="number">110</span>      <span class="number">11101110</span>    <span class="number">10010001</span></span><br><span class="line">得到<span class="number">10010001</span>(反码)==<span class="number">11101110</span>(原码)==-<span class="number">110</span>，正确。注意：使用反码计算得到的结果也是反码，需要再次转换成原码。</span><br></pre></td></tr></table></figure></p>
<p>示例2：计算76-10<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">计算<span class="number">76</span>-<span class="number">10</span>==<span class="number">66</span></span><br><span class="line">   十进制     二进制原码    二进制反码</span><br><span class="line">   <span class="number">76</span>        <span class="number">01001100</span>    <span class="number">01001100</span></span><br><span class="line"> + -<span class="number">10</span>       <span class="number">10001010</span>    <span class="number">11110101</span></span><br><span class="line">---------------------------------</span><br><span class="line">   <span class="number">66</span>        <span class="number">01000010</span>    <span class="number">101000001</span>==<span class="number">01000010</span>  </span><br><span class="line">这里得到的值超过<span class="number">8</span>bit，所以最高的<span class="number">1</span>需要丢弃，丢弃后需要在最低位+<span class="number">1</span>，得到<span class="number">01000010</span>(反码)==<span class="number">01000010</span>(原码)==<span class="number">66</span>，正确。</span><br></pre></td></tr></table></figure></p>
<p>示例3：计算1-1<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">计算<span class="number">1</span>-<span class="number">1</span>==<span class="number">0</span></span><br><span class="line">   十进制     二进制原码    二进制反码</span><br><span class="line">   <span class="number">1</span>         <span class="number">00000001</span>    <span class="number">00000001</span></span><br><span class="line"> + -<span class="number">1</span>        <span class="number">10000001</span>    <span class="number">11111110</span></span><br><span class="line">---------------------------------</span><br><span class="line">   <span class="number">0</span>         <span class="number">10000000</span>    <span class="number">11111111</span>  </span><br><span class="line">得到<span class="number">11111111</span>(反码)==<span class="number">10000000</span>(原码)==-<span class="number">0</span>，-<span class="number">0</span>？通过反码计算会出现+<span class="number">0</span>和-<span class="number">0</span>，一个<span class="number">0</span>对应了两个码，显然是不合理的。</span><br></pre></td></tr></table></figure></p>
<p>从上面三个例子可以看出使用反码进行减法运算时存在两个问题：</p>
<ol>
<li>当计算结果溢出时需要额外进行+1操作，使得运算多了一步，效率降低</li>
<li><p>0存在+0和-0两种存在方式，不方便理解</p>
<h5 id="3-_模与互补、同余"><strong>3. 模与互补、同余</strong></h5><p>在看补码之前，先介绍三个概念——模、补数、同余。我们从现实生活举例来看：</p>
<ul>
<li>我们将一个时钟的分针往前拨20分钟，和往后拨40分钟，得到的结果是一样的。</li>
<li>把你的属年(属猴)往后退5年，和往前进7年，一样都是属兔。</li>
<li>把数字 87，减去 25，和加上 75，在不考虑百位数的条件下，得到的结果都是62。</li>
</ul>
</li>
</ol>
<p>上述几组数字，有这样的关系：<br>　　20 + 40 = 60<br>　　5 + 7 = 12<br>　　25 + 75 = 100<br>式中的 60、12 和 100，就是“模”。<br>式中的 20和40、5和7，以及25和75，就是一对对“互补”的数字。<br>而且20，80，140在模是60的情况下就是互为“同余”的数字。<br>通俗解释下模、补数、同余的概念：</p>
<ul>
<li><strong>模</strong>：就是一个轮回，比如分针转一圈，十二生肖一轮等等。</li>
<li><strong>互补 </strong>：一个数值针对某个模的互补值就是这个数值加上或者减去多少能够等于模，或者等于模的同余值。</li>
<li><strong>同余 </strong>：一个数值加上或者减去模的整数倍得到的所有数值即为该数值的同余值<strong>(也就是除上模，余数是一样，所以叫同余)</strong>，0是模的同余，-模也是模的同余。</li>
</ul>
<p>理解了什么是模，什么是互补、什么是同余，那么如果给一个模，以及一个值a，如果计算a的补数(与a互补的值)呢，其实很简单，只需要拿模-a即可，计算同余值可以直接加上或者减去模的整数倍即可。</p>
<h5 id="4-_那么互补的值有什么用呢？"><strong>4. 那么互补的值有什么用呢？</strong></h5><p>如果我们在进行减法运算时，用与减数互补的值代替减数与被减数进行加法运算会发生什么呢？废话不多说，看示例。<br>示例1：在分钟刻度下，计算55分钟往后拨动34分钟，转化成数学计算就是：55-34<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">被减数	     <span class="number">55</span></span><br><span class="line">减数		  <span class="number">34</span></span><br><span class="line">减数补数   <span class="number">60</span>-<span class="number">34</span>==<span class="number">26</span></span><br><span class="line">最终结果     <span class="number">55</span>+<span class="number">26</span>==<span class="number">81</span></span><br><span class="line">---------------------</span><br><span class="line">用减数补数代替减数得到结果为<span class="number">81</span>,<span class="number">81</span>在分钟刻度盘上正好是<span class="number">21</span>，也就是<span class="number">81</span>是<span class="number">21</span>的同余值，和<span class="number">55</span>-<span class="number">34</span>是一样的。注意：这里涉及到类似上面的<span class="number">87</span>+<span class="number">75</span>的情况，即忽略了进位。</span><br></pre></td></tr></table></figure></p>
<p>示例2：在十二生肖中，计算猴年往后退11年，转化成数学计算就是：9-11<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">被减数	     <span class="number">9</span></span><br><span class="line">减数		  <span class="number">11</span></span><br><span class="line">减数补数   <span class="number">12</span>-<span class="number">11</span>==<span class="number">1</span></span><br><span class="line">最终结果     <span class="number">9</span>+<span class="number">1</span>==<span class="number">10</span></span><br><span class="line">-------------------</span><br><span class="line">用减数互补值代替减数得到结果为<span class="number">10</span>,<span class="number">10</span>对应到十二生肖正好是鸡，和猴年往后退<span class="number">11</span>年是一样的，所以得到的也是一个同余值。</span><br></pre></td></tr></table></figure></p>
<p>从上面的示例可以看出，使用互补值计算出的结果与实际值其实是<strong>同余</strong>的关系。</p>
<h5 id="5-_二进制的模"><strong>5. 二进制的模</strong></h5><p>上面看了分钟刻度盘的模，十二生肖的模，以及两位整数的模，那么对于一个8bit的字节的模是多少呢？<br>分钟刻度盘的模为什么是60？是因为他的值是从1-59，总共60个值，十二生肖以及两位整数也是一样的，所以我们只需要看看一个8bit的字节的所有取值一共是多少个就是他的模，显示8个bit可表示的最小值是00000000==0，最大值是11111111==255，那么从0到255一共是256个值，所以一个8bit的字节的模就是256了。但是其实在计算机中为了能够表示负数，所以讲8bit的字节的最高位设为符号位，0表示整数，1表示负数，所以能够表示数值的也就只有7bit，如果我们忽视符号位，那么剩下7bit的模就是128，而不是256了。<strong>下面在计算时我们会直接使用128而非256！</strong></p>
<h5 id="6-_使用互补值进行二进制的减法计算"><strong>6. 使用互补值进行二进制的减法计算</strong></h5><p>下面我们就来看看如果使用互补值来进行二进制的减法计算，我们先来看一个公式：假设模式M，我们计算X-Y，然后我们使用减数的补数来计算，看看下面的换算：</p>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">X</span>-<span class="keyword">Y</span> == <span class="keyword">X</span>+(M-<span class="keyword">Y</span>) == <span class="keyword">X</span>+((M-<span class="number">1</span>)-<span class="keyword">Y</span>+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>下面我们来看示例，这个公式在下面会用到的。</p>
<p>示例1：计算15-125<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">           十进制          二进制</span><br><span class="line">被减数	     <span class="number">15</span>             <span class="number">0001111</span></span><br><span class="line">减数		  <span class="number">125</span>            <span class="number">1111101</span></span><br><span class="line">减数补数   <span class="number">128</span>-<span class="number">125</span>==<span class="number">3</span>     <span class="number">0000011</span></span><br><span class="line">最终结果     <span class="number">18</span>             <span class="number">0010010</span></span><br><span class="line">------------------------------------</span><br><span class="line">得到<span class="number">0010010</span>==<span class="number">18</span>，在模式<span class="number">128</span>的情况下，<span class="number">18</span>正好是-<span class="number">110</span>的同余值，跟上面现实的例子是一样的！</span><br></pre></td></tr></table></figure></p>
<p>示例2：计算76-10<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">           十进制          二进制</span><br><span class="line">被减数	     <span class="number">76</span>             <span class="number">01001100</span></span><br><span class="line">减数		  <span class="number">10</span>            <span class="number">00001010</span></span><br><span class="line">减数补数   <span class="number">256</span>-<span class="number">10</span>==<span class="number">246</span>   <span class="number">11110110</span></span><br><span class="line">最终结果     <span class="number">322</span>    <span class="number">101000010</span></span><br><span class="line">------------------------------------</span><br><span class="line">得到<span class="number">101000010</span>==<span class="number">322</span>，在模式<span class="number">256</span>的情况下，<span class="number">322</span>正好是<span class="number">66</span>的同余值，结果还是一样！</span><br></pre></td></tr></table></figure></p>
<p>从上面两个例子我们应该可以看出，如果我们使用减数的补数进行加法运算，那么得到的结果就是一个与正确结果同余的值。在现实生活中，我们可以直接把两个同余的值看做是相同的，例如分钟20和分钟80完全就是一样的，那么在计算机里我们可以这么假设吗？答案是可以的，看下面。<br>试想当计算机使用一个7bit的空间保存一个数值时是如何保存的，比如18，我们可以这么推算，首先分配一个7bit的空间，每个bit上的值都是0，那么如何表示18呢？我们可以这样理解：往这个7bit的空间内进行18次加1操作，满2就进1，最终就会得到0010010。那么如何表示-110，我们可以理解为往这个7bit的空间内进行110次减1操作，一开始全是0，那么如何减1呢？很简单直接减成1111111即可，可以这样理解，分钟在0刻度，你往后拨一下就会指向59，这里也是这个道理，所以连续减110次，就会得到0010010，根18是一样的，所以在计算机看来18和-110是一样的。<br>也就是说<strong>15-125 == 15+(128-125) == 15+(127-125+1) </strong>(上面的公式)，也就是说-125被127-125+1代替了，那么<strong>127-125+1（M-）</strong>又是什么？</p>
<h5 id="7-_补码"><strong>7. 补码</strong></h5><p>上面一路走来终于证明了使用补数可以代替减法，下面我们要解决的问题是M-1-Y+1是啥。<br>我们直接看二进制如何计算M-1-Y+1。<br>示例：计算M=128，Y=110</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">     十进制   二进制</span><br><span class="line"> M-<span class="number">1</span>  <span class="number">127</span>   <span class="number">1111111</span></span><br><span class="line"> -Y   <span class="number">110</span>   <span class="number">1101110</span></span><br><span class="line">            <span class="number">0010001</span></span><br><span class="line">--------------------</span><br><span class="line">M-<span class="number">1</span>换算成二进制就是N位<span class="number">1</span>，那么N位<span class="number">1</span>减去任何一个N位的二进制是啥呢？其实就是按位取反！因为遇到<span class="number">0</span>,<span class="number">1</span>-<span class="number">0</span>==<span class="number">1</span>，取反，遇到<span class="number">1</span>,<span class="number">1</span>-<span class="number">1</span>==<span class="number">0</span>，取反，所以整体就是按位取反，也就是反码。</span><br><span class="line">            </span><br><span class="line"> +<span class="number">1</span>   <span class="number">1</span>     <span class="number">0000001</span></span><br><span class="line">            <span class="number">0010010</span></span><br><span class="line"> ------------------</span><br><span class="line">所以总体就是在<span class="number">110</span>的二进制基础上按位取反然后加<span class="number">1</span>,也就是<span class="number">110</span>的反码加<span class="number">1</span>。</span><br></pre></td></tr></table></figure>
<p>看了上面的示例，应该知道M=128，Y=110，M-1-Y+1就是Y的反码加1，也就是说，如果我们需要计算X-Y，只需要计算X+(Y的反码+1)，由于我们得出这个结论是使用<strong>补数替代减法</strong>得到的，所以<strong>Y的反码+1</strong>就被叫做Y的<strong>补码</strong>。<br>到这里我们知道了110的补码，上面我们介绍了计算机使用1字节的最高位表示符号位，1表示负数，所以-110的最高位是1，由于在使用补码进行减法运算过程中最高位并不参与运算，所以这个最高位应该是固定不动的，所以负数的反码补码最高位始终都是1。<strong>也就得到了-110的补码是：10010010</strong>。对于正数，符号位是0，那么反码补码最高位就始终是0，而且对于正数在计算时也无需使用其补码进行操作，但是为了统一都是用补码，所以定正数的反码补码都等于原码。<br>根据补码的计算过程有些文章会说一个负数X的补码对应的值==2^n-|X|，理解了上面的过程这个公式就自然懂了，不过这个公式没啥用，也没必要记。<br>到这里终于把<strong>补码</strong>的来历说清楚了，至少我自己是明白了，但愿读者也可以明白吧！</p>
<h5 id="一些补码的其他知识"><strong>一些补码的其他知识</strong></h5><p>上面我们看了7bit的模式128，也就说是能表示0-127共128个数值，加上最高位的符号位就成了-127-127共计255个数值，因为没有-0这个数字。但是实际对于计算机来说8bit的空间是可以表示256个数字的，那么还有一个数字是啥呢？正是：<strong>10000000</strong>(注意：这是补码，因为计算机都存的补码)。我们可以试着计算下10000000的原码，可以得到10000000的原码就是10000000，也就是-0，但是如果存在+0和-0两个计算机码对应一个值(+0和-0都是0)，那么显然是没必要的，而且还会造成混乱，所以人为的规定<strong>10000000表示-128</strong>。所以一个8bit的空间可以表示的数字就是从-128到127了，而不是-127-127！</p>
<h5 id="8-_参考文章"><strong>8. 参考文章</strong></h5><p>感谢下面这些文章帮助我理解补码：<br><a href="http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html" target="_blank" rel="external">原码, 反码, 补码 详解</a><br><a href="http://www.douban.com/note/223507364/" target="_blank" rel="external">原码、反码和补码</a></p>
<p>欢迎大家点评讨论！</p>
]]></content>
    <summary type="html">
    <![CDATA[介绍计算机中的原码、反码、补码]]>
    
    </summary>
    
      <category term="二进制" scheme="http://vickyqi.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="反码" scheme="http://vickyqi.com/tags/%E5%8F%8D%E7%A0%81/"/>
    
      <category term="补数" scheme="http://vickyqi.com/tags/%E8%A1%A5%E6%95%B0/"/>
    
      <category term="补码" scheme="http://vickyqi.com/tags/%E8%A1%A5%E7%A0%81/"/>
    
      <category term="计算机" scheme="http://vickyqi.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="计算机基础" scheme="http://vickyqi.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[正则学习二三事]]></title>
    <link href="http://vickyqi.com/2015/10/19/%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
    <id>http://vickyqi.com/2015/10/19/正则学习二三事/</id>
    <published>2015-10-19T06:19:11.000Z</published>
    <updated>2015-11-01T08:10:38.000Z</updated>
    <content type="html"><![CDATA[<p>正则一直是我一大痛点，一直都想解决这个问题，但是奈何每次看到那么多符号就发蒙，所以就一直拖下去了。直到最近总是被别人问到如何在hql中使用rlike查询符合特定规则的字段，然后各种不会，结果被鄙视的一塌糊涂，无奈，这才静下心来慢慢研究。<br>以前看正则就是一堆符号，代表各个意思，如\d表示数字，\d+表示一个或者多个连续数字，单看每个规则都可以理解，除了组合，但是实际使用时真的很难组织到一起。归根结底还是因为对这些符号的理解不够深入。所以正则还是得多写，推荐一个在线练习的网站<a href="http://regex.alf.nu/" target="_blank" rel="external">RegexGolf</a>。好了，下面写写自己学习正则的一些总结吧，希望能够帮助到别人，也帮助自己总结总结。</p>
<h4 id="正则的基础知识："><strong>正则的基础知识：</strong></h4><h5 id="字面值"><strong>字面值</strong></h5><p>正则表达式由只代表自身的字面值和代表特定含义的元字符组成。 只代表自身的字面值指的是普通的字符，如abcde，特殊含义的元字符包括：</p>
<table>
<thead>
<tr>
<th></th>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>\</td>
<td>反斜线字符</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\0n</td>
<td>带有八进制值 0 的字符 n (0 &lt;= n &lt;= 7)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\0nn</td>
<td>带有八进制值 0 的字符 nn (0 &lt;= n &lt;= 7)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\0mnn</td>
<td>带有八进制值 0 的字符 mnn（0 &lt;= m &lt;= 3、0 &lt;= n &lt;= 7）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\xhh</td>
<td>带有十六进制值 0x 的字符 hh</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\uhhhh</td>
<td>带有十六进制值 0x 的字符 hhhh</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\t</td>
<td>制表符 (‘\u0009’)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\n</td>
<td>新行（换行）符 (‘\u000A’)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\r</td>
<td>回车符 (‘\u000D’)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\f</td>
<td>换页符 (‘\u000C’)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\a</td>
<td>报警 (bell) 符 (‘\u0007’)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\e</td>
<td>转义符 (‘\u001B’)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\cx</td>
<td>对应于 x 的控制符</td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="字符类"><strong>字符类</strong></h5><p> 字符类是字符在方括号中的集合。表示“找到集合里任意一个字符“。例如：</p>
<table>
<thead>
<tr>
<th></th>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>[abc]</td>
<td>a、b 或 c（简单类）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>[^abc]</td>
<td>任何字符，除了 a、b 或 c（否定）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>[a-zA-Z]</td>
<td>a 到 z 或 A 到 Z，两头的字母包括在内（范围）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>[a-d[m-p]]</td>
<td>a 到 d 或 m 到 p：[a-dm-p]（并集）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>[a-z&amp;&amp;[def]]</td>
<td>d、e 或 f（交集）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>[a-z&amp;&amp;[^bc]]</td>
<td>a 到 z，除了 b 和 c：[ad-z]（减去）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>[a-z&amp;&amp;[^m-p]]</td>
<td>a 到 z，而非 m 到 p：[a-lq-z]（减去）</td>
<td></td>
</tr>
</tbody>
</table>
<p>从上表可以看出<strong>[]</strong>里面可进行并集/交集/差集操作。对于字符范围是根据ASCII值的大小来的，例如[A-z]也是可以的，甚至能够匹配[，但是完全不建议如此使用，推荐使用的字符范围：[0-9]/[a-z]/[A-Z]。<br>字符类还有一些预定义的字符类：</p>
<table>
<thead>
<tr>
<th></th>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>. 任何字符（与行结束符可能匹配也可能不匹配）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\d</td>
<td>数字：[0-9]</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\D</td>
<td>非数字： [^0-9]</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\s</td>
<td>空白字符：[ \t\n\x0B\f\r]</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\S</td>
<td>非空白字符：[^\s]</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\w</td>
<td>单词字符：[a-zA-Z_0-9]</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\W</td>
<td>非单词字符：[^\w]</td>
<td></td>
</tr>
</tbody>
</table>
<p>使用上面的预定义字符类能够更加方便的表示字符范围。需要牢记。<br><strong>注意</strong>： 区间是字符的区间，不是数字的区间。正则表达式[1-31]表示“找到一个1或一个2或一个3”，不是“找到一个从1到31的整数”。</p>
<h5 id="乘法器"><strong>乘法器</strong></h5><table>
<thead>
<tr>
<th></th>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>X?</td>
<td>X，一次或一次也没有</td>
<td></td>
</tr>
<tr>
<td></td>
<td>X*</td>
<td>X，零次或多次</td>
<td></td>
</tr>
<tr>
<td></td>
<td>X+</td>
<td>X，一次或多次</td>
<td></td>
</tr>
<tr>
<td></td>
<td>X{n}</td>
<td>X，恰好 n 次</td>
<td></td>
</tr>
<tr>
<td></td>
<td>X{n,}</td>
<td>X，至少 n 次</td>
<td></td>
</tr>
<tr>
<td></td>
<td>X{n,m}</td>
<td>X，至少 n 次，但是不超过 m 次</td>
<td></td>
</tr>
</tbody>
</table>
<p>X可以使一个普通字面值，如a+：一个或多个a，也可以是一个字符类，如[abc]{2}，表示a/b/c后跟a/b/c。<br>值得注意的是优先选择更长的匹配，因为乘法器是贪婪的。如果你输入的文本是I had an aaaaawful day，该正则表达式就会在aaaaawful中匹配到aaaaa。不会在第三个a后就停止匹配。<br>乘法器是贪婪的，但它不会忽略一个更好的匹配。如果你的输入文本为I had an aaawful daaaaay，之后这个正则表达式会在第一次的匹配中于aaawful找到aaa。只有在你说“给我找到另一个匹配”的时候，它才会继续搜索然后在daaaaay中找到aaaaa。<br>惰性：<br>正则表达式<em>“.</em>“<em>表示“找到一个双引号，接着找到尽可能多的字符，最后再找到一个双引号”。注意一下被.</em>匹配的内部字符，很可能包含多个双引号。这通常不是非常有用。乘法器可通过追加问号<strong>（?）</strong>来实现<strong>惰性</strong>。<em>“.</em>?”*表示“匹配一个双引号，跟着一个尽可能少的字符，再跟着一个双引号”。</p>
<h5 id="分支"><strong>分支</strong></h5><p>可以使用管道符号来实现匹配多种选择。</p>
<table>
<thead>
<tr>
<th></th>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>X!Y(用!代替竖线)</td>
<td>X或者Y</td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="组合"><strong>组合</strong></h5><p>可以使用圆括号来组合表达式。例：<br>在一周中找到一天，使用<strong>(Mon|Tues|Wednes|Thurs|Fri|Satur|Sun)day</strong>，这里如果把小括号或者中括号，结果是完全不一样的，因为中括号是字符类，即里面的Mon并不是完全匹配Mon，而是只要匹配M/o/n其中一个即可。<br>同时组合后面还可跟上乘法器，如：<strong>\w+(\s+\w+)*</strong>代表“找到一个或多个单词，它们以空格隔开”。</p>
<h5 id="边界"><strong>边界</strong></h5><p>边界分成：单词边界，行边界，文本边界</p>
<ol>
<li>单词边界<br>单词边界是一个单词字符和非单词字符之间的位置。记住，一个单词字符是\w，它是[0-9A-Za-z<em>]，一个非单词字符是\W，也就是[^0-9A-Za-z</em>]。<br>文本的开头和结尾总是当作单词边界。<br>输入的文本<strong>it’s a cat</strong>有八个单词边界，分别为：文本开头-i，t-‘，’-s，s-空格，空格-a，a-空格，空格-c，t-文本结尾。</li>
<li>行边界<br>每一块文本会分解成一个或多个行，用换行符分隔。<br>注意文本不是以换行符结束，而是以行结束。然而，任何行，包括最后一行，可以包含零个字符。<br>起始行位置是在一个换行符和下一行的第一个字符之间。与单词边界一样，在文本的开头也算作一个起始的行。结束行位置是在行的最后一个字符和换行符之间。与单词边界一样，文本结束也算作行结束。</li>
<li>文本边界<br>很多实现提供一个标记，通过改变它来改变^和$的含义。从“行开始”和“行结束”变成“文本开始”和“文本结束”。其它的一些实现提供单独的元字符\A和\z来达到这个目的。<br>一些表示边界的符号：</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>^</td>
<td>行的开头</td>
<td></td>
</tr>
<tr>
<td></td>
<td>$</td>
<td>行的结尾</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\b</td>
<td>单词边界</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\B</td>
<td>非单词边界</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\A</td>
<td>输入的开头</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\G</td>
<td>上一个匹配的结尾</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\Z</td>
<td>输入的结尾，仅用于最后的结束符（如果有的话）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\z</td>
<td>输入的结尾</td>
<td></td>
</tr>
</tbody>
</table>
<p>其中^$是最常用的两个边界分隔符。</p>
<h4 id="捕获和替换："><strong>捕获和替换：</strong></h4><ol>
<li><p>捕获组</p>
<p>()在正则中被用来表示组，同时也可以用来捕获匹配上的子串，可以拥有多个捕获组，它们甚至可以嵌套使用，捕获组从左到右进行编号，只要计算左圆括号。例如：<br>对于表达式：<strong>(\w+) had a ((\w+) \w+)</strong>，文本是I had a nice day，那么</p>
<ul>
<li>捕获组1是I。</li>
<li>捕获组2是nice day。</li>
<li>捕获组3是nice。</li>
<li>捕获组0是I had a nice day（根据具体实现不同）</li>
</ul>
<p>如果表达式使用了两个捕获组，但是只捕获到一组，那么组2是空字符串。引用捕获组使用+组序号，如\1表示引用第一个捕获组。</p>
</li>
<li>后向引用<br>可以在同样的表达式中引用同一个捕获组，这称为后向引用。<br>例：表达式[abc]{2}表示“匹配aa或ab或ac or ba或bb或bc或ca或cb或cc”，但是表达式([abc])\1表示“匹配aa或bb或cc”。</li>
</ol>
<p>以上就是正则的全部知识，其实了解正则的知识点很简单，但是真要应用到实际中还是需要通过大量的练习才能做到熟练使用。</p>
<h5 id="实际案例"><strong>实际案例</strong></h5><ol>
<li><p>压缩CSS文件，去掉CSS文件中的换行以及空格</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">工具：Notepad++  查找：([&#123;;])<span class="string">\s+</span>  替换：<span class="string">\1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>替换文件中连续出现的#，为其后面添加一个空格，例：####你好-&gt;#### 你好</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">工具：Notepad++  查找：([<span class="preprocessor">#]+)  替换：\<span class="number">1</span> (<span class="number">1</span>后面有个空格)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上案例会不断更新，已记录一些自己对正则使用的经历。</p>
<h4 id="参考文章"><strong>参考文章</strong></h4><p><a href="http://doslin.com/regular%20expressions/2014/03/11/learn-regular-expressions-in-about-55-minutes.html" target="_blank" rel="external">55分钟学会正则表达式(译)</a></p>
<p>JDK API文档</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>正则一直是我一大痛点，一直都想解决这个问题，但是奈何每次看到那么多符号就发蒙，所以就一直拖下去了。直到最近总是被别人问到如何在hql中使用rlike查询符合特定规则的字段，然后各种不会，结果被鄙视的一塌糊涂，无奈，这才静下心来慢慢研究。<br>以前看正则就是一堆符号，代表各]]>
    </summary>
    
      <category term="正则" scheme="http://vickyqi.com/tags/%E6%AD%A3%E5%88%99/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[排序算法系列——八大排序算法对比分析]]></title>
    <link href="http://vickyqi.com/2015/08/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/"/>
    <id>http://vickyqi.com/2015/08/21/排序算法系列——八大排序算法对比分析/</id>
    <published>2015-08-21T11:14:00.000Z</published>
    <updated>2015-11-14T11:25:40.000Z</updated>
    <content type="html"><![CDATA[<p>本系列最后一篇，综合分析下前面介绍的八种排序算法的效率，以及各自的适用情况。<br>下面先看看八种排序算法的时间复杂度表格：<br><img src="http://img.blog.csdn.net/20150821162219212" alt="八种排序算法时间复杂度"><br>图中八种排序被分成了两组，一组时间复杂度为O(n^2)，另一组相对高效些。<br>下面先对第一组O(n^2)的四种排序算法进行对比，分别取数组长度为100,1000,10000,100000四个数量级，各个元素在0-10000000之间随机获取。下面看下结果的分析。</p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th style="text-align:center">长度=100</th>
<th style="text-align:right">长度=1000</th>
<th style="text-align:right">长度=10000</th>
<th style="text-align:right">长度=100000</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序</td>
<td style="text-align:center">535</td>
<td style="text-align:right">2,198</td>
<td style="text-align:right">135,773</td>
<td style="text-align:right">16,554,053</td>
</tr>
<tr>
<td>希尔排序</td>
<td style="text-align:center">308</td>
<td style="text-align:right">703</td>
<td style="text-align:right">3,639</td>
<td style="text-align:right">39,769</td>
</tr>
<tr>
<td>直接选择排序</td>
<td style="text-align:center">382</td>
<td style="text-align:right">3,219</td>
<td style="text-align:right">232,495</td>
<td style="text-align:right">24,201,891</td>
</tr>
<tr>
<td>冒泡排序</td>
<td style="text-align:center">525</td>
<td style="text-align:right">5,377</td>
<td style="text-align:right">475,865</td>
<td style="text-align:right">62,703,335</td>
</tr>
</tbody>
</table>
<p>从上表可以看出，以上四种算法效率最高的绝对是希尔排序，其次是直接插入排序，再就是直接选择排序，最后才是冒泡排序。事实证明冒泡排序真的不适合实际应用，实际使用中最优先选择希尔排序，但是如果要求稳定性的话就选择直接插入排序，但是效率差太多了。<br>下面主要对另外四个排序算法进行对比，不过通过上面的结果，所以在这里把希尔排序也加进来一起比较。由于基数排序对数组最大位数敏感，所以这里会分别对最大值为3位、4位、5位、6位、7位五种情况分别对应长度为10000,100000,1000000,10000000四种情况进行比较，长度太小体现不出O(nlgn)的优势。</p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th style="text-align:right">长度=10000</th>
<th style="text-align:right">长度=100000</th>
<th style="text-align:right">长度=1000000</th>
<th style="text-align:right">长度=10000000</th>
</tr>
</thead>
<tbody>
<tr>
<td>希尔排序</td>
<td style="text-align:right">3996</td>
<td style="text-align:right">36439</td>
<td style="text-align:right">876530</td>
<td style="text-align:right">12129001</td>
</tr>
<tr>
<td>堆排序</td>
<td style="text-align:right">3451</td>
<td style="text-align:right">38077</td>
<td style="text-align:right">767878</td>
<td style="text-align:right">10459868</td>
</tr>
<tr>
<td>快速排序</td>
<td style="text-align:right">2446</td>
<td style="text-align:right">37998</td>
<td style="text-align:right">2566811</td>
<td style="text-align:right">673399814</td>
</tr>
<tr>
<td>归并排序</td>
<td style="text-align:right">2549</td>
<td style="text-align:right">23595</td>
<td style="text-align:right">356314</td>
<td style="text-align:right">8325651</td>
</tr>
<tr>
<td>基数排序</td>
<td style="text-align:right">4162</td>
<td style="text-align:right">12724</td>
<td style="text-align:right">272851</td>
<td style="text-align:right">10866036</td>
</tr>
</tbody>
</table>
<p>上表是<strong>MaxValue=1000</strong>时的结果，从表中可以看出当长度为10000时快速排序和归并排序效果最好，基数排序效果最差，但是当长度达到10W和100W基数排序效果最好，不过归并排序效率就比快速排序高很多了，同时快速排序当排序数组长度达到100W时效果变得很差，远远落后其他四个排序算法。所以当待排序数组最大值为1000时，数组长度为10000时使用快速和归并，当长度为1000W以内使用基数排序，或者归并排序。</p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th style="text-align:center">长度=10000</th>
<th style="text-align:right">长度=100000</th>
<th style="text-align:right">长度=1000000</th>
<th style="text-align:right">长度=10000000</th>
</tr>
</thead>
<tbody>
<tr>
<td>希尔排序</td>
<td style="text-align:center">16349</td>
<td style="text-align:right">201486</td>
<td style="text-align:right">2800650</td>
<td style="text-align:right">53033110</td>
</tr>
<tr>
<td>堆排序</td>
<td style="text-align:center">3622</td>
<td style="text-align:right">130898</td>
<td style="text-align:right">3091654</td>
<td style="text-align:right">51502613</td>
</tr>
<tr>
<td>快速排序</td>
<td style="text-align:center">2366</td>
<td style="text-align:right">83221</td>
<td style="text-align:right">985588</td>
<td style="text-align:right">71016772</td>
</tr>
<tr>
<td>归并排序</td>
<td style="text-align:center">2544</td>
<td style="text-align:right">60744</td>
<td style="text-align:right">841400</td>
<td style="text-align:right">20983723</td>
</tr>
<tr>
<td>基数排序</td>
<td style="text-align:center">4815</td>
<td style="text-align:right">42903</td>
<td style="text-align:right">962442</td>
<td style="text-align:right">15133291</td>
</tr>
</tbody>
</table>
<p>以上是<strong>MaxValue=10000</strong>时的结果，从表中可以看出基数排序的效果最好，其次是归并排序，然后快速排序。所以当待排序数组最大值为10000时使用基数排序还是很不错的，虽然长度在10000时效果不如归并排序。当然归并排序也是个不错的选择。</p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th style="text-align:center">长度=10000</th>
<th style="text-align:right">长度=100000</th>
<th style="text-align:right">长度=1000000</th>
<th style="text-align:right">长度=10000000</th>
</tr>
</thead>
<tbody>
<tr>
<td>希尔排序</td>
<td style="text-align:center">5107</td>
<td style="text-align:right">203601</td>
<td style="text-align:right">3401635</td>
<td style="text-align:right">89081661</td>
</tr>
<tr>
<td>堆排序</td>
<td style="text-align:center">5900</td>
<td style="text-align:right">140530</td>
<td style="text-align:right">4087559</td>
<td style="text-align:right">76957182</td>
</tr>
<tr>
<td>快速排序</td>
<td style="text-align:center">2873</td>
<td style="text-align:right">89582</td>
<td style="text-align:right">1553479</td>
<td style="text-align:right">30429666</td>
</tr>
<tr>
<td>归并排序</td>
<td style="text-align:center">3215</td>
<td style="text-align:right">81579</td>
<td style="text-align:right">1238016</td>
<td style="text-align:right">21442519</td>
</tr>
<tr>
<td>基数排序</td>
<td style="text-align:center">15017</td>
<td style="text-align:right">65216</td>
<td style="text-align:right">1116738</td>
<td style="text-align:right">16308437</td>
</tr>
</tbody>
</table>
<p>以上是<strong>MaxValue=100000</strong>时的结果，从表中可以看出结果同<strong>MaxValue=10000</strong>时的结果差不多。</p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th style="text-align:center">长度=10000</th>
<th style="text-align:right">长度=100000</th>
<th style="text-align:right">长度=1000000</th>
<th style="text-align:right">长度=10000000</th>
</tr>
</thead>
<tbody>
<tr>
<td>希尔排序</td>
<td style="text-align:center">3701</td>
<td style="text-align:right">246185</td>
<td style="text-align:right">3496864</td>
<td style="text-align:right">79870999</td>
</tr>
<tr>
<td>堆排序</td>
<td style="text-align:center">3999</td>
<td style="text-align:right">122765</td>
<td style="text-align:right">3563651</td>
<td style="text-align:right">69155734</td>
</tr>
<tr>
<td>快速排序</td>
<td style="text-align:center">14974</td>
<td style="text-align:right">45710</td>
<td style="text-align:right">1351332</td>
<td style="text-align:right">19350824</td>
</tr>
<tr>
<td>归并排序</td>
<td style="text-align:center">3718</td>
<td style="text-align:right">47956</td>
<td style="text-align:right">1375705</td>
<td style="text-align:right">23364515</td>
</tr>
<tr>
<td>基数排序</td>
<td style="text-align:center">15001</td>
<td style="text-align:right">37974</td>
<td style="text-align:right">1290274</td>
<td style="text-align:right">16083427</td>
</tr>
</tbody>
</table>
<p>以上是<strong>MaxValue=1000000</strong>时的结果，结果还是一样，基数排序效果最好。</p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th style="text-align:center">长度=10000</th>
<th style="text-align:right">长度=100000</th>
<th style="text-align:right">长度=1000000</th>
<th style="text-align:right">长度=10000000</th>
</tr>
</thead>
<tbody>
<tr>
<td>希尔排序</td>
<td style="text-align:center">4063</td>
<td style="text-align:right">235374</td>
<td style="text-align:right">3524810</td>
<td style="text-align:right">92989117</td>
</tr>
<tr>
<td>堆排序</td>
<td style="text-align:center">11444</td>
<td style="text-align:right">155166</td>
<td style="text-align:right">3461969</td>
<td style="text-align:right">63201731</td>
</tr>
<tr>
<td>快速排序</td>
<td style="text-align:center">7501</td>
<td style="text-align:right">61635</td>
<td style="text-align:right">1435866</td>
<td style="text-align:right">19843452</td>
</tr>
<tr>
<td>归并排序</td>
<td style="text-align:center">3376</td>
<td style="text-align:right">42739</td>
<td style="text-align:right">1322604</td>
<td style="text-align:right">20859039</td>
</tr>
<tr>
<td>基数排序</td>
<td style="text-align:center">6159</td>
<td style="text-align:right">106208</td>
<td style="text-align:right">1535261</td>
<td style="text-align:right">25146006</td>
</tr>
</tbody>
</table>
<p>以上是<strong>MaxValue=10000000</strong>时的结果，基数排序的效率已经没有归并排序好了，应该由于归并的次数增加了。<br>这里有个地方很奇怪，可以从上面<strong>MaxValue=1000</strong>时的表中可以看到当长度=100W时，快速排序的时间超过其他四个排序一个数量级，但是当MaxValue=10000，甚至更大之后快速排序的时间都和其它排序是一个数据量，而且<strong>MaxValue=1000</strong>时耗时大于<strong>MaxValue=10000</strong>以上。具体原因未知，大家可以自己测试，也许重复元素太多会影响快速排序的效率？<br>综合以上所有测试结果，总结各个排序算法的适用场景。<br><strong>直接插入排序</strong>：直接用希尔排序替代就好，除非待排序数组本身就是部分有序<br><strong>希尔排序</strong>：    效果最好，秒杀所有O(n^2)的排序算法，所在在数据量较小的场景下，如100000个元素以下都可考虑希尔排序<br><strong>直接选择排序</strong>：    直接用希尔排序替代，或者用堆排序替代<br><strong>冒泡排序</strong>：    强烈推荐不使用此排序算法<br><strong>堆排序</strong>：    优于希尔排序，推荐替代希尔排序，但是如果待排序数组是部分有序的那么希尔优于堆排序<br><strong>快速排序</strong>：    数组长度100W以下效率最高，100W以上可以用归并排序替代<br><strong>归并排序</strong>：    不考虑基数排序的话，数组长度100W以上效率最高，100W以下可以用快速排序替代<br><strong>基数排序</strong>：    适用场景要求较高，元素必须是整数，整数时长度10W以上，最大值100W以下效率较好，但是基数排序比其他排序好在可以适用字符串，或者其他需要根据多个条件进行排序的场景，例如日期，先排序日，再排序月，最后排序年 ，其它排序算法可是做不了的。<br>下面附上测试代码：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vicky.<span class="built_in">sort</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class SortComparison2 &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 比较全部排序算法</span><br><span class="line">	 */</span></span><br><span class="line">	@Test</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> testAll() &#123;</span><br><span class="line">		Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="built_in">int</span> num = -<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">int</span> maxValue = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 从命令行输入元素数量，以及最大值，格式：10,1000，输入quit结束</span></span><br><span class="line">			<span class="keyword">String</span> input = scan.next();</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">"quit"</span>.equals(input)) &#123;</span><br><span class="line">				System.<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">String</span>[] strs = input.<span class="built_in">split</span>(<span class="string">","</span>);</span><br><span class="line">			num = Integer.parseInt(strs[<span class="number">0</span>]);</span><br><span class="line">			maxValue = Integer.parseInt(strs[<span class="number">1</span>]);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Sort Data Num = "</span> + num + <span class="string">", MaxValue = "</span> + maxValue);</span><br><span class="line"></span><br><span class="line">			Random ran = <span class="keyword">new</span> Random();</span><br><span class="line">			Integer[] data = <span class="keyword">new</span> Integer[num];</span><br><span class="line">			Integer[] data1 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">			Integer[] data2 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">			Integer[] data3 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">			Integer[] data4 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">			Integer[] data5 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">			Integer[] data6 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">			Integer[] data7 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">			Integer[] data8 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">				data[i] = ran.nextInt(maxValue);</span><br><span class="line">				data1[i] = data[i];</span><br><span class="line">				data2[i] = data[i];</span><br><span class="line">				data3[i] = data[i];</span><br><span class="line">				data4[i] = data[i];</span><br><span class="line">				data5[i] = data[i];</span><br><span class="line">				data6[i] = data[i];</span><br><span class="line">				data7[i] = data[i];</span><br><span class="line">				data8[i] = data[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 插入排序</span></span><br><span class="line">			<span class="keyword">long</span> insertTimes = testStraightInsertionSort(data1);</span><br><span class="line">			<span class="keyword">long</span> shellTimes = testShellSort(data2);</span><br><span class="line">			<span class="comment">// 选择排序</span></span><br><span class="line">			<span class="keyword">long</span> selectTimes = testStraightSelectionSort(data3);</span><br><span class="line">			<span class="keyword">long</span> heapTimes = testHeapSort(data4);</span><br><span class="line">			<span class="comment">// 交换排序</span></span><br><span class="line">			<span class="keyword">long</span> bubbleTimes = testBubbleSort(data5);</span><br><span class="line">			<span class="keyword">long</span> quickTimes = testQuickSort(data6);</span><br><span class="line">			<span class="comment">// 归并排序</span></span><br><span class="line">			<span class="keyword">long</span> mergeTimes = testMergeSort(data7);</span><br><span class="line">			<span class="comment">// 基数排序</span></span><br><span class="line">			<span class="keyword">long</span> radixTimes = testRadixSort(data8);</span><br><span class="line"></span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"method       \ttime(ms)"</span>);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"InsertionSort\t"</span> + insertTimes);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"ShellSort    \t"</span> + shellTimes);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"SelectionSort\t"</span> + selectTimes);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"HeapSort     \t"</span> + heapTimes);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"BubbleSort   \t"</span> + bubbleTimes);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"QuickSort    \t"</span> + quickTimes);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"MergeSort    \t"</span> + mergeTimes);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"RadixSort    \t"</span> + radixTimes);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 *测试时间复杂度为O(n^2)的排序</span><br><span class="line">	 */</span></span><br><span class="line">	@Test</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> testBase() &#123;</span><br><span class="line">		Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="built_in">int</span> num = -<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">int</span> maxValue = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 从命令行输入元素数量，以及最大值，格式：10,1000，输入quit结束</span></span><br><span class="line">			<span class="keyword">String</span> input = scan.next();</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">"quit"</span>.equals(input)) &#123;</span><br><span class="line">				System.<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">String</span>[] strs = input.<span class="built_in">split</span>(<span class="string">","</span>);</span><br><span class="line">			num = Integer.parseInt(strs[<span class="number">0</span>]);</span><br><span class="line">			maxValue = Integer.parseInt(strs[<span class="number">1</span>]);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Sort Data Num = "</span> + num + <span class="string">", MaxValue = "</span> + maxValue);</span><br><span class="line"></span><br><span class="line">			Random ran = <span class="keyword">new</span> Random();</span><br><span class="line">			Integer[] data = <span class="keyword">new</span> Integer[num];</span><br><span class="line">			Integer[] data1 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">			Integer[] data2 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">			Integer[] data3 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">			Integer[] data4 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">				data[i] = ran.nextInt(maxValue);</span><br><span class="line">				data1[i] = data[i];</span><br><span class="line">				data2[i] = data[i];</span><br><span class="line">				data3[i] = data[i];</span><br><span class="line">				data4[i] = data[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 插入排序</span></span><br><span class="line">			<span class="keyword">long</span> insertTimes = testStraightInsertionSort(data1);</span><br><span class="line">			<span class="keyword">long</span> shellTimes = testShellSort(data2);</span><br><span class="line">			<span class="comment">// 选择排序</span></span><br><span class="line">			<span class="keyword">long</span> selectTimes = testStraightSelectionSort(data3);</span><br><span class="line">			<span class="comment">// 交换排序</span></span><br><span class="line">			<span class="keyword">long</span> bubbleTimes = testBubbleSort(data4);</span><br><span class="line"></span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"method       \ttime(ms)"</span>);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"InsertionSort\t"</span> + insertTimes);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"ShellSort    \t"</span> + shellTimes);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"SelectionSort\t"</span> + selectTimes);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"BubbleSort   \t"</span> + bubbleTimes);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 比较O(nlgn)左右的排序算法</span><br><span class="line">	 * </span><br><span class="line">	 * 这里把希尔加上是因为虽然希尔时间复杂度是O(n^2)但是从实际结果来看其效率还是较高的，所以拿来跟O(nlgn)一起对比</span><br><span class="line">	 */</span></span><br><span class="line">	@Test</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> testGood() &#123;</span><br><span class="line">		Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="built_in">int</span> num = -<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">int</span> maxValue = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 从命令行输入元素数量，以及最大值，格式：10,1000，输入quit结束</span></span><br><span class="line">			<span class="keyword">String</span> input = scan.next();</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">"quit"</span>.equals(input)) &#123;</span><br><span class="line">				System.<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">String</span>[] strs = input.<span class="built_in">split</span>(<span class="string">","</span>);</span><br><span class="line">			num = Integer.parseInt(strs[<span class="number">0</span>]);</span><br><span class="line">			maxValue = Integer.parseInt(strs[<span class="number">1</span>]);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Sort Data Num = "</span> + num + <span class="string">", MaxValue = "</span> + maxValue);</span><br><span class="line"></span><br><span class="line">			Random ran = <span class="keyword">new</span> Random();</span><br><span class="line">			Integer[] data = <span class="keyword">new</span> Integer[num];</span><br><span class="line">			Integer[] data1 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">			Integer[] data2 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">			Integer[] data3 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">			Integer[] data4 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">			Integer[] data5 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">				data[i] = ran.nextInt(maxValue);</span><br><span class="line">				data1[i] = data[i];</span><br><span class="line">				data2[i] = data[i];</span><br><span class="line">				data3[i] = data[i];</span><br><span class="line">				data4[i] = data[i];</span><br><span class="line">				data5[i] = data[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 插入排序</span></span><br><span class="line">			<span class="keyword">long</span> shellTimes = testShellSort(data1);</span><br><span class="line">			<span class="comment">// 选择排序</span></span><br><span class="line">			<span class="keyword">long</span> heapTimes = testHeapSort(data2);</span><br><span class="line">			<span class="comment">// 交换排序</span></span><br><span class="line">			<span class="keyword">long</span> quickTimes = testQuickSort(data3);</span><br><span class="line">			<span class="comment">// 归并排序</span></span><br><span class="line">			<span class="keyword">long</span> mergeTimes = testMergeSort(data4);</span><br><span class="line">			<span class="comment">// 基数排序</span></span><br><span class="line">			<span class="keyword">long</span> radixTimes = testRadixSort(data5);</span><br><span class="line"></span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"method       \ttime(ms)"</span>);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"ShellSort    \t"</span> + shellTimes);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"HeapSort     \t"</span> + heapTimes);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"QuickSort    \t"</span> + quickTimes);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"MergeSort    \t"</span> + mergeTimes);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"RadixSort    \t"</span> + radixTimes);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="keyword">long</span> testStraightInsertionSort(T[] data) &#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">		StraightInsertionSort.<span class="built_in">sort</span>(data);</span><br><span class="line">		<span class="keyword">return</span> (System.nanoTime() - start) / <span class="number">1000</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="keyword">long</span> testShellSort(T[] data) &#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">		ShellSort.<span class="built_in">sort</span>(data);</span><br><span class="line">		<span class="keyword">return</span> (System.nanoTime() - start) / <span class="number">1000</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="keyword">long</span> testStraightSelectionSort(T[] data) &#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">		StraightSelectionSort.<span class="built_in">sort</span>(data);</span><br><span class="line">		<span class="keyword">return</span> (System.nanoTime() - start) / <span class="number">1000</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="keyword">long</span> testHeapSort(T[] data) &#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">		HeapSort.<span class="built_in">sort</span>(data);</span><br><span class="line">		<span class="keyword">return</span> (System.nanoTime() - start) / <span class="number">1000</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="keyword">long</span> testBubbleSort(T[] data) &#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">		BubbleSort.<span class="built_in">sort</span>(data);</span><br><span class="line">		<span class="keyword">return</span> (System.nanoTime() - start) / <span class="number">1000</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="keyword">long</span> testQuickSort(T[] data) &#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">		QuickSort.<span class="built_in">sort</span>(data);</span><br><span class="line">		<span class="keyword">return</span> (System.nanoTime() - start) / <span class="number">1000</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="keyword">long</span> testMergeSort(T[] data) &#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">		MergeSort.<span class="built_in">sort</span>(data);</span><br><span class="line">		<span class="keyword">return</span> (System.nanoTime() - start) / <span class="number">1000</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> testRadixSort(Integer[] data) &#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">		RadixSort.<span class="built_in">sort</span>(data);</span><br><span class="line">		<span class="keyword">return</span> (System.nanoTime() - start) / <span class="number">1000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行时需要指定JVM运行参数：<strong>-Xms1024m -Xmx1024m -Xss2048k</strong>。<br>以上测试可能会有偏差，</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列最后一篇，综合分析下前面介绍的八种排序算法的效率，以及各自的适用情况。<br>下面先看看八种排序算法的时间复杂度表格：<br><img src="http://img.blog.csdn.net/20150821162219212" alt="八种排序算法时间复杂度"]]>
    </summary>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="排序" scheme="http://vickyqi.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="排序" scheme="http://vickyqi.com/categories/Java/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[排序算法系列——基数排序]]></title>
    <link href="http://vickyqi.com/2015/08/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://vickyqi.com/2015/08/21/排序算法系列——基数排序/</id>
    <published>2015-08-21T04:05:00.000Z</published>
    <updated>2015-11-14T11:31:32.000Z</updated>
    <content type="html"><![CDATA[<p>基数排序不同于其他的七种排序算法，它是基于一种分配法，而非比较。基数排序属于“分配式排序”（distribution sort），基数排序法又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用。它的灵感来自于队列(Queue)，它最独特的地方在于利用了数字的有穷性(阿拉伯数字只有0到9的10个)。</p>
<h5 id="基本思想"><strong>基本思想</strong></h5><p>我们考虑对整数进行基数排序的过程，对于整数，我们可以将其分成个位、十位、百位、。。。基数排序就是先对元素的个位进行排序，然后再对十位进行排序，。。。最终按最高位进行排序完成整个排序。逻辑可以理解为，比如正常情况下我们排序两个整数，我们首先对比的是十位然后是个位，现在我们颠倒过来先排序个位，再排序十位，如果十位相同上一步我们已经按个位排好序，所以还是有序的。其实基数排序也有另一种方式MSD，即从高位开始。</p>
<h5 id="实现要点"><strong>实现要点</strong></h5><p>首先我们需要一个能够放下所有一位数的桶（bucket），还好阿拉伯数字只有10个，所以我们只需要10个bucket就可以搞定，但是在将所有元素放入bucket时肯定会出现多个元素放入一个bucket的情况，这时候就需要使用链表来解决了（也有使用二维数组的方式，但是空间需要n^2，当排序元素很多时肯定有点吃不消），同时为了方便往bucket中遍历元素以及添加元素，我们让bucket包含两个指针，一个指向bucket中第一个元素（head），另一个指向最后一个元素（tail），而bucket中每个元素都是一个Node，Node中包含一个排序序列中的值（val）以及一个指向下一个元素的指针（next）。<br>有了桶，下一步就是需要将所有数值从个位开始依次放入桶，然后再按顺序取出放回原数组了，这里有个地方需要注意下，就是如何循环到数组中所有元素的最高位就终止循环，这里有两个解决方法：<br>（1）首先遍历一遍数组，找到最大值，确定最高位<br>（2）一直循环直到所有元素的指定位数都是0为止<br>第一种方法需要O(n)次的比较，而第二次需要计算每个值在指定位数的值，同时还需要将其放入桶中。我的实现需要第一种方式。<br>到这里基本就可以实现出一个基数排序了，下面就看看如何实现。<br><strong>Java实现</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vicky.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 基数排序</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> Vicky</span><br><span class="line"> * </span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RADIX = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Integer[] data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == data) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"data"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (data.length == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 遍历一遍，找到最大值，确定最高位数</span></span><br><span class="line">		<span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (; i &lt; data.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (data[i] &gt; max) &#123;</span><br><span class="line">				max = data[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 计算最高位数</span></span><br><span class="line">		<span class="keyword">int</span> maxDigit = String.valueOf(max).length();</span><br><span class="line">		Bucket[] temp = <span class="keyword">new</span> Bucket[RADIX];<span class="comment">// 用于保存各个位数的bucket</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">0</span>; num &lt; maxDigit; num++) &#123;</span><br><span class="line">			<span class="comment">// 将每个元素指定位数的值放入对应的bucket中</span></span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">				<span class="keyword">int</span> val = data[i] / pow(RADIX, num);</span><br><span class="line">				Node node = <span class="keyword">new</span> Node(data[i], <span class="keyword">null</span>);</span><br><span class="line">				Bucket tmp = temp[val % RADIX];</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">null</span> == tmp) &#123;</span><br><span class="line">					temp[val % RADIX] = <span class="keyword">new</span> Bucket(node, node);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					tmp.getTail().setNext(node);</span><br><span class="line">					tmp.setTail(node);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 将temp中保存的元素按顺序更新到原数组中</span></span><br><span class="line">			<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">null</span> == temp[i]) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				Node node = temp[i].getHead();</span><br><span class="line">				data[index++] = node.getValue();</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">null</span> != node.getNext()) &#123;</span><br><span class="line">					data[index++] = node.getNext().getValue();</span><br><span class="line">					node = node.getNext();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 顺便重置temp</span></span><br><span class="line">				temp[i] = <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"use time:"</span> + (System.nanoTime() - start) / <span class="number">1000000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 计算指定基数的指定幂的值</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> digit</span><br><span class="line">	 *            基数，如10</span><br><span class="line">	 * <span class="doctag">@param</span> num</span><br><span class="line">	 *            幂次值，从0开始，10^0=1</span><br><span class="line">	 * <span class="doctag">@return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> digit, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">			val *= digit;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * &lt;p&gt;</span><br><span class="line">	 * 桶，用于存放数组</span><br><span class="line">	 * &lt;/p&gt;</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@author</span> Vicky</span><br><span class="line">	 * <span class="doctag">@date</span> 2015-8-21</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bucket</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Node head;</span><br><span class="line">		<span class="keyword">private</span> Node tail;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Bucket</span><span class="params">(Node head, Node tail)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">			<span class="keyword">this</span>.head = head;</span><br><span class="line">			<span class="keyword">this</span>.tail = tail;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Node <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Node <span class="title">getTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> tail;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTail</span><span class="params">(Node tail)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.tail = tail;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * &lt;p&gt;</span><br><span class="line">	 * 节点，用于解决桶中存放多个元素问题</span><br><span class="line">	 * &lt;/p&gt;</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@author</span> Vicky</span><br><span class="line">	 * <span class="doctag">@date</span> 2015-8-21</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">		<span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value, Node next)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">			<span class="keyword">this</span>.value = value;</span><br><span class="line">			<span class="keyword">this</span>.next = next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Node <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Node next)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.next = next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Random ran = <span class="keyword">new</span> Random();</span><br><span class="line">		Integer[] data = <span class="keyword">new</span> Integer[<span class="number">10000000</span>];</span><br><span class="line">		Integer[] data2 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">		Integer[] data3 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">			data[i] = ran.nextInt(<span class="number">100000</span>);</span><br><span class="line">			data2[i] = data[i];</span><br><span class="line">			data3[i] = data[i];</span><br><span class="line">		&#125;</span><br><span class="line">		MergeSort.sort(data);</span><br><span class="line">		QuickSort.sort(data2);</span><br><span class="line">		RadixSort.sort(data3);</span><br><span class="line">		<span class="comment">// SortUtils.printArray(data);</span></span><br><span class="line">		<span class="comment">// SortUtils.printArray(data2);</span></span><br><span class="line">		<span class="comment">// SortUtils.printArray(data3);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="效率分析"><strong>效率分析</strong></h5><p>（1）时间复杂度<br>O(kn)</p>
<blockquote>
<p>基数排序的时间复杂度是 O(k·n)，其中n是排序元素个数，k是数字位数。注意这不是说这个时间复杂度一定优于O(n·log(n))，因为k的大小一般会受到 n 的影响。 以排序n个不同整数来举例，假定这些整数以B为底，这样每位数都有B个不同的数字，k就一定不小于logB(n)。由于有B个不同的数字，所以就需要B个不同的桶，在每一轮比较的时候都需要平均n·log2(B) 次比较来把整数放到合适的桶中去，所以就有：<br>k 大于或等于 logB(n)<br>每一轮(平均)需要 n·log2(B) 次比较<br>所以，基数排序的平均时间T就是：<br>T ≥logB(n)·n·log2(B) = log2(n)·logB(2)·n·log2(B)= log2(n)·n·logB(2)·log2(B) = n·log2(n)<br>所以和比较排序相似，基数排序需要的比较次数：T ≥ n·log2(n)。故其时间复杂度为Ω(n·log2(n)) = Ω(n·log n) 。</p>
</blockquote>
<p>（2）空间复杂度<br>O(radix+n)<br>radix个bucket，以及n个Node。<br>（3）稳定性<br>稳定<br>假设一组元素：12(a),23,12(b),34,15，首先我们按个位分桶得到bucket(1)里面是12(a),12(b)，取出后还是12(a),12(b)所以顺序并没有变化。</p>
<p>基数排序虽然看着感觉效率很高，其实经过测试效率并不如快速排序和归并排序，但是比其他的O(n^2)的排序算法效率肯定是高的。因为基数排序需要操作链接，对于链表的操作肯定不如数组效率高。不过基数排序可以适用于非数值排序，比如字符串。对于一组字符串进行排序，其他的排序算法就无法适用了，但是可以运用基数排序，按字符串个每位字符进行划分入桶，再进行排序即可，不过得先确定有多少个不同字符，要是包含全部字符，那就没法玩了。下面引用一篇文章介绍的基数排序的适用范围吧。</p>
<blockquote>
<p>基数排序从低位到高位进行，使得最后一次计数排序完成后，数组有序。其原理在于对于待排序的数据，整体权重未知的情况下，先按权重小的因子排序，然后按权重大的因子排序。例如比较时间，先按日排序，再按月排序，最后按年排序，仅需排序三次。但是如果先排序高位就没这么简单了。基数排序源于老式穿孔机，排序器每次只能看到一个列，很多教科书上的基数排序都是对数值排序，数值的大小是已知的，与老式穿孔机不同。将数值按位拆分再排序，是无聊并自找麻烦的事。算法的目的是找到最佳解决问题的方案，而不是把简单的事搞的更复杂。基数排序更适合用于对时间、字符串等这些整体权值未知的数据进行排序。这时候基数排序的思想才能体现出来，例如字符串，如果从高位（第一位）往后排就很麻烦。而反过来，先对影响力较小，排序排重因子较小的低位（最后一位）进行排序就非常简单了。这时候基数排序的思想就能体现出来。又或者所有的数值都是以字符串形式存储，就象穿孔机一样，每次只能对一列进行排序。这时候基数排序也适用，例如：对{“193”;”229”;”233”;”215”}进行排序。</p>
</blockquote>
<h5 id="参考文章"><strong>参考文章</strong></h5><p><em><a href="http://blog.csdn.net/xieyuntestshow/article/details/7064641" target="_blank" rel="external"> java基数排序</a></em><br><em><a href="http://developer.51cto.com/art/201104/256449.htm" target="_blank" rel="external">Java排序算法总结（八）：基数排序</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>基数排序不同于其他的七种排序算法，它是基于一种分配法，而非比较。基数排序属于“分配式排序”（distribution sort），基数排序法又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达]]>
    </summary>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="排序" scheme="http://vickyqi.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="排序" scheme="http://vickyqi.com/categories/Java/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[排序算法系列—-归并排序]]></title>
    <link href="http://vickyqi.com/2015/08/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://vickyqi.com/2015/08/20/排序算法系列——归并排序/</id>
    <published>2015-08-20T05:42:00.000Z</published>
    <updated>2015-11-14T11:32:18.000Z</updated>
    <content type="html"><![CDATA[<p>归并排序的核心思想同上一篇介绍的<a href="http://blog.csdn.net/vickyway/article/details/47780477" target="_blank" rel="external">快速排序</a>，都是采用了分治法的思想。其基本思想是将一个待排序序列，划分成两个子序列，然后将这两个子序列排好序之后合并，并递归的将子序列划分为更小的子序列，一直到只有一个元素的子序列，然后自底向上两两合并。<br>由于归并排序的核心就是合并两个数组，所以先看看如何合并两个有序的数组，并保证合并后的数组是有序的。</p>
<h5 id="数组合并"><strong>数组合并</strong></h5><p>首先同时遍历两个数组（A，B），并将两个数组的第一个元素进行对比，假设A的第一个元素较小，则将A[0]复制到合并后的数组中，然后比较A[1]与B[0]，如果B[0]较小，则将B[0]复制到合并后的数组中，然后比较A[1]与B[1]，如果A[1]较小，则将A[1]复制到合并后的数组中，继续比较A[2]与B[0]。如此重复，直至某一个数组全部复制到合并后的数组，然后将另一个数组中剩下的元素按顺序复制到合并后的数组，这样整个合并就完成了。</p>
<h5 id="基本思想"><strong>基本思想</strong></h5><p>归并排序主要采用分治法的思想，将一个问题划分成多个子问题，然后递归解决各个子问题。主要就是将一个待排序序列划分成两个子序列，然后再继续对子序列进行划分，一直划分到只有一个元素为止，然后自下往上两两合并子序列，最终完成排序。</p>
<h5 id="实现要点"><strong>实现要点</strong></h5><p>实现的要点主要就是如何完成合并，上面已经详细介绍了合并的方法，这里也不叙述了。直接看下面的实现代码吧。<br><strong>Java实现</strong></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vicky.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 归并排序</span><br><span class="line"> * </span><br><span class="line"> * 时间复杂度：O(nlgn)</span><br><span class="line"> * </span><br><span class="line"> * 空间复杂度：O(n)</span><br><span class="line"> * </span><br><span class="line"> * 稳定性：稳定</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> Vicky</span><br><span class="line"> * </span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == data) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"data"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (data.length == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Object[] newData = <span class="keyword">new</span> Object[data.length];</span><br><span class="line">		devideSort(newData, data, <span class="number">0</span>, data.length - <span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">"use time:"</span> + (System.nanoTime() - start) / <span class="number">1000000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 分治法排序</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> &lt;T&gt;</span><br><span class="line">	 * <span class="doctag">@param</span> newData</span><br><span class="line">	 * <span class="doctag">@param</span> data</span><br><span class="line">	 * <span class="doctag">@param</span> start</span><br><span class="line">	 * <span class="doctag">@param</span> end</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">devideSort</span><span class="params">(Object[] newData,</span><br><span class="line">			T[] data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (middle &gt; start) &#123;</span><br><span class="line">			devideSort(newData, data, start, middle);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (middle + <span class="number">1</span> &lt; end) &#123;</span><br><span class="line">			devideSort(newData, data, middle + <span class="number">1</span>, end);</span><br><span class="line">		&#125;</span><br><span class="line">		mergeArray(newData, data, start, middle, middle + <span class="number">1</span>, end);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 合并两个数组</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> &lt;T&gt;</span><br><span class="line">	 * <span class="doctag">@param</span> newData</span><br><span class="line">	 *            用于辅助</span><br><span class="line">	 * <span class="doctag">@param</span> data</span><br><span class="line">	 *            被合并的数组</span><br><span class="line">	 * <span class="doctag">@param</span> start1</span><br><span class="line">	 * <span class="doctag">@param</span> end1</span><br><span class="line">	 * <span class="doctag">@param</span> start2</span><br><span class="line">	 * <span class="doctag">@param</span> end2</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">mergeArray</span><span class="params">(Object[] newData,</span><br><span class="line">			T[] data, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = start1, j = start2, index = start1;</span><br><span class="line">		<span class="keyword">while</span> (i &lt;= end1 || j &lt;= end2) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i &gt; end1) &#123;<span class="comment">// 第一个数组已经全部合并到新的数组，则将第二个数组剩下的元素按顺序直接复制到新的数组</span></span><br><span class="line">				newData[index++] = data[j++];</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (j &gt; end2) &#123;<span class="comment">// 第二个数组已经全部合并到新的数组，则将第一个数组剩下的元素按顺序直接复制到新的数组</span></span><br><span class="line">				newData[index++] = data[i++];</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 将两个数组从第一位开始比较，取出较小的复制到新的数组，同时继续将较大的元素与较小的元素所在的数组后续的元素进行对比</span></span><br><span class="line">			<span class="keyword">if</span> (data[i].compareTo(data[j]) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">// 此处i&lt;=j的时候也选择i的原因是为了保证稳定性，因为i在原数组中是在j前面的，</span></span><br><span class="line">				<span class="comment">// 所以即使i==j我们也选择i保证排序后i依旧在j前面</span></span><br><span class="line">				newData[index++] = data[i++];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				newData[index++] = data[j++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将排好序的元素复制回原数组</span></span><br><span class="line">		<span class="keyword">for</span> (i = start1; i &lt;= end2; i++) &#123;</span><br><span class="line">			data[i] = (T) newData[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Random ran = <span class="keyword">new</span> Random();</span><br><span class="line">		Integer[] data = <span class="keyword">new</span> Integer[<span class="number">10000</span>];</span><br><span class="line">		Integer[] data2 = <span class="keyword">new</span> Integer[<span class="number">10000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">			data[i] = ran.nextInt(<span class="number">1000000</span>);</span><br><span class="line">			data2[i] = data[i];</span><br><span class="line">		&#125;</span><br><span class="line">		MergeSort.sort(data);</span><br><span class="line">		QuickSort.sort(data2);</span><br><span class="line">		SortUtils.printArray(data);</span><br><span class="line">		SortUtils.printArray(data2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="效率分析"><strong>效率分析</strong></h5><p>（1）时间复杂度<br>O(nlgn)<br>对长度为n的文件，需进行lgn 趟二路归并，每趟归并的时间为O(n)，故其时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlgn)。<br>（2）空间复杂度<br>O(n)<br>合并的时候需要O(n)长度的辅助数组进行合并，所以归并排序的空间复杂度是O(n)。<br>（3）稳定性<br>稳定<br>排序中有可能发生两个相同元素交换的地方就是在合并的时候，所以我们可以在合并的时候认为的控制其稳定性，具体方式在上面代码的mergeArray()中有注释。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>归并排序的核心思想同上一篇介绍的<a href="http://blog.csdn.net/vickyway/article/details/47780477" target="_blank" rel="external">快速排序</a>，都是采用了分治法的思想。其基本思]]>
    </summary>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="排序" scheme="http://vickyqi.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="排序" scheme="http://vickyqi.com/categories/Java/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[排序算法系列——快速排序]]></title>
    <link href="http://vickyqi.com/2015/08/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://vickyqi.com/2015/08/19/排序算法系列——快速排序/</id>
    <published>2015-08-19T09:35:00.000Z</published>
    <updated>2015-11-14T11:31:36.000Z</updated>
    <content type="html"><![CDATA[<p>快速排序同冒泡排序，是交换排序的一种。快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。快速排序的时间复杂度是O(nlogn)，比其他O(n^2)的排序算法快很多，不过实现起来还是有一定难度的。<br>分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。</p>
<h5 id="基本思想"><strong>基本思想</strong></h5><p>快速排序使用分治法思想，从待排序序列中取出某个元素作为基准，以此基准将待排序序列划分成左右两个子序列，并使基准左边的元素都小于基准元素，右边的元素都大于等于基准元素，这样基准元素的位置就是正确的了，然后通过递归对每个子序列都做同样的操作，即可完成排序。</p>
<h5 id="实现要点"><strong>实现要点</strong></h5><p>实现的难点是在选定一个基准之后如何将其余元素按大小分别移动到基准的两侧。下面介绍一种空间复杂度为O(1)的方法：<br>下面以一组待排序元素(data)为例，简单描述下将序列以基准划分为两部分的过程<br>|0|1|2|3|4|5|6|7|8|9|<br>|-|-|-|-|-|-|-|-|-|-|<br>|72|38|54|87|96|17|57|84|25|91|<br>首先我们取data[0]作为基准，用一个变量temp保存data[0]，然后将所有小于temp的元素移动到序列头部，大于等于temp的元素移动到序列尾部，用i=0,j=n-1分别记录序列头部以及尾部，然后从j开始遍历，data[j]&gt;=temp不做任何交换，同时j–，继续比较下一个，如果data[j]小于temp，则将data[j]与data[i]交换，然后i++，并比较data[i]与temp，data[i]小于temp，则不做任何交换，同时i++，继续比较下一个，如果data[i]&gt;=temp，则将data[i]与data[j]交换，j–，再比较data[i]与temp。从描述可以发现，首先我们从尾部开始，如果发生交换则切换到头部，再发生交换再切回来，如此交换进行，直至i=j，最终i的位置就是我们一开始选择的基准元素的位置。这样一次排序就完成了，接着递归排序子序列，这里需要判断如果最终的基准位置左边没有子序列则无需递归排序左子序列，同样的如果基准位置右边没有子序列则无需递归排序右子序列。<br><strong>Java实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">package com.vicky.sort;</span><br><span class="line"></span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 交换排序：快速排序</span><br><span class="line"> * </span><br><span class="line"> * 时间复杂度：O(nlogn)</span><br><span class="line"> * </span><br><span class="line"> * @author Vicky</span><br><span class="line"> * </span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> QuickSort &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">		<span class="keyword">if</span> (null == data) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"data"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (data.length == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		devideSort(data, <span class="number">0</span>, data.length - <span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">"use time:"</span> + (System.nanoTime() - start) / <span class="number">1000000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">devideSort</span><span class="params">(T[] data,</span><br><span class="line">			<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = start;</span><br><span class="line">		<span class="keyword">int</span> j = end;</span><br><span class="line">		T temp = data[start];</span><br><span class="line">		boolean direct = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (direct) &#123;</span><br><span class="line">				<span class="keyword">if</span> (data[i].compareTo(temp) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">					SortUtils.swap(data, i, j);</span><br><span class="line">					j--;</span><br><span class="line">					direct = <span class="literal">false</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					i++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (data[j].compareTo(temp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					SortUtils.swap(data, i, j);</span><br><span class="line">					i++;</span><br><span class="line">					direct = <span class="literal">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					j--;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (start &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">			devideSort(data, start, i - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i + <span class="number">1</span> &lt; end) &#123;</span><br><span class="line">			devideSort(data, i + <span class="number">1</span>, end);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Random ran = <span class="keyword">new</span> Random();</span><br><span class="line">		Integer[] data = <span class="keyword">new</span> Integer[<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">			data[i] = ran.nextInt(<span class="number">10000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		QuickSort.sort(data);</span><br><span class="line">		SortUtils.printArray(data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="效率分析"><strong>效率分析</strong></h5><p>（1）时间复杂度<br>O(nlogn)</p>
<blockquote>
<p>（1）最坏时间复杂度<br>最坏情况是每次划分选取的基准都是当前无序区中关键字最小(或最大)的记录，划分的结果是基准左边的子区间为空(或右边的子区间为空)，而划分所得的另一个非空的子区间中记录数目，仅仅比划分前的无序区中记录个数减少一个。因此，快速排序必须做n-1次划分，第i次划分开始时区间长度为n-i+1，所需的比较次数为n-i(1≤i≤n-1)，故总的比较次数达到最大值：<strong>Cmax = n(n-1)/2=O(n2)</strong>。如果按上面给出的划分算法，每次取当前无序区的第1个记录为基准，那么当文件的记录已按递增序(或递减序)排列时，每次划分所取的基准就是当前无序区中关键字最小(或最大)的记录，则快速排序所需的比较次数反而最多。<br>（2）最好时间复杂度<br>在最好情况下，每次划分所取的基准都是当前无序区的”中值”记录，划分的结果是基准的左、右两个无序子区间的长度大致相等。总的关键字比较次数：0(nlgn)。<br>注意：用递归树来分析最好情况下的比较次数更简单。因为每次划分后左、右子区间长度大致相等，故递归树的高度为O(lgn)，而递归树每一层上各结点所对应的划分过程中所需要的关键字比较次数总和不超过n，故整个排序过程所需要的关键字比较总次数C(n)=O(nlgn)。因为快速排序的记录移动次数不大于比较的次数，所以快速排序的最坏时间复杂度应为0(n2)，最好时间复杂度为O(nlgn)。<br>（3）基准关键字的选取<br>在当前无序区中选取划分的基准关键字是决定算法性能的关键。<br>①”三者取中”的规则<br>“三者取中”规则，即在当前区间里，将该区间首、尾和中间位置上的关键字比较，取三者之中值所对应的记录作为基准，在划分开始前将该基准记录和该区伺的第1个记录进行交换，此后的划分过程与上面所给的Partition算法完全相同。<br>②取位于low和high之间的随机数k(low≤k≤high)，用R[k]作为基准<br>选取基准最好的方法是用一个随机函数产生一个取位于low和high之间的随机数k(low≤k≤high)，用R[k]作为基准，这相当于强迫R[low..high]中的记录是随机分布的。用此方法所得到的快速排序一般称为随机的快速排序。<br>注意：随机化的快速排序与一般的快速排序算法差别很小。但随机化后，算法的性能大大地提高了，尤其是对初始有序的文件，一般不可能导致最坏情况的发生。算法的随机化不仅仅适用于快速排序，也适用于其它需要数据随机分布的算法。<br>（4）平均时间复杂度<br>尽管快速排序的最坏时间为O(n2)，但就平均性能而言，它是基于关键字比较的内部排序算法中速度最快者，快速排序亦因此而得名。它的平均时间复杂度为O(nlgn)。</p>
</blockquote>
<p>（2）空间复杂度<br>O(lgn)<br>快速排序在系统内部需要一个栈来实现递归。若每次划分较为均匀，则其递归树的高度为O(lgn)，故递归后需栈空间为O(lgn)。最坏情况下，递归树的高度为O(n)，所需的栈空间为O(n)。<br>（3）稳定性<br>不稳定<br>快速排序的稳定性要跟其如何选择基准以及如果进行交换有关。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>快速排序同冒泡排序，是交换排序的一种。快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。快速排序的时间复杂度是O(nlogn)，比其他O(n^2)的排序算法快很多]]>
    </summary>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="排序" scheme="http://vickyqi.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="排序" scheme="http://vickyqi.com/categories/Java/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[排序算法系列——冒泡排序]]></title>
    <link href="http://vickyqi.com/2015/08/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://vickyqi.com/2015/08/18/排序算法系列——冒泡排序/</id>
    <published>2015-08-18T03:31:00.000Z</published>
    <updated>2015-11-14T11:31:42.000Z</updated>
    <content type="html"><![CDATA[<p>冒泡排序是交换排序的一种，其思想是从序列头部开始逐步往后遍历，每次遍历比较相邻两个元素，如果顺序不对则交换，n-1次遍历之后序列就完成了排序。由于每次遍历都是把最大的元素一步步让最后移动，类似于水泡慢慢浮出水面，于是得名冒泡算法。冒泡算法的思想很简单，实现起来也很容易，但是效率太低，所以即使是小数据量也很少推荐使用冒泡算法，更多的使用直接插入排序。</p>
<h5 id="基本思想"><strong>基本思想</strong></h5><p>从待排序序列头部开始循环遍历n-1次，每次遍历比较相邻两个元素，如果顺序不对则交换，也就是说如果你想要从小到大排列，那么如果相邻两个元素比较结果是前面的大于后面的，则交换就可以了，那么通过一次遍历最大的元素就到达了序列的尾部，n-1次遍历之后序列就完成了排序。这里显然有可优化的空间，下面会提到。</p>
<h5 id="实现要点"><strong>实现要点</strong></h5><p>第i次(i=0…n-1)遍历从0开始比较到n-1-i(n序列长度)，因为每次遍历都会将未排序部分最大的元素移动到序列尾部，所以序列尾部是有序的，故在之后的遍历过程中无需继续比较有序的部分。<br><strong>算法改进</strong><br>该算法有两处可优化的地方：</p>
<ul>
<li>如果一次遍历过程中未发生任何交换，即所有相邻元素的顺序都是正确的，则说明整个序列已经完成排序，故无需继续遍历。</li>
<li>每次遍历过程中记录下最后一次发生遍历的位置，则在改位置之后的部分已经是有序的，下次遍历时就可以提前结束。</li>
</ul>
<p>实验表明以上两种改进之后的效率并未有太大的提高，第一种改进效率反而比为改进的低，第二种改进效率稍微提高一点点。虽然这两种改进从理论上来看是有一定的优化的，但是测试时使用的序列一般都是随机的，即在n-1次遍历之前完成排序以及部分有序的可能性都很小，所以这两种改进的效果都不是很明显，可能根本不会发生，反而由于加入了一些逻辑判断反而导致效率降低。不过如果是真是数据，那么之前提到的两种情况还是很可能发生的。</p>
<p><strong>Java实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">package com.vicky.sort;</span><br><span class="line"></span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 交换排序：冒泡排序</span><br><span class="line"> * </span><br><span class="line"> * 时间复杂度：O(n^2)</span><br><span class="line"> * </span><br><span class="line"> * 空间复杂度：O(1)</span><br><span class="line"> * </span><br><span class="line"> * 稳定性：稳定</span><br><span class="line"> * </span><br><span class="line"> * @author Vicky</span><br><span class="line"> * </span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> BubbleSort &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 未改进的冒泡排序</span><br><span class="line">	 * </span><br><span class="line">	 * @param &lt;T&gt;</span><br><span class="line">	 * @param data</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">		<span class="keyword">if</span> (null == data) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"data"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (data.length == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// n-1趟遍历</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="comment">// 每次遍历从0开始依次比较相邻元素</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">				<span class="comment">// 前面元素&gt;后面元素则交换</span></span><br><span class="line">				<span class="keyword">if</span> (data[j].compareTo(data[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					T temp = data[j];</span><br><span class="line">					data[j] = data[j + <span class="number">1</span>];</span><br><span class="line">					data[j + <span class="number">1</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"sort, use time:"</span> + (System.nanoTime() - start)</span><br><span class="line">				/ <span class="number">1000000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 改进后冒泡排序</span><br><span class="line">	 * </span><br><span class="line">	 * 改进原理：如果一次遍历过程未发生交换，则说明序列已经是有序的，故无需再进行遍历。</span><br><span class="line">	 * </span><br><span class="line">	 * @param &lt;T&gt;</span><br><span class="line">	 * @param data</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sortImprove</span><span class="params">(T[] data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">		<span class="keyword">if</span> (null == data) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"data"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (data.length == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		boolean exchange = <span class="literal">false</span>;<span class="comment">// 记录一趟遍历是否发生交换</span></span><br><span class="line">		<span class="comment">// n-1趟遍历</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="comment">// 每次遍历从0开始依次比较相邻元素</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">				<span class="comment">// 前面元素&gt;后面元素则交换</span></span><br><span class="line">				<span class="keyword">if</span> (data[j].compareTo(data[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					T temp = data[j];</span><br><span class="line">					data[j] = data[j + <span class="number">1</span>];</span><br><span class="line">					data[j + <span class="number">1</span>] = temp;</span><br><span class="line">					exchange = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果本次遍历未发生交换，则说明序列已是有序的，则无需继续遍历</span></span><br><span class="line">			<span class="keyword">if</span> (!exchange) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"sortImprove1, use time:"</span></span><br><span class="line">				+ (System.nanoTime() - start) / <span class="number">1000000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 改进后冒泡排序</span><br><span class="line">	 * </span><br><span class="line">	 * 改进原理：在冒泡排序的每趟扫描中，记住最后一次交换发生的位置lastexchange也能有所帮助。因为该位置之后的部分已经是有序的(未发生交换，</span><br><span class="line">	 * 所以是有序)，</span><br><span class="line">	 * 故下一趟排序开始的时候，只需处理0到lastexchange部分，lastexchange到n-1是有序区。同时如果未发生交换则退出即可</span><br><span class="line">	 * </span><br><span class="line">	 * @param &lt;T&gt;</span><br><span class="line">	 * @param data</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sortImprove2</span><span class="params">(T[] data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">		<span class="keyword">if</span> (null == data) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"data"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (data.length == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> lastChange = data.length - <span class="number">1</span>;<span class="comment">// 记录一趟遍历最后一次发生交换的位置，该位置之后是有序的</span></span><br><span class="line">		<span class="comment">// 上次遍历发生交换则lastChange&gt;0，继续遍历</span></span><br><span class="line">		<span class="keyword">while</span> (lastChange &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 本次遍历从0开始到上次遍历最后一次交换的位置结束</span></span><br><span class="line">			<span class="keyword">int</span> end = lastChange;</span><br><span class="line">			lastChange = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 每次遍历从0开始依次比较相邻元素</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; end; j++) &#123;</span><br><span class="line">				<span class="comment">// 前面元素&gt;后面元素则交换</span></span><br><span class="line">				<span class="keyword">if</span> (data[j].compareTo(data[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					T temp = data[j];</span><br><span class="line">					data[j] = data[j + <span class="number">1</span>];</span><br><span class="line">					data[j + <span class="number">1</span>] = temp;</span><br><span class="line">					lastChange = j + <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"sortImprove2, use time:"</span></span><br><span class="line">				+ (System.nanoTime() - start) / <span class="number">1000000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 用于记录三种冒泡排序的用时</span></span><br><span class="line">		<span class="keyword">long</span>[] useTime1 = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">long</span>[] useTime2 = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">long</span>[] useTime3 = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="comment">// 循环测试10次，取均值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> times = <span class="number">0</span>; times &lt; <span class="number">10</span>; times++) &#123;</span><br><span class="line">			<span class="comment">// 构建10000个元素的序列进行排序</span></span><br><span class="line">			Random ran = <span class="keyword">new</span> Random();</span><br><span class="line">			Integer[] data = <span class="keyword">new</span> Integer[<span class="number">10000</span>];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">				data[i] = ran.nextInt(<span class="number">10000000</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 使用System.arraycopy复制三个数组分别用于排序</span></span><br><span class="line">			Integer[] data1 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">			Integer[] data2 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">			Integer[] data3 = <span class="keyword">new</span> Integer[data.length];</span><br><span class="line">			System.arraycopy(data, <span class="number">0</span>, data1, <span class="number">0</span>, data.length);</span><br><span class="line">			System.arraycopy(data, <span class="number">0</span>, data2, <span class="number">0</span>, data.length);</span><br><span class="line">			System.arraycopy(data, <span class="number">0</span>, data3, <span class="number">0</span>, data.length);</span><br><span class="line">			<span class="comment">// 分别记录三种冒泡排序的用时</span></span><br><span class="line">			<span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">			BubbleSort.sort(data1);</span><br><span class="line">			useTime1[times] = (System.nanoTime() - start) / <span class="number">1000000</span>;</span><br><span class="line">			<span class="comment">// SortUtils.printArray(data1);</span></span><br><span class="line">			start = System.nanoTime();</span><br><span class="line">			BubbleSort.sortImprove(data2);</span><br><span class="line">			useTime2[times] = (System.nanoTime() - start) / <span class="number">1000000</span>;</span><br><span class="line">			start = System.nanoTime();</span><br><span class="line">			<span class="comment">// SortUtils.printArray(data2);</span></span><br><span class="line">			BubbleSort.sortImprove2(data3);</span><br><span class="line">			useTime3[times] = (System.nanoTime() - start) / <span class="number">1000000</span>;</span><br><span class="line">			<span class="comment">// SortUtils.printArray(data3);</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 计算用时最大值，最小值，均值</span></span><br><span class="line">		<span class="keyword">long</span>[] res1 = SortUtils.countArray(useTime1);</span><br><span class="line">		<span class="keyword">long</span>[] res2 = SortUtils.countArray(useTime2);</span><br><span class="line">		<span class="keyword">long</span>[] res3 = SortUtils.countArray(useTime3);</span><br><span class="line">		System.out.println(<span class="string">"method\tmax\tmin\tavg\t"</span>);</span><br><span class="line">		System.out.println(<span class="string">"sort"</span> + <span class="string">"\t"</span> + res1[<span class="number">0</span>] + <span class="string">"\t"</span> + res1[<span class="number">1</span>] + <span class="string">"\t"</span></span><br><span class="line">				+ res1[<span class="number">2</span>]);</span><br><span class="line">		System.out.println(<span class="string">"sortImprove"</span> + <span class="string">"\t"</span> + res2[<span class="number">0</span>] + <span class="string">"\t"</span> + res2[<span class="number">1</span>]</span><br><span class="line">				+ <span class="string">"\t"</span> + res2[<span class="number">2</span>]);</span><br><span class="line">		System.out.println(<span class="string">"sortImprove2"</span> + <span class="string">"\t"</span> + res3[<span class="number">0</span>] + <span class="string">"\t"</span> + res3[<span class="number">1</span>]</span><br><span class="line">				+ <span class="string">"\t"</span> + res3[<span class="number">2</span>]);</span><br><span class="line">		<span class="comment">// 测试结果，第一种改进方法效率比不改进还差一些，</span></span><br><span class="line">		<span class="comment">// 可能由于出现提前完成排序的可能性较小，每次遍历加入了过多的赋值以及判断操作导致效率反而降低</span></span><br><span class="line">		<span class="comment">// 第二种改进方法还是有一些效果的</span></span><br><span class="line">		<span class="comment">// method max min avg</span></span><br><span class="line">		<span class="comment">// sort 1190 1073 1123</span></span><br><span class="line">		<span class="comment">// sortImprove 1258 1097 1146</span></span><br><span class="line">		<span class="comment">// sortImprove2 1205 1056 1099</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="效率分析"><strong>效率分析</strong></h5><p>（1）时间复杂度<br>O(n^2)<br>冒泡排序最好的时间复杂度是O(n)，一次遍历即可，无需交换（第一种改进）。最坏情况需要遍历n-1次，比较且交换n-1-i次，故时间复杂度是O(n^2)。<br>（2）空间复杂度<br>O(1)<br>从空间来看，它只需要一个元素的辅助空间，用于元素的位置交换O(1)。<br>（3）稳定性<br>稳定<br>排序过程中只有相邻两个元素会发生交换，同时为了减少交换次数相同的元素不会进行交换，所以两个相同元素的相对位置不会发生改变。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>冒泡排序是交换排序的一种，其思想是从序列头部开始逐步往后遍历，每次遍历比较相邻两个元素，如果顺序不对则交换，n-1次遍历之后序列就完成了排序。由于每次遍历都是把最大的元素一步步让最后移动，类似于水泡慢慢浮出水面，于是得名冒泡算法。冒泡算法的思想很简单，实现起来也很容易，但是]]>
    </summary>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="排序" scheme="http://vickyqi.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="排序" scheme="http://vickyqi.com/categories/Java/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[排序算法系列——堆排序]]></title>
    <link href="http://vickyqi.com/2015/08/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://vickyqi.com/2015/08/14/排序算法系列——堆排序/</id>
    <published>2015-08-14T10:39:00.000Z</published>
    <updated>2015-11-14T11:31:06.000Z</updated>
    <content type="html"><![CDATA[<p>堆排序同直接选择排序一样是选择排序的一种。堆排序是借助一种数据结构——堆来完成排序，堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<h5 id="什么是堆"><strong>什么是堆</strong></h5><p>关于二叉树这里就不叙述了。堆（二叉堆）可以视为一棵完全的二叉树，完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。<br><img src="http://img.blog.csdn.net/20150814174525425" alt="对和数组的关系"><br>从上面可以看出，如果对一个堆从上往下，从左往右进行遍历的话，正好和数组的顺序是一致的。所以对于给定一个节点（下标i）我们可以很容易计算出其子节点以及父节点的下标：</p>
<ul>
<li>Parent(i) = floor(i/2)，i 的父节点下标</li>
<li>Left(i) = 2i，i 的左子节点下标</li>
<li>Right(i) = 2i + 1，i 的右子节点下标</li>
</ul>
<p>同时堆还有最大堆和最小堆之分。<br>最大堆：</p>
<ul>
<li>堆的根节点是最大值</li>
<li>堆中每个节点都大于其子节点，小于其父节点</li>
</ul>
<p>最小堆：</p>
<ul>
<li>堆的根节点是最小值</li>
<li>堆中每个节点都小于其子节点，大于其父节点</li>
</ul>
<h5 id="基本思想"><strong>基本思想</strong></h5><p>堆排序就是利用堆这种特殊的数据结构来进行排序，比如我们选择最大堆来进行排序，则我们只需要将待排序的元素构建成一个堆即可，因为堆中的第一个元素是最大值，所以将堆的第一个元素取出，之后再将剩余的元素构建成一个新堆，再取出第一个元素，当所有的元素都被取出之后，整个序列就完成了排序。从描述可以看出，这里是利用堆来从无序部分中获取最大值，所以堆排序同直接选择排序的基本思想一样，都是从无序部分取出一个最大或者最小值放入有序部分，两者的不同之处在于直接选择排序是通过对无序部分进行遍历比较来获取最大值或者最小值，而堆排序是利用堆这种特殊的数据结构。</p>
<h5 id="实现要点"><strong>实现要点</strong></h5><p>如果想要对一组数据使用堆排序，首先要做的就是将这组数据构建成一个堆，然后取出堆中的根节点。这里我们选择最大值，即根节点是最大值，为了减少排序的空间复杂度，我们将选出的元素直接与原数组的最后一位进行交换，这样数组的最后一位就是正确的了，然后我们对剩余元素重新调整成堆结构，重复此过程直到只剩下一个元素。<br>这里主要就是两个操作过程，一个是建堆，一个是调整堆。<br>在构建堆的时候一般选择最后一个元素的父节点作为起始点进行递归构建堆。建堆是一个递归的过程，即先构建最下层的小堆，然后逐步往外层构建，最终形成一个完整的堆，因为当一个节点大于其子节点，那么如果其父节点大于这个节点，则它的父节点比大于其孙子节点，所以整个堆都是满足条件的。<br>在调整堆的时候，由于调整堆是因为我们拿走了一个元素，所以在调整堆时需要注意整个堆的大小，这个大小会随着迭代的次数而逐步减小，最终为1。不同于建构堆，调整堆的时候由于我们将根节点与最后一个节点进行交换，所以我们从上而下进行调整，即将这个交换到根节点的元素逐步沉到其合理的位置。<br><strong>Java实现</strong></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vicky.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 选择排序：堆排序</span><br><span class="line"> * </span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> Vicky</span><br><span class="line"> * <span class="doctag">@date</span> 2015-8-13</span><br><span class="line"> * <span class="doctag">@param</span> &lt;T&gt;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 排序</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> data</span><br><span class="line">	 *            待排序的数组</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == data) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"data"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (data.length == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		buildMaxHeap(data);</span><br><span class="line">		<span class="comment">// 末尾与头交换，交换后调整最大堆</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = data.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">			T temp = data[<span class="number">0</span>];</span><br><span class="line">			data[<span class="number">0</span>] = data[i];</span><br><span class="line">			data[i] = temp;</span><br><span class="line">			adjustMaxHeap(data, i, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"use time:"</span> + (System.nanoTime() - start) / <span class="number">1000000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 构建最大堆</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> &lt;T&gt;</span><br><span class="line">	 * <span class="doctag">@param</span> data</span><br><span class="line">	 * <span class="doctag">@param</span> index</span><br><span class="line">	 *            序列起始点</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(T[] data)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 自下而上构建最大堆，即从最后一个元素的父节点开始构建最大堆</span></span><br><span class="line">		<span class="keyword">int</span> start = getParentIndex(data.length - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (; start &gt;= <span class="number">0</span>; start--) &#123;</span><br><span class="line">			adjustMaxHeap(data, data.length, start);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 调整最大堆，自下而上</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> &lt;T&gt;</span><br><span class="line">	 * <span class="doctag">@param</span> data</span><br><span class="line">	 * <span class="doctag">@param</span> heapsize</span><br><span class="line">	 *            堆的大小，即对data中从0开始到heapsize之间的元素构建最大堆</span><br><span class="line">	 * <span class="doctag">@param</span> index</span><br><span class="line">	 *            当前需要构建最大堆的位置</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">adjustMaxHeap</span><span class="params">(T[] data, <span class="keyword">int</span> heapsize, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取该元素左右子元素</span></span><br><span class="line">		<span class="keyword">int</span> left = getLeftChildIndex(index);</span><br><span class="line">		<span class="keyword">int</span> right = getRightChildIndex(index);</span><br><span class="line">		<span class="keyword">int</span> max = index;</span><br><span class="line">		<span class="comment">// 取三个元素中最大值与父节点进行交换</span></span><br><span class="line">		<span class="keyword">if</span> (left &lt; heapsize &amp;&amp; data[max].compareTo(data[left]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			max = left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (right &lt; heapsize &amp;&amp; data[max].compareTo(data[right]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			max = right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (max != index) &#123;</span><br><span class="line">			swap(data, index, max);</span><br><span class="line">			adjustMaxHeap(data, heapsize, max);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 交换元素</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> &lt;T&gt;</span><br><span class="line">	 * <span class="doctag">@param</span> data</span><br><span class="line">	 * <span class="doctag">@param</span> i</span><br><span class="line">	 * <span class="doctag">@param</span> j</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T[] data, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		T temp = data[i];</span><br><span class="line">		data[i] = data[j];</span><br><span class="line">		data[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 获取父节点位置</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> i</span><br><span class="line">	 * <span class="doctag">@return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">getParentIndex</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (i - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 获取左子节点位置</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> current</span><br><span class="line">	 * <span class="doctag">@return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">getLeftChildIndex</span><span class="params">(<span class="keyword">int</span> current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (current &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 获取右子节点位置</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> current</span><br><span class="line">	 * <span class="doctag">@return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">getRightChildIndex</span><span class="params">(<span class="keyword">int</span> current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (current &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Random ran = <span class="keyword">new</span> Random();</span><br><span class="line">		Integer[] data = <span class="keyword">new</span> Integer[<span class="number">100000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">			data[i] = ran.nextInt(<span class="number">100000000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		HeapSort.sort(data);</span><br><span class="line">		System.out.println(Arrays.toString(data));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="效率分析"><strong>效率分析</strong></h5><p>（1）时间复杂度<br>O(nlogn)<br>（2）空间复杂度<br>O(1)<br>-从空间来看，它只需要一个元素的辅助空间，用于元素的位置交换O(1)。<br>（3）稳定性<br>不稳定。<br>考虑序列{5A,7,13,5B}，首先我们构建成一个堆，得到的堆是：{13,7,5A,5B}，现在我们取出根节点，然后跟最后一个元素进行交换，再重新调整堆，得到的堆是：{7,5B,5A}，再取走根节点，剩余的堆是：{5A,5B}，所以最终得到的排序结果是5B,5A,7,13。显示堆排序是不稳定的。</p>
<h5 id="参考文章"><strong>参考文章</strong></h5><p><a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="external">常见排序算法 - 堆排序 (Heap Sort)</a><br><a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F" target="_blank" rel="external">堆排序</a><br><a href="http://sjjp.tjuci.edu.cn/sjjg/DataStructure/DS/web/paixu/paixu8.4.2.3.htm" target="_blank" rel="external">堆排序</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>堆排序同直接选择排序一样是选择排序的一种。堆排序是借助一种数据结构——堆来完成排序，堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<h5 id="什么是堆"><strong>什么是堆</strong></h]]>
    </summary>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="排序" scheme="http://vickyqi.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="排序" scheme="http://vickyqi.com/categories/Java/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[排序算法系列——直接选择排序]]></title>
    <link href="http://vickyqi.com/2015/08/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://vickyqi.com/2015/08/13/排序算法系列——直接选择排序/</id>
    <published>2015-08-13T12:08:00.000Z</published>
    <updated>2015-11-14T11:32:14.000Z</updated>
    <content type="html"><![CDATA[<p>前面两篇介绍了两种插入排序算法：直接插入排序和希尔排序。这篇介绍选择排序的一种：直接选择排序。从名字就可以看出直接选择排序与直接插入排序很相似，两者相同点在与都是将待排序序列分成有序区和无序区两部分，不同之处在于直接插入排序是从无序区选出一个插入到有序区合适的位置，而直接选择排序是从无序区选出最小的一个插入到有序区尾部，使得有序区保持有序。</p>
<h5 id="基本思想"><strong>基本思想</strong></h5><p>一组待排序的数据，首先将其划分成两部分，一部分是已排好序的，另一部分是待排序的，然后依次从待排序部分取出最小的元素插入到已排序部分的尾部，保证有序始终是已排好序的，等待排序部分全部取出放入已排序部分之后整个排序过程就完成了。 此处与直接插入排序不同之处在于，在从无序部分选择一个元素插入到有序部分时，是挑选无序部分中最小的元素，所以在挑选时需要同无序部分的每个元素进行对比，找到最小的元素。</p>
<h5 id="实现要点"><strong>实现要点</strong></h5><p>将待排序序列看做为无序部分（有序部分长度为0）。然后从待排序部分使用遍历比较得到最小值的位置，将其与无序部分的第一个元素进行交换（第一轮与data[0]进行交换），重复该过程直到无序部分只剩下一个元素，即完成了排序。<br><strong>Java实现</strong><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vicky.<span class="built_in">sort</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 选择排序：直接选择排序</span><br><span class="line"> * </span><br><span class="line"> * 基本思想：</span><br><span class="line"> * 直接选择排序同直接插入排序，也是将整个序列分为有序区和无序区，所不同的是直接播放排序是将无序区的第一个元素直接插入到有序区以形成一个更大的有序区</span><br><span class="line"> * ，而直接选择排序是从无序区选一个最小的元素直接放到有序区的最后。</span><br><span class="line"> * </span><br><span class="line"> * 时间复杂度：O(n^2)</span><br><span class="line"> * </span><br><span class="line"> * 空间复杂度：θ(1)</span><br><span class="line"> * </span><br><span class="line"> * 稳定性：不稳定</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> * </span><br><span class="line"> * @author Vicky</span><br><span class="line"> * @date 2015-8-13</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> class StraightSelectionSort &#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 排序</span><br><span class="line">	 * </span><br><span class="line">	 * @param data</span><br><span class="line">	 *            待排序的数组</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="keyword">void</span> <span class="built_in">sort</span>(T[] data) &#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == data) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"data"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (data.length == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> st = <span class="number">0</span>; st &lt; data.length - <span class="number">1</span>; st++) &#123;</span><br><span class="line">			<span class="built_in">int</span> j = st + <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">int</span> <span class="built_in">min</span> = st;</span><br><span class="line">			<span class="comment">// 找到最小元素的位置</span></span><br><span class="line">			<span class="keyword">for</span> (; j &lt; data.length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (data[j].compareTo(data[<span class="built_in">min</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="built_in">min</span> = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 将最小元素放到有序区尾部</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">min</span> != st) &#123;<span class="comment">// 避免跟自身交换</span></span><br><span class="line">				T temp = data[st];</span><br><span class="line">				data[st] = data[<span class="built_in">min</span>];</span><br><span class="line">				data[<span class="built_in">min</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"use time:"</span> + (System.nanoTime() - start) / <span class="number">1000000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">		Random ran = <span class="keyword">new</span> Random();</span><br><span class="line">		Integer[] data = <span class="keyword">new</span> Integer[<span class="number">100000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">			data[i] = ran.nextInt(<span class="number">10000000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		StraightSelectionSort.<span class="built_in">sort</span>(data);</span><br><span class="line">		System.out.<span class="built_in">println</span>(Arrays.toString(data));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="效率分析"><strong>效率分析</strong></h5><p>（1）时间复杂度<br>O(n^2)<br>选择排序的交换操作介于0和(n-1)次之间。选择排序的比较操作为n(n-1)/2次之间。选择排序的赋值操作介于0和3(n-1)次之间。比较次数O(n^2)，比较次数与关键字的初始状态无关，总的比较次数N=(n-1)+(n-2)+…+1=n\times(n-1)/2。交换次数O(n)，最好情况是，已经有序，交换0次；最坏情况是，逆序，交换n-1次。所以直接选择排序的时间复杂度是O(n^2)。<br>（2）空间复杂度<br>O(1)<br>-从空间来看，它只需要一个元素的辅助空间，用于元素的位置交换O(1)。<br>（3）稳定性<br>不稳定。<br>-我们假设一个序列{1,3,5,10A,10B,7}，看这个数列，假设前面三个是有序区，后面三个是无序区，则无序区中最小的元素是7，和无序区的首元素交换10A交换，则可以看到序列变成了{1,3,5,7,10B,10A}，然后继续，无序区就剩下{10B,10A}，我们又可以看到，这里又是一个等号问题，同样，前面的交换是必然的，而后面的交换（如果等于也要交换）则不是必然的，为了减少元素交换，直接选择排序是不稳定的。<br><strong>参考文章</strong><br><a href="https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" target="_blank" rel="external">选择排序-维基百科</a><br><a href="http://www.cnblogs.com/lqminn/p/3642027.html" target="_blank" rel="external">排序算法的稳定性</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面两篇介绍了两种插入排序算法：直接插入排序和希尔排序。这篇介绍选择排序的一种：直接选择排序。从名字就可以看出直接选择排序与直接插入排序很相似，两者相同点在与都是将待排序序列分成有序区和无序区两部分，不同之处在于直接插入排序是从无序区选出一个插入到有序区合适的位置，而直接选]]>
    </summary>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="排序" scheme="http://vickyqi.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="排序" scheme="http://vickyqi.com/categories/Java/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[排序算法系列——希尔排序]]></title>
    <link href="http://vickyqi.com/2015/08/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://vickyqi.com/2015/08/13/排序算法系列——希尔排序/</id>
    <published>2015-08-13T02:55:00.000Z</published>
    <updated>2015-11-14T11:35:26.000Z</updated>
    <content type="html"><![CDATA[<p>希尔排序同之前介绍的直接插入排序一起属于插入排序的一种。希尔排序算法是按其设计者希尔（Donald Shell）的名字命名，该算法由1959年公布，是插入排序的一种更高效的改进版本。它的作法不是每次一个元素挨一个元素的比较。而是初期选用大跨步（增量较大）间隔比较，使记录跳跃式接近它的排序位置；然后增量缩小；最后增量为 1 ，这样记录移动次数大大减少，提高了排序效率。希尔排序对增量序列的选择没有严格规定。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ul>
<h5 id="基本思想"><strong>基本思想</strong></h5><p>先将整个待排序序列按固定步长(增量)划分成多个子序列，对每个子序列使用直接插入排序进行排序，然后依次缩减步长(增量)再进行排序，直至步长(增量)为1时，即对全部序列进行一次直接插入排序，保证整个序列被排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。</p>
<p><strong>实例分析</strong><br>（<a href="http://bubkoo.com/2014/01/15/sort-algorithm/shell-sort/" target="_blank" rel="external">摘自一篇博客</a>）<br>假设有数组 array = [80, 93, 60, 12, 42, 30, 68, 85, 10]，首先取 d1 = 4，将数组分为 4 组，如下图中相同颜色代表一组：<br><img src="http://img.blog.csdn.net/20150813104959684" alt="这里写图片描述"><br>然后分别对 4 个小组进行插入排序，排序后的结果为：<br><img src="http://img.blog.csdn.net/20150813105024016" alt="这里写图片描述"><br>然后，取 d2 = 2，将原数组分为 2 小组，如下图：<br><img src="http://img.blog.csdn.net/20150813105057829" alt="这里写图片描述"><br>然后分别对 2 个小组进行插入排序，排序后的结果为：<br><img src="http://img.blog.csdn.net/20150813105107871" alt="这里写图片描述"><br>最后，取 d3 = 1，进行插入排序后得到最终结果：<br><img src="http://img.blog.csdn.net/20150813105115894" alt="这里写图片描述"></p>
<h5 id="实现要点"><strong>实现要点</strong></h5><p>首先需要合理选择一个起始步长(增量)d，一般选择d=n/2（n为序列长度），以后每次d=d/2，直至d=1。当选择了一个步长(增量)之后，整个序列被划分成d个子序列，每个子序列的元素为i,i+d,i+2d,…，然后对每个子序列使用直接插入排序进行排序，这里需要注意子序列的元素的间隔是d。当d=1时再进行最后一次直接插入排序，完成之后整个序列也就完成了排序。</p>
<p><strong>Java实现</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">package com.vicky.sort;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 希尔排序</span><br><span class="line"> * </span><br><span class="line"> * 基本思想：</span><br><span class="line"> * 先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（</span><br><span class="line"> * 增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，</span><br><span class="line"> * 因此希尔排序在时间效率上比前两种方法有较大提高。</span><br><span class="line"> * </span><br><span class="line"> * 时间复杂度：根据增量(步长)的不同，最坏情况下的时间复杂度不同。</span><br><span class="line"> * 步长序列		Best	Worst</span><br><span class="line"> * n/2(i)		O(n)	O(n(2))</span><br><span class="line"> * 2(k)-1		O(n)	O(n(3/2))</span><br><span class="line"> * 2(i)3(j)		O(n)	O(nlog(2)n)</span><br><span class="line"> * 来源：https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F(维基百科)</span><br><span class="line"> * </span><br><span class="line"> * 空间复杂度：θ(1)</span><br><span class="line"> * </span><br><span class="line"> * 稳定性：不稳定</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> * </span><br><span class="line"> * @author Vicky</span><br><span class="line"> * @date 2015-8-12</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ShellSort &#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 排序</span><br><span class="line">	 * </span><br><span class="line">	 * @param data</span><br><span class="line">	 *            待排序的数组</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">		<span class="keyword">if</span> (null == data) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"data"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (data.length == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> d = data.length / <span class="number">2</span>;<span class="comment">// 增量</span></span><br><span class="line">		<span class="keyword">while</span> (d &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; i++) &#123;</span><br><span class="line">				<span class="comment">// 对同一组元素进行直接插入排序data[i], data[i+d],..., data[i+nd]</span></span><br><span class="line">				<span class="keyword">int</span> st = i + d;<span class="comment">// 取第二个元素作为分界点</span></span><br><span class="line">				<span class="keyword">for</span> (; st &lt; data.length; st += d) &#123;</span><br><span class="line">					T temp = data[st];</span><br><span class="line">					<span class="keyword">int</span> j = st - d;</span><br><span class="line">					<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp.compareTo(data[j]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">						data[j + d] = data[j];</span><br><span class="line">						j -= d;</span><br><span class="line">					&#125;</span><br><span class="line">					data[j + d] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			d = d / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"use time:"</span> + (System.nanoTime() - start) / <span class="number">1000000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Random ran = <span class="keyword">new</span> Random();</span><br><span class="line">		Integer[] data = <span class="keyword">new</span> Integer[<span class="number">1000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">			data[i] = ran.nextInt(<span class="number">10000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		ShellSort.sort(data);</span><br><span class="line">		System.out.println(Arrays.toString(data));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码使用了泛型，同时附带一个测试。可以将希尔排序的性能与直接插入排序进行对比，当数据量超过1000时，希尔排序的性能明显比直接插入排序快很多倍。</p>
<h5 id="效率分析"><strong>效率分析</strong></h5><p>（1）时间复杂度：希尔排序是直接插入排序的一种改进，故其最优情况下的时间复杂度为O(n)。最坏情况下的时间复杂度根据步长(增量)的选择而不同。下面是摘自维基百科对希尔排序步长选择的介绍：</p>
<blockquote>
<p>Donald Shell最初建议步长选择为n/2并且对步长取半直到步长达到1，虽然这样取可以比O(n^2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项来自9 <em> 4^i - 9 </em> 2^i + 1和2^{i+2} * (2^{i+2} - 3) + 1这两个算式[1]。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序和堆排序都要快，甚至在小数组中比快速排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。</p>
</blockquote>
<table>
<thead>
<tr>
<th>步长序列</th>
<th style="text-align:center">Best复杂度</th>
<th style="text-align:right">Worst复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>n/2^i</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:right">O(n^2)</td>
</tr>
<tr>
<td>2^k-1</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:right">O(n^{3/2})</td>
</tr>
<tr>
<td>2^i3^j</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:right">O(nlog^{2}n)</td>
</tr>
</tbody>
</table>
<p>（2）空间复杂度<br>首先从空间来看，它只需要一个元素的辅助空间，用于元素的位置交换O(1)<br>（3）稳定性:<br>不稳定。 根据步长的不同，相同元素的位置会有变化，所以希尔排序不是稳定排序。</p>
<h5 id="参考文章"><strong>参考文章</strong></h5><p><a href="http://bubkoo.com/2014/01/15/sort-algorithm/shell-sort/" target="_blank" rel="external">常见排序算法 - 希尔排序 (Shell Sort)</a><br><a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="external">希尔排序</a><br><a href="http://notepad.yehyeh.net/Content/Algorithm/Sort/Shell/Shell.php" target="_blank" rel="external">[演算法] 希爾排序法(Shell Sort)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>希尔排序同之前介绍的直接插入排序一起属于插入排序的一种。希尔排序算法是按其设计者希尔（Donald Shell）的名字命名，该算法由1959年公布，是插入排序的一种更高效的改进版本。它的作法不是每次一个元素挨一个元素的比较。而是初期选用大跨步（增量较大）间隔比较，使记录跳跃]]>
    </summary>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="排序" scheme="http://vickyqi.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="排序" scheme="http://vickyqi.com/categories/Java/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[排序算法系列——直接插入排序]]></title>
    <link href="http://vickyqi.com/2015/08/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://vickyqi.com/2015/08/12/排序算法系列——直接插入排序/</id>
    <published>2015-08-12T08:41:00.000Z</published>
    <updated>2015-11-14T11:36:16.000Z</updated>
    <content type="html"><![CDATA[<p>直接插入排序与希尔排序一起属于插入排序的一种。插入适合于针对小数据量进行排序，当数据量很大时插入排序的效率相对其他排序会较低，因为他的时间复杂度是0(n2)(下面会进行分析)。</p>
<h5 id="基本思想"><strong>基本思想</strong></h5><p>一组待排序的数据，首先将其划分成两部分，一部分是已排好序的，另一部分是待排序的，然后依次从待排序部分取出一个数插入到已排序部分的适当位置，保证第一部分始终是已排好序的，等待排序部分全部取出放入已排序部分之后整个排序过程就完成了。</p>
<h5 id="实现要点"><strong>实现要点</strong></h5><p>首先取一个关键点，将关键点前面部分作为已排好序部分，关键点后面部分作为待排序部分，通常取数组中第二数作为关键点，前面部分只有一个数所以是已排好序的，后面是待排序部分。设定关键点之后，针对待排序部分进行遍历，依次取出每个数与已排好序部分进行比较，比较时需要循环对已排好序部分的每个数进行比较，如果小于排好序部分的值则继续比较下一个，直至找到一个大于等于其的数据，将找到的数后面的每个数后移一位，然后将待排序的数插入到找到的数后面即可。<br><strong>Java实现</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package com.vicky.sort;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> 1. &lt;p&gt;</span><br><span class="line"> 2. 插入排序：直接插入排序</span><br><span class="line"> 3. </span><br><span class="line"> 4. 基本思想:</span><br><span class="line"> 5. 将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，</span><br><span class="line"> 6. 直至整个序列有序为止。</span><br><span class="line"> 7. &lt;/p&gt;</span><br><span class="line"> 8. </span><br><span class="line"> 9. @author Vicky</span><br><span class="line"> 10. @date 2015-8-12</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> StraightInsertionSort &#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 排序</span><br><span class="line">	 * </span><br><span class="line">	 * @param data</span><br><span class="line">	 *            待排序的数组</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">		<span class="keyword">if</span> (null == data) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"data"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (data.length == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 选择起始点</span></span><br><span class="line">		<span class="keyword">int</span> st = <span class="number">1</span>;</span><br><span class="line">		T temp;</span><br><span class="line">		<span class="keyword">for</span> (; st &lt; data.length; st++) &#123;</span><br><span class="line">			temp = data[st];</span><br><span class="line">			<span class="keyword">int</span> j = st - <span class="number">1</span>;</span><br><span class="line">			<span class="comment">// 如果比其前一个数大，则无需移动，直接处理下一个</span></span><br><span class="line">			<span class="keyword">if</span> (temp.compareTo(data[j]) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 依次与已排好序部分每个数进行比较，直至找到一个比其小的数或者找到头</span></span><br><span class="line">			<span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; temp.compareTo(data[j]) &lt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">				data[j + <span class="number">1</span>] = data[j];</span><br><span class="line">			&#125;</span><br><span class="line">			data[j + <span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"use time:"</span> + (System.nanoTime() - start) / <span class="number">1000000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Random ran = <span class="keyword">new</span> Random();</span><br><span class="line">		Integer[] data = <span class="keyword">new</span> Integer[<span class="number">100000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">			data[i] = ran.nextInt(<span class="number">10000000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		StraightInsertionSort.sort(data);</span><br><span class="line">		System.out.println(Arrays.toString(data));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码使用了泛型，同时附带一个测试。</p>
<h5 id="效率分析（引自：直接插入排序基本思想）："><strong>效率分析（引自：<a href="http://sjjp.tjuci.edu.cn/sjjg/DataStructure/DS/web/paixu/paixu8.2.1.1.htm" target="_blank" rel="external">直接插入排序基本思想</a>）：</strong></h5><p>（1）时间复杂度<br>        从时间分析，首先外层循环要进行n-1次插入，每次插入最少比较一次（正序），移动两次；最多比较i次，移动i＋2次（逆序）（i=1，2，…，n-1）。若分别用Cmin ，Cmax 和Cave表示元素的总比较次数的最小值、最大值和平均值，用Mmin ，Mmax 和Mave表示元素的总移动次数的最小值、最大值和平均值，则上述直接插入算法对应的这些量为：<br>        Cmin=n-1                                        Mmin=2（n-1）<br>        Cmax=1+2+…+n-1=（n2-n）/2     Mmax=3+4+…+n+1=（n2+3n-4）/2<br>        Cave=（n2+n-2）/4                        Mmax=（n2+7n-8）/4<br>        因此，直接插入排序的时间复杂度为O（n2）。<br>        由上面对时间复杂度的分析可知,当待排序元素已从小到大排好序(正序)或接近排好序时,所用的比较次数和移动次数较少;当待排序元素已从大到小排好序(逆序)或接近排好序时,所用的比较次数和移动次数较多,所以插入排序更适合于原始数据基本有序(正序)的情况.<br>插入法虽然在最坏情况下复杂性为O(n2)，但是对于小规模输入来说，插入排序法是一个快速的排序法。许多复杂的排序法，在规模较小的情况下，都使用插入排序法来进行排序，比如快速排序。<br>（2）空间复杂度<br>        首先从空间来看，它只需要一个元素的辅助空间，用于元素的位置交换O(1)<br>（3）稳定性:<br>        插入排序是稳定的,因为具有同一值的元素必然插在具有同一值得前一个元素的后面,即相对次序不变.<br>（4）结构的复杂性及适用情况<br>        插入排序是一种简单的排序方法,他不仅适用于顺序存储结构(数组),而且适用于链接存储结构,不过在链接存储结构上进行直接插入排序时,不用移动元素的位置,而是修改相应的指针。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>直接插入排序与希尔排序一起属于插入排序的一种。插入适合于针对小数据量进行排序，当数据量很大时插入排序的效率相对其他排序会较低，因为他的时间复杂度是0(n2)(下面会进行分析)。</p>
<h5 id="基本思想"><strong>基本思想</strong></h5><p>一]]>
    </summary>
    
      <category term="Java" scheme="http://vickyqi.com/tags/Java/"/>
    
      <category term="排序" scheme="http://vickyqi.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="Java" scheme="http://vickyqi.com/categories/Java/"/>
    
      <category term="排序" scheme="http://vickyqi.com/categories/Java/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>
