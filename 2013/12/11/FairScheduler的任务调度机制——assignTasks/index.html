<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
    

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.4"/>


    <meta name="description" content="一个不甘做屌丝的程序员" />



  <meta name="keywords" content="FairScheduler,Hadoop,Java,MapReduce,任务调度,源码," />



  <link rel="alternate" href="/atom.xml" title="Vicky's Blog" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.4" />


<meta name="description" content="首先需要了解FairScheduler是如何在各个Pool之间分配资源，以及每个Pool如何在Job之间分配资源的。FairScheduler的分配资源发生在update()方法中，而该方法由一个线程UpdateThread每隔updateInterval（由mapred.fairscheduler.update.interval参数决定，默认是500ms）就调用一次，以保证资源分配的实时性。Fa">
<meta property="og:type" content="article">
<meta property="og:title" content="FairScheduler的任务调度机制——assignTasks">
<meta property="og:url" content="http://vickyqi.com/2013/12/11/FairScheduler的任务调度机制——assignTasks/index.html">
<meta property="og:site_name" content="Vicky's Blog">
<meta property="og:description" content="首先需要了解FairScheduler是如何在各个Pool之间分配资源，以及每个Pool如何在Job之间分配资源的。FairScheduler的分配资源发生在update()方法中，而该方法由一个线程UpdateThread每隔updateInterval（由mapred.fairscheduler.update.interval参数决定，默认是500ms）就调用一次，以保证资源分配的实时性。Fa">
<meta property="og:updated_time" content="2015-10-31T07:08:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="FairScheduler的任务调度机制——assignTasks">
<meta name="twitter:description" content="首先需要了解FairScheduler是如何在各个Pool之间分配资源，以及每个Pool如何在Job之间分配资源的。FairScheduler的分配资源发生在update()方法中，而该方法由一个线程UpdateThread每隔updateInterval（由mapred.fairscheduler.update.interval参数决定，默认是500ms）就调用一次，以保证资源分配的实时性。Fa">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>

    <title> FairScheduler的任务调度机制——assignTasks - Vicky's Blog </title>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-69055865-2', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?1adf407d0fa660f9d712a98579cdac09";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



<div class="container one-column page-post-detail">
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Vicky's Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-categories"></i> <br />
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-tags"></i> <br />
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-about"></i> <br />
            关于
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
<form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'G8S2ksi3eMDfbztLn4xs','2.0.0');
</script>

<div class="site-search-toggle"></div>
    </div>
  
</nav>


        </div>
    </header>

    <main id="main" class="main">
        <div class="main-inner">
            <div id="content" class="content">
                

  <div id="posts" class="posts-expand">
	

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              FairScheduler的任务调度机制——assignTasks
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2013-12-11T00:33:00+08:00" content="2013-12-11">
            2013-12-11
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/Hadoop学习/" itemprop="url" rel="index"><span itemprop="name">Hadoop学习</span></a></span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2013/12/11/FairScheduler的任务调度机制——assignTasks/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2013/12/11/FairScheduler的任务调度机制——assignTasks/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        

		
		<span>&nbsp; | &nbsp;
		<span id="busuanzi_value_page_pv" ></span>次阅读
		</span>    
		
		
      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><p>首先需要了解FairScheduler是如何在各个Pool之间分配资源，以及每个Pool如何在Job之间分配资源的。FairScheduler的分配资源发生在update()方法中，而该方法由一个线程UpdateThread每隔updateInterval（由mapred.fairscheduler.update.interval参数决定，默认是500ms）就调用一次，以保证资源分配的实时性。<br>FairScheduler的资源分配算法由SchedulingAlgorithms的computeFairShares()方法实现，原理是通过二分查找选择出一个使得资源分配数最接近实际资源数的值。具体可以去阅读下<code>SchedulingAlgorithms.computeFairShares()</code>的源码（有点难理解，最好debug下）。<br>下面就来看看FairScheduler如何从众多的任务中选择出一个任务，即任务调度。</p>
<h4 id="FairScheduler-assignTasks()："><strong>FairScheduler.assignTasks()：</strong></h4><p>该方法的调用是发生在JT接收到来自TT的心跳，在返回响应时会根据TT的实际情况选择一个任务交由TT执行，具体可参考<a href="http://blog.csdn.net/vickyway/article/details/17127559" target="_blank" rel="external">Hadoop1.2.1源码解析系列：JT与TT之间的心跳通信机制——JT篇</a>。该方法为指定TT选择一组适合其执行的Task。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute total runnable maps and reduces, and currently running ones</span></span><br><span class="line"><span class="keyword">int</span> runnableMaps = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> runningMaps = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> runnableReduces = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> runningReduces = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Pool pool: poolMgr.getPools()) &#123;</span><br><span class="line">  runnableMaps += pool.getMapSchedulable().getDemand();</span><br><span class="line">  runningMaps += pool.getMapSchedulable().getRunningTasks();</span><br><span class="line">  runnableReduces += pool.getReduceSchedulable().getDemand();</span><br><span class="line">  runningReduces += pool.getReduceSchedulable().getRunningTasks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处计算所有的Pool（资源池）总的runnableMaps（所有Map任务运行所需的Slot数量），runningMaps(运行中的Map任务数量)，runnableReduces（所有Reduce任务运行所需的Slot数量），runningReduces（运行中的Reduce任务数量）。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClusterStatus clusterStatus = taskTrackerManager.getClusterStatus();</span><br><span class="line"><span class="comment">// Compute total map/reduce slots</span></span><br><span class="line"><span class="comment">// In the future we can precompute this if the Scheduler becomes a </span></span><br><span class="line"><span class="comment">// listener of tracker join/leave events.</span></span><br><span class="line"><span class="keyword">int</span> totalMapSlots = getTotalSlots(TaskType.MAP, clusterStatus);</span><br><span class="line"><span class="keyword">int</span> totalReduceSlots = getTotalSlots(TaskType.REDUCE, clusterStatus);</span><br></pre></td></tr></table></figure></p>
<p>接着根据JT获取集群状态，获取totalMapSlots（集群中所有可运行Map的Slot数量）和totalReduceSlots(集群中所有可运行Reduce的Slot数量).<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// <span class="operator"><span class="keyword">Update</span> <span class="keyword">time</span> waited <span class="keyword">for</span> <span class="keyword">local</span> maps <span class="keyword">for</span> jobs skipped <span class="keyword">on</span> <span class="keyword">last</span> heartbeat</span><br><span class="line">updateLocalityWaitTimes(currentTime);</span></span><br></pre></td></tr></table></figure></p>
<p>次数是更新上一次TT发送心跳时没有进行更新time waited for local maps的Job进行更新time waited for local maps。</p>
<h4 id="FairScheduler-updateLocalityWaitTimes："><strong>FairScheduler.updateLocalityWaitTimes：</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Update locality wait times for jobs that were skipped at last heartbeat.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateLocalityWaitTimes</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> timeSinceLastHeartbeat = </span><br><span class="line">    (lastHeartbeatTime == <span class="number">0</span> ? <span class="number">0</span> : currentTime - lastHeartbeatTime);</span><br><span class="line">  lastHeartbeatTime = currentTime;</span><br><span class="line">  <span class="keyword">for</span> (JobInfo info: infos.values()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (info.skippedAtLastHeartbeat) &#123;</span><br><span class="line">      info.timeWaitedForLocalMap += timeSinceLastHeartbeat;</span><br><span class="line">      info.skippedAtLastHeartbeat = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先计算出从上次心跳到现在的时间间隔（timeSinceLastHeartbeat），并更新上次的心跳时间。然后遍历infos（存放JobInProgress–&gt;JobInfo的集合）中skippedAtLastHeartbeat==true的Job的JobInfo，将其timeWaitedForLocalMap值增加timeSinceLastHeartbeat，并将JobInfo的skippedAtLastHeartbeat设为false。回到FairScheduler。</p>
<h4 id="FairScheduler-assignTasks()：-1"><strong>FairScheduler.assignTasks()：</strong></h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Check <span class="keyword">for</span> JT safe-mode</span><br><span class="line"> <span class="keyword">if</span> (taskTrackerManager.isInSafeMode()) &#123;</span><br><span class="line">   <span class="built_in">LOG</span>.info(<span class="string">"JobTracker is in safe-mode, not scheduling any tasks."</span>)<span class="comment">;</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span><span class="comment">;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>检查JT是否处于SafeMode，处于SafeMode不进行任何任务的调度。<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TaskTrackerStatus tts = tracker.getStatus();</span><br><span class="line"></span><br><span class="line">int mapsAssigned = <span class="number">0</span>; // <span class="keyword">loop</span> counter <span class="keyword">for</span> <span class="keyword">map</span> <span class="keyword">in</span> the below <span class="keyword">while</span> <span class="keyword">loop</span></span><br><span class="line">int reducesAssigned = <span class="number">0</span>; // <span class="keyword">loop</span> counter <span class="keyword">for</span> reduce <span class="keyword">in</span> the below <span class="keyword">while</span></span><br><span class="line">int mapCapacity = maxTasksToAssign(TaskType.<span class="keyword">MAP</span>, tts);</span><br><span class="line">int reduceCapacity = maxTasksToAssign(TaskType.REDUCE, tts);</span><br><span class="line"><span class="typename">boolean</span> mapRejected = false; // flag used <span class="keyword">for</span> ending the <span class="keyword">loop</span></span><br><span class="line"><span class="typename">boolean</span> reduceRejected = false; // flag used <span class="keyword">for</span> ending the <span class="keyword">loop</span></span><br><span class="line"></span><br><span class="line">// Keep track <span class="keyword">of</span> which jobs were visited <span class="keyword">for</span> <span class="keyword">map</span> tasks <span class="keyword">and</span> which had tasks</span><br><span class="line">// launched, so that we can later mark skipped jobs <span class="keyword">for</span> delay scheduling</span><br><span class="line">Set&lt;JobInProgress&gt; visitedForMap = <span class="keyword">new</span> HashSet&lt;JobInProgress&gt;();</span><br><span class="line">Set&lt;JobInProgress&gt; visitedForReduce = <span class="keyword">new</span> HashSet&lt;JobInProgress&gt;();</span><br><span class="line">Set&lt;JobInProgress&gt; launchedMap = <span class="keyword">new</span> HashSet&lt;JobInProgress&gt;();</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Task&gt; tasks = <span class="keyword">new</span> ArrayList&lt;Task&gt;();</span><br></pre></td></tr></table></figure></p>
<p>这段代码是初始化一些在调度任务时需要用到的变量，mapsAssigned和reducesAssigned记录已选择的Map/Reduce任务数量，mapCapacity和reduceCapacity记录该TT最大可接收到Map/Reduce任务数量，mapRejected和reduceRejected用来标识是否还可继续接收Map/Reduce任务，visitedForMap和visitedForReduce队列用来记录为寻找可执行的Task而访问的Job，launchedMap队列用来记录选择的Map任务，tasks队列用来存放选择的任务。下面看看maxTasksToAssign()方法是如何计算TT最大可接收的Map/Reduce数量的。</p>
<h4 id="FairScheduler-maxTasksToAssign："><strong>FairScheduler.maxTasksToAssign：</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected <span class="typename">int</span> maxTasksToAssign(TaskType <span class="keyword">type</span>, TaskTrackerStatus tts) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!assignMultiple)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="typename">int</span> <span class="built_in">cap</span> = (<span class="keyword">type</span> == TaskType.MAP) ? mapAssignCap : reduceAssignCap;</span><br><span class="line">  <span class="typename">int</span> availableSlots = (<span class="keyword">type</span> == TaskType.MAP) ?</span><br><span class="line">      tts.getAvailableMapSlots(): tts.getAvailableReduceSlots();</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cap</span> == -<span class="number">1</span>) <span class="comment">// Infinite cap; use the TaskTracker's slot count</span></span><br><span class="line">    <span class="keyword">return</span> availableSlots;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> Math.min(<span class="built_in">cap</span>, availableSlots);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处的assignMultiple变量是由mapred.fairscheduler.assignmultiple参数决定，默认是true，表示是否可同时调度Map和Reduce任务。mapAssignCap和reduceAssignCap变量分别是由mapred.fairscheduler.assignmultiple.maps参数和mapred.fairscheduler.assignmultiple.reduces参数决定，默认值都是-1，表示一次心跳最大可调度的Map/Reduce数量，-1表示无限制。availableSlots表示该TT在发送心跳时可使用的Map/Reduce slot数量，所以接收的任务不能超过该值。</p>
<h4 id="FairScheduler-assignTasks()：-2"><strong>FairScheduler.assignTasks()：</strong></h4><p>下面的代码是一段无限循环，知道满足一定条件才退出，分段来看看循环内部。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!mapRejected) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mapsAssigned == mapCapacity ||</span><br><span class="line">            runningMaps == runnableMaps ||</span><br><span class="line">            !loadMgr.canAssignMap(tts, runnableMaps,</span><br><span class="line">                totalMapSlots, mapsAssigned)) &#123;</span><br><span class="line">          eventLog.<span class="built_in">log</span>(<span class="string">"INFO"</span>, <span class="string">"Can't assign another MAP to "</span> + trackerName);</span><br><span class="line">          mapRejected = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!reduceRejected) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reducesAssigned == reduceCapacity ||</span><br><span class="line">            runningReduces == runnableReduces ||</span><br><span class="line">            !loadMgr.canAssignReduce(tts, runnableReduces,</span><br><span class="line">                totalReduceSlots, reducesAssigned)) &#123;</span><br><span class="line">          eventLog.<span class="built_in">log</span>(<span class="string">"INFO"</span>, <span class="string">"Can't assign another REDUCE to "</span> + trackerName);</span><br><span class="line">          reduceRejected = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (mapRejected &amp;&amp; reduceRejected ||</span><br><span class="line">          !assignMultiple &amp;&amp; tasks.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// This is the only exit of the while (true) loop</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>这一段主要是判断是否退出循环，即通过跟新mapRejected和reduceRejected值来决定是否退出循环。当mapsAssigned==mapCapacity，即已选择的Map数量已达到TT可接收的最大值时，或者runningMaps==runnableMaps，即所有的Map任务都已运行，或者<code>loadMgr.canAssignReduce(tts, runnableReduces,totalReduceSlots, reducesAssigned)</code>返回false，即LoadManager（实现类是CapBasedLoadManager）任务不可再继续调度Map任务。Reduce同上。下面看看LoadManager如何判断是否可以继续调度Map/Reduce任务。</p>
<h4 id="CapBasedLoadManager-LoadManager()："><strong>CapBasedLoadManager.LoadManager()：</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">canAssignMap</span><span class="params">(TaskTrackerStatus tracker,</span><br><span class="line">    <span class="keyword">int</span> totalRunnableMaps, <span class="keyword">int</span> totalMapSlots, <span class="keyword">int</span> alreadyAssigned)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cap = getCap(totalRunnableMaps, tracker.getMaxMapSlots(), totalMapSlots);</span><br><span class="line">  <span class="keyword">return</span> tracker.countMapTasks() + alreadyAssigned &lt; cap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCap</span><span class="params">(<span class="keyword">int</span> totalRunnableTasks, <span class="keyword">int</span> localMaxTasks, <span class="keyword">int</span> totalSlots)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> load = maxDiff + ((<span class="keyword">double</span>)totalRunnableTasks) / totalSlots;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>) Math.<span class="built_in">ceil</span>(localMaxTasks * Math.min(<span class="number">1.0</span>, load));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>maxDiff值由mapred.fairscheduler.load.max.diff参数决定，默认是0.0f。该方法根据集群总的任务运行数与集群总的Slot数量的比例，来判断一个TT应该运行多个任务，据此决定是否继续向TT发送任务。<br>上面根据一定条件判断mapRejected和reduceRejected的值，下面通过判断mapRejected和reduceRejected值以及assignMultiple==false是已选择的tasks数量是否大于0，因为当assignMultiple==false时只能选择一个任务。当判断出需要退出循环时，则直接退出循环。</p>
<h4 id="FairScheduler-assignTasks()：-3"><strong>FairScheduler.assignTasks()：</strong></h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TaskType taskType;</span><br><span class="line"><span class="keyword">if</span> (mapRejected) &#123;</span><br><span class="line">  taskType = TaskType<span class="built_in">.</span>REDUCE;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (reduceRejected) &#123;</span><br><span class="line">  taskType = TaskType<span class="built_in">.</span><span class="built_in">MAP</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// If both types are available, choose the task type with fewer running</span></span><br><span class="line">  <span class="comment">// tasks on the task tracker to prevent that task type from starving</span></span><br><span class="line">  <span class="keyword">if</span> (tts<span class="built_in">.</span>countMapTasks() + mapsAssigned &lt;=</span><br><span class="line">      tts<span class="built_in">.</span>countReduceTasks() + reducesAssigned) &#123;</span><br><span class="line">    taskType = TaskType<span class="built_in">.</span><span class="built_in">MAP</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    taskType = TaskType<span class="built_in">.</span>REDUCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是决定选择Map任务还是Reduce任务。如果mapRejected==true，则选择Reduce任务，相反如何reduceRejected==true，则选择Map任务，当两者都==false时，根据TT上已运行的Map数量+已为该TT选择的Map任务数量与TT上已运行的Reduce数量+已为该TT选择的Reduce任务数量之间的大小决定如何选择，当相等时优选选择Map任务。上面是一些准备工作，下面就开始进行任务的调度了。</p>
<h4 id="FairScheduler-assignTasks()：-4"><strong>FairScheduler.assignTasks()：</strong></h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Get the <span class="built_in">map</span> <span class="built_in">or</span> reduce schedulables <span class="built_in">and</span> <span class="built_in">sort</span> them by fair sharing</span><br><span class="line">List&lt;PoolSchedulable&gt; scheds = getPoolSchedulables(taskType);</span><br><span class="line">Collections.<span class="built_in">sort</span>(scheds, <span class="keyword">new</span> SchedulingAlgorithms.FairShareComparator());</span><br></pre></td></tr></table></figure>
<p>第一句是获取所有的Map/Reduce类型的PoolScheduler。每个Pool中都存放着两个PoolScheduler，一个用来调度Map任务——mapSchedulable，另一个用来调度Reduce任务——reduceSchedulable。然后根据SchedulingAlgorithms.FairShareComparator进行排序，该排序算法主要是根据每个Pool或者Job中运行中的任务与Pool或者Job的自身状态之间的一个比率关系进行排序，即按运行中的任务数/Math.min(minShare,demand)升序排序，按运行中的任务数/weight升序排序。下面看看SchedulingAlgorithms.FairShareComparator类。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> FairShareComparator implements Comparator&lt;Schedulable&gt; &#123;</span><br><span class="line">   @<span class="function">Override</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Schedulable s1, Schedulable s2)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">double</span> minShareRatio1, minShareRatio2;</span><br><span class="line">     <span class="keyword">double</span> tasksToWeightRatio1, tasksToWeightRatio2;</span><br><span class="line">     <span class="keyword">int</span> minShare1 = Math.min(s1.getMinShare(), s1.getDemand());</span><br><span class="line">     <span class="keyword">int</span> minShare2 = Math.min(s2.getMinShare(), s2.getDemand());</span><br><span class="line">     boolean s1Needy = s1.getRunningTasks() &lt; minShare1;</span><br><span class="line">     boolean s2Needy = s2.getRunningTasks() &lt; minShare2;</span><br><span class="line">     minShareRatio1 = s1.getRunningTasks() / Math.max(minShare1, <span class="number">1.0</span>);</span><br><span class="line">     minShareRatio2 = s2.getRunningTasks() / Math.max(minShare2, <span class="number">1.0</span>);</span><br><span class="line">     tasksToWeightRatio1 = s1.getRunningTasks() / s1.getWeight();</span><br><span class="line">     tasksToWeightRatio2 = s2.getRunningTasks() / s2.getWeight();</span><br><span class="line">     <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> (s1Needy &amp;&amp; !s2Needy)</span><br><span class="line">       res = -<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (s2Needy &amp;&amp; !s1Needy)</span><br><span class="line">       res = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (s1Needy &amp;&amp; s2Needy)</span><br><span class="line">       res = (<span class="keyword">int</span>) Math.signum(minShareRatio1 - minShareRatio2);</span><br><span class="line">     <span class="keyword">else</span> <span class="comment">// Neither schedulable is needy</span></span><br><span class="line">       res = (<span class="keyword">int</span>) Math.signum(tasksToWeightRatio1 - tasksToWeightRatio2);</span><br><span class="line">     <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// Jobs are tied in fairness ratio. Break the tie by submit time and job </span></span><br><span class="line">       <span class="comment">// name to get a deterministic ordering, which is useful for unit tests.</span></span><br><span class="line">       res = (<span class="keyword">int</span>) Math.signum(s1.getStartTime() - s2.getStartTime());</span><br><span class="line">       <span class="keyword">if</span> (res == <span class="number">0</span>)</span><br><span class="line">         res = s1.getName().compareTo(s2.getName());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>先说一下：compare(a,b)–&gt;-1，则a,b；compare(a,b)–&gt;1，则b,a（老是记不住）。这个比较算法还是较简单的，原理就是哪个Scheduler中的运行中的任务数越接近其承受能力那么排序就越靠后，这也是很合理的，优先调度较轻松的Scheduler（表达不好，嘿嘿）。排序好了就可以有序的进行任务调度了。</p>
<h4 id="FairScheduler-assignTasks()：-5"><strong>FairScheduler.assignTasks()：</strong></h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> foundTask = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (Schedulable sched: scheds) &#123; <span class="comment">// This loop will assign only one task</span></span><br><span class="line">        eventLog.log(<span class="string">"INFO"</span>, <span class="string">"Checking for "</span> + taskType +</span><br><span class="line">            <span class="string">" task in "</span> + sched.getName());</span><br><span class="line">        <span class="keyword">Task</span> <span class="keyword">task</span> = taskType == TaskType.MAP ? </span><br><span class="line">                    sched.assignTask(tts, currentTime, visitedForMap) : </span><br><span class="line">                    sched.assignTask(tts, currentTime, visitedForReduce);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">task</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">          foundTask = <span class="keyword">true</span>;</span><br><span class="line">          JobInProgress job = taskTrackerManager.getJob(<span class="keyword">task</span>.getJobID());</span><br><span class="line">          eventLog.log(<span class="string">"ASSIGN"</span>, trackerName, taskType,</span><br><span class="line">              job.getJobID(), <span class="keyword">task</span>.getTaskID());</span><br><span class="line">          <span class="comment">// Update running task counts, and the job's locality level</span></span><br><span class="line">          <span class="keyword">if</span> (taskType == TaskType.MAP) &#123;</span><br><span class="line">            launchedMap.add(job);</span><br><span class="line">            mapsAssigned++;</span><br><span class="line">            runningMaps++;</span><br><span class="line">            updateLastMapLocalityLevel(job, <span class="keyword">task</span>, tts);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reducesAssigned++;</span><br><span class="line">            runningReduces++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Add task to the list of assignments</span></span><br><span class="line">          tasks.add(<span class="keyword">task</span>);</span><br><span class="line">          <span class="keyword">break</span>; <span class="comment">// This break makes this loop assign only one task</span></span><br><span class="line">        &#125; <span class="comment">// end if(task != null)</span></span><br><span class="line">      &#125; <span class="comment">// end for(Schedulable sched: scheds)</span></span><br></pre></td></tr></table></figure>
<p>foundTask标志是否选择到任务，每次遍历只选择一个Task，因为每个选择一个Task之后，Scheduler的状态都会发生变化，然后再重新进行排序，再选择。这里可以看出Task的选择是调用Scheduler的assignTask()方法选择的。Scheduler有两个实现，分别是PoolScheduler和JobScheduler，此处是PoolScheduler。下面来看看PoolScheduler的assignTask()方法。</p>
<h4 id="PoolScheduler-assignTask()："><strong>PoolScheduler.assignTask()：</strong></h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Task</span> assignTask(TaskTrackerStatus tts, <span class="keyword">long</span> currentTime,</span><br><span class="line">      Collection&lt;JobInProgress&gt; visited) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">int</span> runningTasks = getRunningTasks();</span><br><span class="line">    <span class="keyword">if</span> (runningTasks &gt;= poolMgr.getMaxSlots(pool.getName(), taskType)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SchedulingMode mode = pool.getSchedulingMode();</span><br><span class="line">    Comparator&lt;Schedulable&gt; comparator;</span><br><span class="line">    <span class="keyword">if</span> (mode == SchedulingMode.FIFO) &#123;</span><br><span class="line">      comparator = <span class="keyword">new</span> SchedulingAlgorithms.FifoComparator();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == SchedulingMode.FAIR) &#123;</span><br><span class="line">      comparator = <span class="keyword">new</span> SchedulingAlgorithms.FairShareComparator();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unsupported pool scheduling mode "</span> + mode);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.<span class="keyword">sort</span>(jobScheds, comparator);</span><br><span class="line">    <span class="keyword">for</span> (JobSchedulable sched: jobScheds) &#123;</span><br><span class="line">      <span class="keyword">Task</span> <span class="keyword">task</span> = sched.assignTask(tts, currentTime, visited);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">task</span> != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">task</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>首先获取该PoolScheduler运行中的Task数量，然后判断如果运行中的任务数大于该Pool的该类型任务（Map/Reduce）的最大数量，则不调度任务，返回null。然后根据<code>SchedulingMode mode = pool.getSchedulingMode()</code>获取Pool的调度模式（FIFO/FAIR），即FairScheduler在对Pool中的Job进行调度时支持两种调度方式：FIFO和FAIR。FIFO：先进先出，先添加的Job先调度，使用<code>SchedulingAlgorithms.FifoComparator</code>比较器；FAIR：根据公平原则进行调度（和Pool的调度一样，也是使用SchedulingAlgorithms.FairShareComparator比较器）。该参数由定义Pool时的schedulingMode参数指定。下面简单说一下FIFO调度规则。<br>FIFO：先根据Hadoop自带的Job的优先级priority（分为5个等级，优先级从高到低依次是：VERY_HIGH，HIGH，NORMAL，LOW，VERY_LOW），由在创建Job时通过mapred.job.priority参数指定，默认是NORMAL。然后根据Job的StartTime进行比较，越早的Job优先调度。<br>FAIR方式和PoolScheduler调度时一样。使用比较器对PoolScheduler中的Job（JobScheduler）进行排序。排序完成之后，遍历JobScheduler，通过调用JobScheduler的assignTask()方法选择任务。下面看看JobScheduler的assignTask()方法。</p>
<h4 id="JobScheduler-assignTask()："><strong>JobScheduler.assignTask()：</strong></h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">Task <span class="title">assignTask</span><span class="params">(TaskTrackerStatus tts, <span class="keyword">long</span> currentTime,</span><br><span class="line">      Collection&lt;JobInProgress&gt; visited)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isRunnable()) &#123;</span><br><span class="line">      visited.add(job);</span><br><span class="line">      TaskTrackerManager ttm = scheduler.taskTrackerManager;</span><br><span class="line">      ClusterStatus clusterStatus = ttm.getClusterStatus();</span><br><span class="line">      <span class="keyword">int</span> numTaskTrackers = clusterStatus.getTaskTrackers();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// check with the load manager whether it is safe to </span></span><br><span class="line">      <span class="comment">// launch this task on this taskTracker.</span></span><br><span class="line">      LoadManager loadMgr = scheduler.getLoadManager();</span><br><span class="line">      <span class="keyword">if</span> (!loadMgr.canLaunchTask(tts, job, taskType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (taskType == TaskType.MAP) &#123;</span><br><span class="line">        LocalityLevel localityLevel = scheduler.getAllowedLocalityLevel(</span><br><span class="line">            job, currentTime);</span><br><span class="line">        scheduler.getEventLog().log(</span><br><span class="line">            <span class="string">"ALLOWED_LOC_LEVEL"</span>, job.getJobID(), localityLevel);</span><br><span class="line">        <span class="keyword">switch</span> (localityLevel) &#123;</span><br><span class="line">          <span class="keyword">case</span> NODE:</span><br><span class="line">            <span class="keyword">return</span> job.obtainNewNodeLocalMapTask(tts, numTaskTrackers,</span><br><span class="line">                ttm.getNumberOfUniqueHosts());</span><br><span class="line">          <span class="keyword">case</span> RACK:</span><br><span class="line">            <span class="keyword">return</span> job.obtainNewNodeOrRackLocalMapTask(tts, numTaskTrackers,</span><br><span class="line">                ttm.getNumberOfUniqueHosts());</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> job.obtainNewMapTask(tts, numTaskTrackers,</span><br><span class="line">                ttm.getNumberOfUniqueHosts());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> job.obtainNewReduceTask(tts, numTaskTrackers,</span><br><span class="line">            ttm.getNumberOfUniqueHosts());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出只有运行中的Job才能调度Task。visited.add(job)将该Job添加到visited队列，表示该Job在任务调度时有被访问过。然后通过LoadManager.canLaunchTask()方法判断是否可以在该TT上运行任务，这里默认是true。针对Map任务需要考虑任务的本地化，即尽可能的使Map任务运行在存放着输入文件的TT上，以提高Map任务运行效率。LocalityLevel localityLevel = scheduler.getAllowedLocalityLevel(job, currentTime)是获取Map任务的一个本地化级别，然后根据本地化级别调用不同方法获取不同的Task，而对于Reduce任务则直接选择一个任务即可。下面看看FairScheduler.getAllowedLocalityLevel()方法。</p>
<h4 id="FairScheduler-getAllowedLocalityLevel()："><strong>FairScheduler.getAllowedLocalityLevel()：</strong></h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JobInfo info = infos.get(job);</span><br><span class="line">    <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123; <span class="comment">// Job not in infos (shouldn't happen)</span></span><br><span class="line">      LOG.error(<span class="string">"getAllowedLocalityLevel called on job "</span> + job</span><br><span class="line">          + <span class="string">", which does not have a JobInfo in infos"</span>);</span><br><span class="line">      <span class="keyword">return</span> LocalityLevel.<span class="keyword">ANY</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (job.nonLocalMaps.<span class="keyword">size</span>() &gt; <span class="number">0</span>) &#123; <span class="comment">// Job doesn't have locality information</span></span><br><span class="line">      <span class="keyword">return</span> LocalityLevel.<span class="keyword">ANY</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先任务的本地化级别存在四个级别：NODE（表示Map的输入文件需要与任务运行的TT在一个节点上），NODEGROUP（表示Map的输入文件需要与任务运行的TT在一个节点组上），RACK（表示Map的输入文件需要与任务运行的TT在一个节机架上），ANY（无任何要求）。首先获取Job的JobInfo信息，如果不存在对应的JobInfo信息则返回LocalityLevel.ANY，如果Job的nonLocalMaps队列不为空也返回LocalityLevel.ANY。nonLocalMaps是在Job进行初始化时通过判断Job的Split如果没有Location则将该Split对应的Map任务添加到nonLocalMaps队列。<br><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pool</span> pool = poolMgr.getPool(job);</span><br><span class="line">    <span class="type">PoolSchedulable</span> sched = pool.getMapSchedulable<span class="literal">()</span>;</span><br><span class="line">    long minShareTimeout = poolMgr.getMinSharePreemptionTimeout(pool.getName<span class="literal">()</span>);</span><br><span class="line">    long fairShareTimeout = poolMgr.getFairSharePreemptionTimeout<span class="literal">()</span>;</span><br><span class="line">    <span class="keyword">if</span> (currentTime - sched.getLastTimeAtMinShare<span class="literal">()</span> &gt; minShareTimeout ||</span><br><span class="line">        currentTime - sched.getLastTimeAtHalfFairShare<span class="literal">()</span> &gt; fairShareTimeout) &#123;</span><br><span class="line">      eventLog.log(<span class="string">"INFO"</span>, <span class="string">"No delay scheduling for "</span></span><br><span class="line">          + job.getJobID<span class="literal">()</span> + <span class="string">" because it is being starved"</span>);</span><br><span class="line">      return <span class="type">LocalityLevel</span>.<span class="type">ANY</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>判断该Job所在的Pool是否处于饥饿状态，是的话则直接返回LocalityLevel.ANY。此处根据Pool的minShareTimeout和fairShareTimeout两个属性值进行判断。Pool的lastTimeAtMinShare和lastTimeAtHalfFairShare值是在FairScheduler的update()方法中更新的，而该方法由一个线程一直调用。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In the common case, compute locality level based on time waited</span></span><br><span class="line">    <span class="keyword">switch</span>(info.lastMapLocalityLevel) &#123;</span><br><span class="line">    <span class="keyword">case</span> NODE: <span class="comment">// Last task launched was node-local</span></span><br><span class="line">      <span class="keyword">if</span> (info.timeWaitedForLocalMap &gt;=</span><br><span class="line">          nodeLocalityDelay + rackLocalityDelay)</span><br><span class="line">        <span class="keyword">return</span> LocalityLevel.<span class="keyword">ANY</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (info.timeWaitedForLocalMap &gt;= nodeLocalityDelay)</span><br><span class="line">        <span class="keyword">return</span> LocalityLevel.RACK;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> LocalityLevel.NODE;</span><br><span class="line">    <span class="keyword">case</span> RACK: <span class="comment">// Last task launched was rack-local</span></span><br><span class="line">      <span class="keyword">if</span> (info.timeWaitedForLocalMap &gt;= rackLocalityDelay)</span><br><span class="line">        <span class="keyword">return</span> LocalityLevel.<span class="keyword">ANY</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> LocalityLevel.RACK;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// Last task was non-local; can launch anywhere</span></span><br><span class="line">      <span class="keyword">return</span> LocalityLevel.<span class="keyword">ANY</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>下面根据Job的lastMapLocalityLevel，即该Job上一次调度Map任务时所选择的的LocalityLevel值决定本次如何进行Map任务的调度。如果lastMapLocalityLevel==NODE，则表示Job上一次调度Map任务是本地化等级是NODE，当等待时间timeWaitedForLocalMap&gt;(nodeLocalityDelay + rackLocalityDelay)这两个属性之和时则选择LocalityLevel.ANY；但是如果timeWaitedForLocalMap只是&gt;nodeLocalityDelay，那么则可以选择RACK级别的本地化，如果timeWaitedForLocalMap<nodelocalitydelay，那么则选择node级别的本地化。timewaitedforlocalmap的值是在fairscheduler的assigntasks()方法中更新的，即fairscheduler开始调度任务之前会先更新fairscheduler上保存的所有job的jobinfo中的timewaitedforlocalmap值，已确保后面能够正确选择map任务的本地化级别。当lastmaplocalitylevel==rack时，只需要timewaitedforlocalmap>=rackLocalityDelay就可以返回ANY，否则返回RACK；默认返回RACK。这里就计算出在选择Map任务时的本地化级别，之后Job在选择Map任务时会根据本地化级别选择不同的任务进行运行。回到JobScheduler.assignTask()方法。</nodelocalitydelay，那么则选择node级别的本地化。timewaitedforlocalmap的值是在fairscheduler的assigntasks()方法中更新的，即fairscheduler开始调度任务之前会先更新fairscheduler上保存的所有job的jobinfo中的timewaitedforlocalmap值，已确保后面能够正确选择map任务的本地化级别。当lastmaplocalitylevel==rack时，只需要timewaitedforlocalmap></p>
<h4 id="JobScheduler-assignTask()：-1"><strong>JobScheduler.assignTask()：</strong></h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (localityLevel) &#123;</span><br><span class="line">          <span class="keyword">case</span> NODE:</span><br><span class="line">            <span class="keyword">return</span> job.obtainNewNodeLocalMapTask(tts, numTaskTrackers,</span><br><span class="line">                ttm.getNumberOfUniqueHosts());</span><br><span class="line">          <span class="keyword">case</span> RACK:</span><br><span class="line">            <span class="keyword">return</span> job.obtainNewNodeOrRackLocalMapTask(tts, numTaskTrackers,</span><br><span class="line">                ttm.getNumberOfUniqueHosts());</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> job.obtainNewMapTask(tts, numTaskTrackers,</span><br><span class="line">                ttm.getNumberOfUniqueHosts());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这是在选择Map任务时根据本地化级别会调用不同的方法选择不同的任务。主要是obtainNewNodeLocalMapTask()，obtainNewNodeOrRackLocalMapTask()，obtainNewMapTask()三个方法，以及选择Reduce任务的obtainNewReduceTask()方法。这四个方法内部还是有点复杂的下次再深入分析。<br>到这里JobScheduler的assignTask()就完成了，返回Task，回到PoolScheduler的assignTask()方法，可以看到只要得到一个Task，PoolScheduler就会返回该Task，所以继续回到FairScheduler的assignTask()方法。在FairScheduler的assignTask()方法中可以看到，当返回一个Task之后会标志foundTask=true，如果是Map任务则会将Task对应的Job添加到launchedMap中，然后调用updateLastMapLocalityLevel()方法更新Job的JobInfo的lastMapLocalityLevel和timeWaitedForLocalMap值，以便下次正确的选择Map任务。</p>
<h4 id="FairScheduler-assignTask()："><strong>FairScheduler.assignTask()：</strong></h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">if</span> (!foundTask) &#123;</span><br><span class="line">        <span class="title">if</span> (taskType == TaskType.MAP) &#123;</span><br><span class="line">          <span class="title">mapRejected</span> = <span class="built_in">true</span>;</span><br><span class="line">        &#125; <span class="title">else</span> &#123;</span><br><span class="line">          <span class="title">reduceRejected</span> = <span class="built_in">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>该处很简单，判断如果没有选到Map任务或者Reduce任务，则将相应的标志设为true。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (JobInProgress job: visitedForMap) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!launchedMap.<span class="keyword">contains</span>(job)) &#123;</span><br><span class="line">        infos.<span class="keyword">get</span>(job).skippedAtLastHeartbeat = <span class="constant">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>visitedForMap该值在进行调度Map任务时每访问一个Job都会被记录在该队列中，如果被访问的Job并不在launchedMap队列（存放被选中Map任务的Job）中，则将该Job对应的JobInfo的skippedAtLastHeartbeat参数设为true，表示本次心跳没有选择该Job的Map任务。这个skippedAtLastHeartbeat参数会影响Job的timeWaitedForLocalMap值，具体可以参考FairScheduler的updateLocalityWaitTimes()方法。</p>
<hr>
<p>以上就是FairScheduler调度任务源码的一些简单的解析，如有错误之处，请指出，谢谢。</p>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/FairScheduler/" rel="tag">#FairScheduler</a>
          
            <a href="/tags/Hadoop/" rel="tag">#Hadoop</a>
          
            <a href="/tags/Java/" rel="tag">#Java</a>
          
            <a href="/tags/MapReduce/" rel="tag">#MapReduce</a>
          
            <a href="/tags/任务调度/" rel="tag">#任务调度</a>
          
            <a href="/tags/源码/" rel="tag">#源码</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2013/12/15/FairScheduler的任务调度机制——assignTasks（续）/" rel="prev">FairScheduler的任务调度机制——assignTasks（续）</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2013/11/21/FairScheduler job初始化过程源码浅析/" rel="next">FairScheduler job初始化过程源码浅析</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>

 
	
    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2013/12/11/FairScheduler的任务调度机制——assignTasks/"
     data-title="FairScheduler的任务调度机制——assignTasks"
     data-content=""
     data-url="http://vickyqi.com/2013/12/11/FairScheduler的任务调度机制——assignTasks/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


            </div>

            

            
              <div class="comments" id="comments">
                
                  <div class="ds-thread" data-thread-key="2013/12/11/FairScheduler的任务调度机制——assignTasks/"
                       data-title="FairScheduler的任务调度机制——assignTasks" data-url="http://vickyqi.com/2013/12/11/FairScheduler的任务调度机制——assignTasks/">
                  </div>
                
              </div>
            
        </div>

        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/Vicky.jpg" alt="Vicky" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Vicky</p>
        </div>
        <p class="site-description motion-element" itemprop="description">一个不甘做屌丝的程序员</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">20</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">26</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/vickyqi" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/vickyway" target="_blank">csdn</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#FairScheduler-assignTasks()："><span class="nav-number">1.</span> <span class="nav-text">FairScheduler.assignTasks()：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FairScheduler-updateLocalityWaitTimes："><span class="nav-number">2.</span> <span class="nav-text">FairScheduler.updateLocalityWaitTimes：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FairScheduler-assignTasks()：-1"><span class="nav-number">3.</span> <span class="nav-text">FairScheduler.assignTasks()：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FairScheduler-maxTasksToAssign："><span class="nav-number">4.</span> <span class="nav-text">FairScheduler.maxTasksToAssign：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FairScheduler-assignTasks()：-2"><span class="nav-number">5.</span> <span class="nav-text">FairScheduler.assignTasks()：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CapBasedLoadManager-LoadManager()："><span class="nav-number">6.</span> <span class="nav-text">CapBasedLoadManager.LoadManager()：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FairScheduler-assignTasks()：-3"><span class="nav-number">7.</span> <span class="nav-text">FairScheduler.assignTasks()：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FairScheduler-assignTasks()：-4"><span class="nav-number">8.</span> <span class="nav-text">FairScheduler.assignTasks()：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FairScheduler-assignTasks()：-5"><span class="nav-number">9.</span> <span class="nav-text">FairScheduler.assignTasks()：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PoolScheduler-assignTask()："><span class="nav-number">10.</span> <span class="nav-text">PoolScheduler.assignTask()：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JobScheduler-assignTask()："><span class="nav-number">11.</span> <span class="nav-text">JobScheduler.assignTask()：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FairScheduler-getAllowedLocalityLevel()："><span class="nav-number">12.</span> <span class="nav-text">FairScheduler.getAllowedLocalityLevel()：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JobScheduler-assignTask()：-1"><span class="nav-number">13.</span> <span class="nav-text">JobScheduler.assignTask()：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FairScheduler-assignTask()："><span class="nav-number">14.</span> <span class="nav-text">FairScheduler.assignTask()：</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
        <div class="footer-inner">
            <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Vicky</span>
</div>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

总共被光顾 <span id="busuanzi_value_site_pv"></span> 次 &nbsp|&nbsp
恭喜，您排第 <span id="busuanzi_value_site_uv"></span> 位



        </div>
    </footer>

    <div class="back-to-top"></div>
</div>

<script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"vickyqi"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('footer')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     
  	  <script type="text/javascript">
  		var duoshuo_user_ID = 13969606
  	  </script>
     
  	<script src="/js/ua-parser.min.js"></script>
  	<script src="/js/hook-duoshuo.js"></script>
  

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.4"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.4"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.4" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>


  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.4" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



<script type="text/javascript">
    $(document).ready(function () {
        if (CONFIG.sidebar === 'always') {
            displaySidebar();
        }
    });
</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>







<!-- lazyload -->
<script type="text/javascript" src="/js/lazyload.js"></script>
<script type="text/javascript">
    jQuery(function () {
        jQuery("#posts img").lazyload({
            placeholder: "/images/loading.gif",
            effect: "fadeIn"
        });
    });
</script>
</body>
</html>
